["```js\nvar connect = require(\"connect\"),\n    app = connect(); // create the application\n\n// add a favicon for browsers\napp.use(connect.favicon());\n\n// require a simple username/password to access\napp.use(connect.basicAuth(\"username\", \"password\"));\n\n// this middleware simply responds with \"Hello World\" to every request\n// that isn't responded to by previous middleware (i.e. favicon)\napp.use(function (req, res) {\n    res.end(\"Hello World\");\n});\n\n// app is a thin wrapper around Node's http.Server\n// so many of the same methods are available\napp.listen(3000);\n\nconsole.log(\"Server available at http://localhost:3000/\");\n```", "```js\nvar express = require('express'),\n    app = express();\n\napp.use(express.favicon());\napp.use(express.basicAuth(\"username\", \"password\"));\n\napp.get(\"/\", function (req, res) {\n    res.send('Hello World');\n});\n\napp.listen(3000);\n```", "```js\napp.use(express.basicAuth(\"admin\", \"123456\"));\n```", "```js\nvar users = {\n    // username: \"password\"\n    admin: \"password\",\n    user: \"123456\"\n};\n\napp.use(express.basicAuth(function (user, pass) {\n    return users.hasOwnProperty(user) && users[user] === pass;\n}));\n```", "```js\napp.use(express.basicAuth(function (user, pass, done) {\n    User.authenticate({ username: user, password: pass }, done);\n}));\n```", "```js\n// module dependencies\nvar passport = require(\"passport\"),\n    LocalStrategy = require(\"passport-local\").Strategy;\n\n// LocalStrategy means we perform the authentication ourselves\npassport.use(new LocalStrategy(\n    // this callback function performs the authentication check\n    function (username, password, done) {\n        // this is just a mock API call\n        User.findOne({ username: username }, function (err, user) {\n            // if a fatal error of some sort occurred, pass that along\n            if (err) {\n                done(err);\n            // if we don't find a valid user\n            } else if (!user || !user.validPassword(password)) {\n                done(null, false, { message: \"Incorrect username and password combination.\" });\n\n            // otherwise, this was a successful authentication\n            } else {\n                done(null, user);\n            }\n        });\n    }\n));\n```", "```js\nvar express = require(\"express\"),\n    app = express();\n\n// application middleware\napp.use(express.cookieParser());\napp.use(express.bodyParser());\napp.use(express.session({ secret: \"long random string \u2026 \" }));\n\n// initialize passport\napp.use(passport.initialize());\napp.use(passport.session()); // optional session support\n\n// more application middleware\napp.use(app.router);\n```", "```js\npassport.serializeUser(function (user, done) {\n    // only store the user's ID in the session (to keep it light)\n    done(null, user.id);\n});\n\npassport.deserializeUser(function (id, done) {\n    // we can retrieve the user's information based on the ID\n    User.findById(id, function (err, user) {\n        done(err, user);\n    });\n});\n```", "```js\nvar passport = require('passport'),\n    OpenIDStrategy = require('passport-openid').Strategy;\n\n// configure the OpenID Strategy\npassport.use(new OpenIDStrategy(\n    {\n        // the URL that the provider will redirect the user to\n        returnURL: 'http://www.example.com/auth/openid/return',\n        // the realm should identify your application to the User\n        realm: 'http://www.example.com/'\n    },\n    // this verify callback has 2 arguments:\n    // identifier: the ID for your user (who they claim to be)\n    // done: the callback to issue after you've looked the user up\n    function (id, done) {\n        // this is a generic API, it could be any async operation\n        User.findOrCreate({ openId: id }, function (err, user) {\n            done(err, user);\n        });\n    }\n));\n```", "```js\n// this route accepts the user\"s login request, passport handles the redirect\n// over to the Provider for authentication\napp.post(\"/auth/openid\", passport.authenticate(\"openid\"));\n\n// the Provider will redirect back to this URL (based on our earlier\n// configuration of the strategy) and it will tell us whether or not\n// the authentication was successful\napp.get(\"/auth/openid/return\", passport.authenticate(\"openid\", {\n    // if successful, we'll redirect the user to the hame page\n    successRedirect: \"/\",\n    // otherwise, send back to the login page\n    failureRedirect: \"/login\"\n}));\n```", "```js\n<form action=\"/auth/openid\" method=\"post\">\n    <div>\n        <label>OpenID:</label>\n        <input type=\"text\" name=\"openid_identifier\"/><br/>\n    </div>\n    <div>\n        <input type=\"submit\" value=\"Sign In\"/>\n    </div>\n</form>\n```", "```js\nvar passport = require('passport'),\n    FacebookStrategy = require('passport-facebook').Strategy;\n\n// configuring the Facebook strategy (OAuth v2.0)\npassport.use(new FacebookStrategy(\n    {\n        // developers must register their application with Facebook\n        // this is where the ID/Secret are obtained\n        clientID: FACEBOOK_APP_ID,\n        clientSecret: FACEBOOK_APP_SECRET,\n\n        // this is the URL that Facebook will redirect the user to\n        callbackURL: \"http://www.example.com/auth/facebook/callback\"\n    },\n\n    // the verify callback has 4 arguments here:\n    // accessToken: the token Facebook uses to verify authentication\n    // refreshToken: used to extend the lifetime of the accessToken\n    // profile: the user's shared information\n    // done: the callback function\n    function (accessToken, refreshToken, profile, done) {\n        // here is where your application connects the 2 accounts\n        User.findOrCreate(..., function (err, user) {\n            done(err, user);\n        });\n    }\n));\n```", "```js\n// redirects the User to Facebook for authentication\napp.get(\"/auth/facebook\", passport.authenticate(\"facebook\"));\n\n// Facebook will redirect back to this URL based on the strategy configuration\napp.get(\"/auth/facebook/callback\", passport.authenticate(\"facebook\", {\n    successRedirect: \"/\",\n    failureRedirect: \"/login\"\n}));\n```", "```js\n<a href=\"/auth/facebook\">Login with Facebook</a>\n```", "```js\nfunction restrict(req, res, next) {\n    if (req.user) {\n        return next();\n    } else {\n        res.send(403); // Forbidden\n    }\n}\n\napp.get(\"/restricted\", restrict, function (req, res) {\n    res.send(\"Hello, \" + req.user);\n});\n```", "```js\n// dummy user data\nvar users = [\n    { id: 1, name: \"dominic\", role: \"admin\" },\n    { id: 2, name: \"matthew\", role: \"member\" },\n    { id: 3, name: \"gabriel\", role: \"member\" }\n];\n\n// middleware for loading a user based on a :user param in the route\nfunction loadUser(req, res, next) {\n    req.userData = users[req.params.user];\n    return next();\n}\n\n// middleware for restricting a route to only a specified role name\nfunction requireRole(role) {\n    // returns a function, closure allows us to access the role variable\n    return function (req, res, next) {\n        // check if the logged-in user's role is correct\n        if (req.user.role === role) {\n            return next();\n        } else {\n            return next(new Error(\"Unauthorized\"));\n        }\n    };\n}\n\n// this route only loads a user's data (so it is loaded via middleware)\napp.get(\"/users/:user\", loadUser, function (req, res) {\n    res.send(req.user.name);\n});\n\n// this route can only be called upon by an admin\napp.del(\"/users/:user\", requireRole(\"admin\"), loadUser, function (req, res) {\n    res.send(\"User deleted\");\n});\n```", "```js\nvar winston = require('winston');\nwinston.log(\"info\", \"Hello World\");\nwinston.info(\"Hello Again\");\n```", "```js\nvar winston = require(\"winston\");\n\nvar logger = new (winston.Logger)({\n    transports: [\n        new (winston.transports.Console)(),\n        new (winston.transports.File)({ filename: 'somefile.log' })\n    ]\n});\n```", "```js\nvar path = require(\"path\"),\n    winston = require(\"winston\");\n\nmodule.exports = new (winston.Logger)({\n    transports: [\n        // only logs errors to the console\n        new (winston.transports.Console)({\n            level: \"error\"\n        }),\n        // all logs will be saved to this app.log file\n        new (winston.transports.File)({\n            filename: path.resolve(__dirname, \"../logs/app.log\")\n        }),\n        // only errors will be saved to errors.log, and we can examine \n        // to app.log for more context and details if needed.\n        new (winston.transports.File)({\n            level: \"error\",\n            filename: path.resolve(__dirname, \"../logs/errors.log\")\n        })\n    ]\n});\n```", "```js\nvar logger = require(\"./lib/logger\");\nlogger.log(\"info\", \"Hello World\");\nlogger.info(\"Hello Again\");\n```", "```js\napp.get(\"/throw/now\", function (req, res) {\n    // Express wraps the route handler invocation in try/catch, so\n    // this will be handled without crashing the server\n    throw new Error(\"I will not crash the server;\n});\n\napp.get(\"/throw/async\", function (req, res) {\n    // However, when performing some asynchronous operation\n    // time) then you will lose your server if you throw\n    setTimeout(function () {\n        // try/catch does not work on callbacks/asynchronous code!\n        throw new Error(\"I WILL crash the server\");\n    }, 100);\n});\n```", "```js\napp.get(\"/next\", function (req, res, next) {\n    // this is the correct way to handle errors, as Express will\n    // delegate the error to special middleware\n    return next(new Error(\"I'm passed to Express\"));\n});\n```", "```js\n// 4 arguments tells Express that the middleware is for errors\n// you can have more than 1 if necessary\napp.use(function (err, req, res, next) {\n    console.trace();\n    console.error(err);\n\n    // just responds with a 500 status code and the error message\n    res.send(500, err.message);\n});\n```", "```js\napp.use(express.errorHandler());\n```"]