["```js\nvar assert = require('assert');\nvar mp3dat = require('../index.js');\nvar testFile = 'test/test.mp3';\n\n```", "```js\n{ duration: { hours: 0, minutes: 0, seconds: 5, milliseconds: 186 },\n  bitrate: 128000,\n  filesize: 82969,\n  timestamp: 5186,\n  timesig: '00:00:05' }\n\n```", "```js\nassert(mp3dat, 'mp3dat failed to load');\n\nassert(mp3dat.stat, 'there should be a stat method');\n\nassert(mp3dat.stat instanceof Function, 'stat should be a Function');\n\n```", "```js\nmp3dat.stat(testFile, function (err, stats) {\n\n  assert.ifError(err);\n\n  //expected properties\n  assert(stats.duration, 'should be a truthy duration property');\n  assert(stats.bitrate, 'should be a truthy bitrate property');\n  assert(stats.filesize, 'should be a truthy filesize property');\n  assert(stats.timestamp, 'should be a truthy timestamp property');\n  assert(stats.timesig, 'should be a truthy timesig property');\n\n```", "```js\n  //expected types\n  assert.equal(typeof stats.duration, 'object', 'duration should be an object type');\n  assert(stats.duration instanceof Object, 'durations should be an instance of Object');\n  assert(!isNaN(stats.bitrate), 'bitrate should be a number');\n  assert(!isNaN(stats.filesize), 'filesize should be a number');\n  assert(!isNaN(stats.timestamp), 'timestamp should be a number');\n\n  assert(stats.timesig.match(/^\\d+:\\d+:\\d+$/), 'timesig should be in HH:MM:SS format');\n\n  //expected duration properties\n  assert.notStrictEqual(stats.duration.hours, undefined,  'should be a duration.hours property');\n  assert.notStrictEqual(stats.duration.minutes, undefined, 'should be a duration.minutes property');\n  assert.notStrictEqual(stats.duration.seconds, undefined, 'should be a duration.seconds property');\n  assert.notStrictEqual(stats.duration.milliseconds, undefined, 'should be a duration.milliseconds property');\n\n  //expected duration types\n  assert(!isNaN(stats.duration.hours), 'duration.hours should be a number');\n  assert(!isNaN(stats.duration.minutes), 'duration.minutes should be a number');\n  assert(!isNaN(stats.duration.seconds), 'duration.seconds should be a number');\n  assert(!isNaN(stats.duration.milliseconds), 'duration.milliseconds should be a number');\n\n  //expected duration properties constraints\n  assert(stats.duration.minutes < 60, 'duration.minutes should be no greater than 59');\n  assert(stats.duration.seconds < 60, 'duration.seconds should be no greater than 59');\n  assert(stats.duration.milliseconds < 1000, 'duration.seconds should be no greater than 999');\n\n  console.log('All tests passed');  //if we've gotten this far we are done.\n});\n\n```", "```js\nnode test \n\n```", "```js\nAssertionError: there should be a stat method\n\n```", "```js\nassert(mp3dat.stat, 'there should be a stat method');\n\n```", "```js\nnpm install should \n\n```", "```js\nvar should = require('should');\nvar mp3dat = require('../index.js');\nvar testFile = 'test/test.mp3';\n\nshould.exist(mp3dat);\nmp3dat.should.have.property('stat');\nmp3dat.stat.should.be.an.instanceof(Function);\n\nmp3dat.stat(testFile, function (err, stats) {\n  should.ifError(err);\n\n  //expected properties\n  stats.should.have.property('duration');\n  stats.should.have.property('bitrate');\n  stats.should.have.property('filesize');    \n  stats.should.have.property('timestamp');\n  stats.should.have.property('timesig');  \n\n  //expected types\n  stats.duration.should.be.an.instanceof(Object);\n  stats.bitrate.should.be.a('number');\n  stats.filesize.should.be.a('number');\n  stats.timestamp.should.be.a('number');  \n\n  stats.timesig.should.match(/^\\d+:\\d+:\\d+$/);\n\n  //expected duration properties\n  stats.duration.should.have.keys('hours', 'minutes', 'seconds', 'milliseconds');\n\n  //expected duration types and constraints\n  stats.duration.hours.should.be.a('number');\n  stats.duration.minutes.should.be.a('number').and.be.below(60);\n  stats.duration.seconds.should.be.a('number').and.be.below(60);\n  stats.duration.milliseconds.should.be.a('number').and.be.below(1000);  \n\n  console.log('All tests passed');\n\n});\n\n```", "```js\nmodule.exports = require('./lib');\n\n```", "```js\nvar fs = require('fs');\n\n//half-byte (4bit) hex values to interpreted bitrates (bps)\n//only MPEG-1 bitrates supported\nvar bitrates = { 1 : 32000, 2 : 40000, 3 : 48000, 4 : 56000, 5 : 64000,\n  6 : 80000, 7 : 96000, 8 : 112000, 9 : 128000, A : 160000, B : 192000,\n  C : 224000, D : 256000, E : 320000 };\n\n```", "```js\nfunction buildStats(bitrate, size, cb) {\n  var magnitudes = [ 'hours', 'minutes', 'seconds', 'milliseconds'],\n    duration = {}, stats,\n    hours = (size / (bitrate / 8) / 3600);\n\n  (function timeProcessor(time, counter) {\n      var timeArray = [], factor = (counter < 3) ? 60 : 1000 ;\n      if (counter) {        \n        timeArray = (factor * +('0.' + time)).toString().split('.');\n      }\n\n      if (counter < magnitudes.length - 1) {\n        duration[magnitudes[counter]] = timeArray[0] || Math.floor(time);\n        duration[magnitudes[counter]] = +duration[magnitudes[counter]];\n        counter += 1;\n        timeProcessor(timeArray[1] || time.toString().split('.')[1], counter);\n        return;\n      }\n        //round off the final magnitude\n        duration[magnitudes[counter]] = Math.round(timeArray.join('.'));\n  }(hours, 0));\n\n  stats = {\n    duration: duration,\n    bitrate: bitrate,\n    filesize: size,\n    timestamp: Math.round(hours * 3600000),\n    timesig: ''\n  };\n\n  function pad(n){return n < 10 ? '0'+n : n}  \n   magnitudes.forEach(function (mag, i) {\n   if (i < 3) {\n    stats.timesig += pad(duration[mag]) + ((i < 2) ? ':' : '');\n   }\n  });\n\n  cb(null, stats);\n}\n\n```", "```js\nfunction findBitRate(f, cb) {\n   fs.createReadStream(f)\n    .on('data', function (data) {\n      var i;\n      for (i = 0; i < data.length; i += 2) {\n        if (data.readUInt16LE(i) === 64511) {\n          this.destroy();\n          cb(null, bitrates[data.toString('hex', i + 2, i + 3)[0]]);\n          break;\n        };\n    }\n  }).on('end', function () {\n    cb(new Error('could not find bitrate, is this definitely an MPEG-1 MP3?'));\n  });   \n}\n\n```", "```js\nexports.stat = function (f, cb) {\n  fs.stat(f, function (err, fstats) {\n    findBitRate(f, function (err, bitrate) {\n      if (err) { cb(err); return; }\n      buildStats(bitrate, fstats.size, cb);    \n    });\n  });\n}\n\n```", "```js\nnode test \n\n```", "```js\nAll tests passed\n\n```", "```js\nvar mp3dat = require('mp3dat');\n\n```", "```js\nvar mp3dat = require('../index.js');\n\nmp3dat.stat('../test/test.mp3', function (err, stats) {\n  console.log(stats);\n});\n\n```", "```js\n{ duration: { hours: 0, minutes: 0, seconds: 5, milliseconds: 186 },\n  bitrate: 128000,\n  filesize: 82969,\n  timestamp: 5186,\n  timesig: '00:00:05' }\n\n```", "```js\nvar fs = require('fs');\n\nfunction Mp3dat(f, size) {\n  if (!(this instanceof Mp3dat)) {\n    return new Mp3dat(f, size);\n  }\n  this.stats = {duration:{}};\n}\n\n```", "```js\nMp3dat.prototype._bitrates = { 1 : 32000, 2 : 40000, 3 : 48000, 4 : 56000, 5 : 64000, 6 : 80000, 7 : 96000, 8 : 112000, 9 : 128000, A : 160000, B : 192000, C : 224000, D : 256000, E : 320000 };\n\nMp3dat.prototype._magnitudes = [ 'hours', 'minutes', 'seconds', 'milliseconds'];\n\nMp3dat.prototype._pad = function (n) { return n < 10 ? '0' + n : n; }  \n\nMp3dat.prototype._timesig = function () {\n  var ts = '', self = this;;\n  self._magnitudes.forEach(function (mag, i) {\n   if (i < 3) {\n    ts += self._pad(self.stats.duration[mag]) + ((i < 2) ? ':' : '');\n   }\n  });\n  return ts;\n}\n\n```", "```js\nMp3dat.prototype._findBitRate = function(cb) {\n  var self = this;\n   fs.createReadStream(self.f)\n    .on('data', function (data) {\n      var i = 0;\n       for (i; i < data.length; i += 2) {\n        if (data.readUInt16LE(i) === 64511) {\n          self.bitrate = self._bitrates[data.toString('hex', i + 2, i + 3)[0]];\n          this.destroy();\n          cb(null);\n          break;\n        };\n    }\n  }).on('end', function () {\n    cb(new Error('could not find bitrate, is this definitely an MPEG-1 MP3?'));\n  });\n}\n\n```", "```js\nMp3dat.prototype._buildStats = function (cb) {\n  var self = this,\n  hours = (self.size / (self.bitrate / 8) / 3600);\n\n  self._timeProcessor(hours, function (duration) {\n    self.stats = {\n      duration: duration,\n      bitrate: self.bitrate,\n      filesize: self.size,\n      timestamp: Math.round(hours * 3600000),\n      timesig: self._timesig(duration, self.magnitudes)\n    };\n    cb(null, self.stats);\n\n  });\n}\n\n```", "```js\nMp3dat.prototype._timeProcessor = function (time, counter, cb) {\n  var self = this, timeArray = [], factor = (counter < 3) ? 60 : 1000,\n    magnitudes = self._magnitudes, duration = self.stats.duration;\n\n  if (counter instanceof Function) {\n    cb = counter;\n    counter = 0;\n  }\n\n  if (counter) {        \n    timeArray = (factor * +('0.' + time)).toString().split('.');\n  }\n  if (counter < magnitudes.length - 1) {\n    duration[magnitudes[counter]] = timeArray[0] || Math.floor(time);\n    duration[magnitudes[counter]] = +duration[magnitudes[counter]];\n    counter += 1;\n    self._timeProcessor.call(self, timeArray[1] || time.toString().split('.')[1], counter, cb);\n    return;\n  }\n    //round off the final magnitude (milliseconds)\n    duration[magnitudes[counter]] = Math.round(timeArray.join('.'));\n    cb(duration);\n}\n\n```", "```js\nMp3dat.prototype.stat = function (f, cb) {\n  var self = this;\n  fs.stat(f, function (err, fstats) {\n    self.size = fstats.size;\n    self.f = f;\n    self._findBitRate(function (err, bitrate) {\n      if (err) { cb(err); return; }\n      self._buildStats(cb);\n    });    \n  });\n}\n\nmodule.exports = Mp3dat();\n\n```", "```js\nnode test \n\n```", "```js\nAll tests passed\n\n```", "```js\n  if (!(this instanceof Mp3dat)) {\n    return new Mp3dat();\n  }\n\n```", "```js\n{ stats:\n   { duration: { hours: 0, minutes: 0, seconds: 5, milliseconds: 186 },\n     bitrate: 128000,\n     filesize: 82969,\n     timestamp: 5186,\n     timesig: '00:00:05' },\n  size: 82969,\n  f: 'test/test.mp3',\n  bitrate: 128000 }\n\n```", "```js\n{ stat: [Function] }\n\n```", "```js\nfunction Mp3dat() {\n  var self = this;\n  if (!(this instanceof Mp3dat)) {\n    return new Mp3dat();\n  }\n  self.stat = function (f, cb) {\n    fs.stat(f, function (err, fstats) {\n      self.size = fstats.size;\n      self.f = f;\n      self._findBitRate(function (err, bitrate) {\n        if (err) { cb(err); return; }\n        self._buildStats(cb);\n      });    \n    });\n  }  \n  self.stats = {duration:{}};\n}\n\n```", "```js\n{ stat: [Function],\n  stats:\n   { duration: { hours: 0, minutes: 0, seconds: 5, milliseconds: 186 },\n     bitrate: 128000,\n     filesize: 82969,\n     timestamp: 5186,\n     timesig: '00:00:05' },\n  size: 82969,\n  f: 'test/test.mp3',\n  bitrate: 128000 }\n\n```", "```js\nmodule.exports = Mp3dat()\n\n```", "```js\nexports.stat = function (f, cb) {\n  var m = Mp3dat();\n  return Mp3dat.prototype.stat.call(m, f, cb);\n}\n\n```", "```js\n{ stat: [Function] }\n\n```", "```js\nmodule.exports = Mp3dat()\n\n```", "```js\nmodule.exports = Mp3dat\n\n```", "```js\nvar Mp3dat = require('../index.js'),\n\tmp3dat = Mp3dat(),\n      mp3dat2 = Mp3dat();\n\n```", "```js\nMp3dat.prototype.spawnInstance = function () {\n  return Mp3dat();\n}\n\nmodule.exports = Mp3dat();\n\n```", "```js\nvar mp3dat = require('../index.js'),\n   mp3dat2 = mp3dat.spawnInstance();\n\n```", "```js\nvar mp3dat = require('../index.js'),\n   mp3dat2 = require('../index.js');\n\n```", "```js\nfunction cb (err, stats) {\n  should.ifError(err);\n\n  //expected properties\n  stats.should.have.property('duration');\n\n  //...all the other unit tests here\n\n  console.log('passed');\n\n};\n\n```", "```js\nmp3dat.statStream({stream: fs.createReadStream(testFile),\n  size: fs.statSync(testFile).size}, cb);\n\nmp3dat2.stat(testFile, cb);\n\n```", "```js\nvar should = require('should');\nvar fs = require('fs');\nvar mp3dat = require('../index.js'),\n  mp3dat2 = mp3dat.spawnInstance();\n\n```", "```js\nshould.exist(mp3dat);\nmp3dat.should.have.property('stat');\nmp3dat.stat.should.be.an.instanceof(Function);\nmp3dat.should.have.property('statStream');\nmp3dat.statStream.should.be.an.instanceof(Function);\n\n```", "```js\nMp3dat.prototype.statStream = function (opts, cb) {\n  var self = this,\n    errTxt = 'First arg must be options object with stream and size',\n    validOpts = ({}).toString.call(opts) === '[object Object]'\n      && opts.stream\n      && opts.size\n      && 'pause' in opts.stream\n      && !isNaN(+opts.size);\n   lib\n  if (!validOpts) {\n    cb(new Error(errTxt));\n    return;\n  }\n\n  self.size = opts.size;\n  self.f = opts.stream.path;\n\n  self.stream = opts.stream;\n\n  self._findBitRate(function (err, bitrate) {\n    if (err) { cb(err); return; }\n    self._buildStats(cb);\n  });    \n\n}\n\n```", "```js\nMp3dat.prototype._findBitRate = function(cb) {\n  var self = this,\n    stream = self.stream || fs.createReadStream(self.f);\n  stream\n    .on('data', function (data) {\n      var i = 0;\n       for (i; i < data.length; i += 2) {\n        if (data.readUInt16LE(i) === 64511) {\n          self.bitrate = self._bitrates[data.toString('hex', i + 2, i + 3)[0]];\n          this.destroy();\n          cb(null);\n          break;\n        };\n//rest of the _findBitRate function...\n\n```", "```js\nnode tests \n\n```", "```js\npassed\npassed\n\n```", "```js\n//to use try :\n// cat ../test/test.mp3 | node stdin_stream.js 82969\n// the argument (82969) is the size in bytes of the mp3\n\nif (!process.argv[2]) {\n  process.stderr.write('\\nNeed mp3 size in bytes\\n\\n');\n  process.exit();\n}\n\nvar mp3dat = require('../');\nprocess.stdin.resume();\nmp3dat.statStream({stream : process.stdin, size: process.argv[2]}, function (err, stats) {\n  if (err) { console.log(err); }\n  console.log(stats);\n});\n\n```", "```js\nvar mp3dat = require('../../mp3dat');\nvar http = require('http');\nvar fs = require('fs');\nvar form = fs.readFileSync('put_upload_form.html');\nhttp.createServer(function (req, res) {\n  if (req.method === \"PUT\") {\n    mp3dat.statStream({stream: req, size:req.headers['content-length']}, function (err, stats) {\n      if (err) { console.log(err); return; }\n      console.log(stats);\n    });\n\n  }\n  if (req.method === \"GET\") {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end(form);\n  }\n}).listen(8080);\n\n```", "```js\nmp3dat.should.have.property('statStream');\nmp3dat.statStream.should.be.an.instanceof(Function);\n\n```", "```js\nmp3dat.stat({stream: fs.createReadStream(testFile),\n    size: fs.statSync(testFile).size}, cb);\nmp3dat2.stat(testFile, cb);\n\n```", "```js\nmp3dat.stat({stream : process.stdin, size: process.argv[2]}\n\n```", "```js\nmp3dat.stat({stream: req, size: req.headers['content-length']}\n\n```", "```js\nMp3dat.prototype._compile =  function (err, fstatsOpts, cb) {\n  var self = this;\n  self.size = fstatsOpts.size;\n  self.stream = fstatsOpts.stream;\n    self._findBitRate(function (err, bitrate) {\n    if (err) { cb(err); return; }\n    self._buildStats(cb);\n  });    \n}\n\n```", "```js\nMp3dat.prototype.stat = function (f, cb) {\n  var self = this, isOptsObj = ({}).toString.call(f) === '[object Object]';\n\n  if (isOptsObj) {\n    var opts = f, validOpts = opts.stream && opts.size\n      && 'pause' in opts.stream && !isNaN(+opts.size);\n    errTxt = 'First arg must be options object with stream and size'\n\n    if (!validOpts) { cb(new Error(errTxt)); return; }\n\n    self.f = opts.stream.path;\n    self._compile(null, opts, cb);\n    return;\n  }\n\n  self.f = f;\n  fs.stat(f, function (err, fstats) {\n    self._compile.call(self, err, fstats, cb);\n  });\n}\n\n```", "```js\nvar fs = require('fs'),\n  EventEmitter = require('events').EventEmitter,\n  util = require('util');\n\nfunction Mp3dat() {\n  if (!(this instanceof Mp3dat)) {\n    return new Mp3dat();\n  }  \n  EventEmitter.call(this);\n  this.stats = {duration:{}};\n}\n\nutil.inherits(Mp3dat, EventEmitter);\n\n```", "```js\nMp3dat.prototype._findBitRate = function(cb) {\n//beginning of _findBitRate method\n       for (i; i < data.length; i += 2) {\n        if (data.readUInt16LE(i) === 64511) {\n          self.bitrate = self._bitrates[data.toString('hex', i + 2, i + 3)[0]];\n          this.destroy();\n          self.emit('bitrate', self.bitrate);\n          cb(null);\n          break;\n        };\n //rest of _findBitRate method\n\n```", "```js\n//last part of _findBitRate method\n  }).on('end', function () {\n    var err = new Error('could not find bitrate, is this definately an MPEG-1 MP3?');\n    self.emit('error', err);\n    cb(err);\n  });\n\n```", "```js\nMp3dat.prototype._timesig = function () {\n //_timesig function code....\n  self.emit('timesig', ts);\n  return ts;\n}\n\n```", "```js\nMp3dat.prototype._buildStats = function (cb) {\n//_buildStats code\n  self._timeProcessor(hours, function (duration) {\n   //_timeProcessor code\n    self.emit('stats', self.stats);\n    if (cb) { cb(null, self.stats); }    \n  });\n}\n\n```", "```js\nMp3dat.prototype.spawnInstance = function () {\n  var m = Mp3dat();\n  this.emit('spawn', m);\n  return m;\n}\n\n```", "```js\nMp3dat.prototype.stat = function (f, cb) {\n//stat code\n  if (isOptsObj) {\n    //other code here\n    self._compile(null, opts, cb);\n    return self;\n  }\n\n```", "```js\n  //prior stat code\n  self.f = f;\n  fs.stat(f, function (err, fstats) {\n    self._compile.call(self, err, fstats, cb);\n  });\n  return self;\n}\n\n```", "```js\nvar mp3dat = require('../index');\n\nmp3dat\n  .stat('../test/test.mp3')\n  .on('bitrate', function (bitrate) {\n    console.log('Got bitrate:', bitrate);\n  })\n  .on('timesig', function (timesig) {\n     console.log('Got timesig:', timesig);\n  })\n  .on('stats', function (stats) {\n     console.log('Got stats:', stats);\n     mp3dat.spawnInstance();\n  })\n  .on('error', function (err) {\n     console.log('Error:', err);\n  })\n  .on('spawn', function (mp3dat2) {\n    console.log('Second mp3dat', mp3dat2);\n  });\n\n```", "```js\n{\n  \"author\": \"David Mark Clements <contact@davidmarkclements.com> (http://davidmarkclements.com)\",\n  \"name\": \"mp3dat\",\n  \"description\": \"A simple MP3 parser that returns stat infos in a similar style to fs.stat for MP3 files or streams. (MPEG-1 compatible only)\",\n  \"version\": \"0.0.1\",\n  \"homepage\": \"http://nodecookbook.com/mp3dat\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/davidmarkclements/mp3dat.git\"\n  },\n  \"main\": \"./lib/index.js\",\n  \"scripts\": {\n    \"test\": \"node test\"\n  },\n  \"engines\": {\n    \"node\": \"~0.6.13\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {}\n}\n\n```", "```js\nnpm adduser \n\n```", "```js\nsudo npm install -g \n\n```", "```js\nrequire('mp3dat') \n\n```", "```js\nnpm publish \n\n```", "```js\nnpm uninstall mp3dat\nnpm install mp3dat \n\n```", "```js\nnpm search mp3dat \n\n```", "```js\ncurl http://isaacs.couchone.com/registry/_changes?feed=continuous&include_docs=true \n\n```", "```js\nmp3dat unpublish\nmp3dat publish \n\n```", "```js\nsudo npm install . -g \n\n```", "```js\nsudo npm link \n\n```", "```js\nsudo npm unlink -g mp3dat \n\n```", "```js\nexamples/\n\n```", "```js\nnpm version 0.0.2 --message \"added .npmignore\"\nnpm publish \n\n```"]