["```js\n@Injectable()  \nexport default class JwtStrategy extends Strategy {  \n   constructor(private readonly authenticationService: AuthenticationService) {  \n       super({  \n            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),  \n            passReqToCallback: true,  \n            secretOrKey: 'secret'  \n        }, async (req, payload, next) => {  \n            return await this.verify(req, payload, next);  \n        });  \n        passport.use(this);  \n    }  \n\n   public async verify(req, payload, done) {  \n       const isValid = await this.authenticationService.validateUser(payload);  \n        if (!isValid) {  \n           return done('Unauthorized', null);  \n        } else {  \n           return done(null, payload);  \n        }  \n   }  \n}\n\n```", "```js\n@Injectable()  \nexport class AuthenticationService {  \n   constructor(private readonly userService: UserService) { }  \n\n   createToken(email: string, ttl?: number) {  \n        const expiresIn = ttl || 60 * 60;  \n        const secretOrKey = 'secret';  \n        const user = { email };  \n        const token = jwt.sign(user, secretOrKey, { expiresIn });  \n        return {  \n            expires_in: expiresIn,  \n            access_token: token,  \n        };  \n   }  \n\n   async validateUser(payload: { email: string; password: string }): Promise<boolean> {  \n        const user = await this.userService.findOne({  \n            where: { email: payload.email }  \n        });  \n        return !!user;  \n   }  \n}\n\n```", "```js\n@Controller()  \nexport class AuthenticationController {  \n   constructor(  \n        private readonly authenticationService: AuthenticationService,  \n        private readonly userService: UserService) {}  \n\n   @Post('login')  \n   @HttpCode(HttpStatus.OK)  \n   public async login(@Body() body: any, @Res() res): Promise<any> {  \n       if (!body.email || !body.password) {  \n           return res.status(HttpStatus.BAD_REQUEST).send('Missing email or password.');  \n       }  \n\n       const user = await this.userService.findOne({  \n           where: {  \n               email: body.email,  \n                password: crypto.createHmac('sha256', body.password).digest('hex')  \n           }  \n       });  \n       if (!user) {  \n           return res.status(HttpStatus.NOT_FOUND).send('No user found with this email and password.');  \n       }  \n\n       const result = this.authenticationService.createToken(user.email);  \n       return res.json(result);  \n    }  \n}\n\n```", "```js\n@Module({})  \nexport class AuthenticationModule {  \n   static forRoot(strategy?: 'jwt' | 'OAuth' | 'Facebook'): DynamicModule {  \n       strategy = strategy ? strategy : 'jwt';  \n        const strategyProvider = {  \n            provide: 'Strategy',  \n            useFactory: async (authenticationService: AuthenticationService) => {  \n                const Strategy = (await import (`./passports/${strategy}.strategy`)).default;  \n                return new Strategy(authenticationService);  \n            },  \n            inject: [AuthenticationService]  \n       };  \n        return {  \n            module: AuthenticationModule,  \n            imports: [UserModule],  \n            controllers: [AuthenticationController],  \n            providers: [AuthenticationService, strategyProvider],  \n            exports: [strategyProvider]  \n        };  \n    }  \n}\n\n```", "```js\n@Injectable()\nexport class UserService() {\n    // The SequelizeInstance come from the DatabaseModule have a look to the Sequelize chapter\n    constructor(@Inject('UserRepository') private readonly UserRepository: typeof User,\n                @Inject('SequelizeInstance') private readonly sequelizeInstance) { }\n\n    /* ... */\n}\n\n```", "```js\n{\n    where: {\n        email: 'some@email.test',\n        firstName: 'someFirstName'\n    }\n}\n\n```", "```js\n@Injectable()\nexport class UserService() {\n    /* ... */\n\n    public async findOne(options?: object): Promise<User | null> {  \n        return await this.UserRepository.findOne<User>(options);  \n    }\n\n    /* ... */\n}\n\n```", "```js\n@Injectable()\nexport class UserService() {\n    /* ... */\n\n    public async findById(id: number): Promise<User | null> {  \n        return await this.UserRepository.findById<User>(id);  \n    }  \n\n    /* ... */\n}\n\n```", "```js\n@Injectable()\nexport class UserService() {\n    /* ... */\n\n    public async create(user: IUser): Promise<User> {  \n        return await this.sequelizeInstance.transaction(async transaction => {  \n            return await this.UserRepository.create<User>(user, {  \n                returning: true,  \n                transaction,  \n            });  \n        });  \n    }  \n\n    /* ... */\n}\n\n```", "```js\n@Injectable()\nexport class UserService() {\n    /* ... */\n\n    public async update(id: number, newValue: IUser): Promise<User | null> {  \n        return await this.sequelizeInstance.transaction(async transaction => {  \n            let user = await this.UserRepository.findById<User>(id, { transaction });  \n            if (!user) throw new Error('The user was not found.');  \n\n            user = this._assign(user, newValue);  \n            return await user.save({  \n                returning: true,  \n                transaction,  \n            });  \n        });  \n    }  \n\n    /* ... */\n}\n\n```", "```js\n@Injectable()\nexport class UserService() {\n    /* ... */\n\n    public async delete(id: number): Promise<void> {  \n        return await this.sequelizeInstance.transaction(async transaction => {  \n            return await this.UserRepository.destroy({  \n                where: { id },  \n                transaction,  \n            });  \n        });  \n    }\n\n    /* ... */\n}\n\n```", "```js\n@Controller()  \nexport class UserController {  \n   constructor(private readonly userService: UserService) { }\n\n   /* ... */\n}\n\n```", "```js\n@Controller()  \nexport class UserController {  \n    /* ... */\n\n    @Get('users')  \n    @UseGuards(CheckLoggedInUserGuard)\n    public async index(@Res() res) {  \n        const users = await this.userService.findAll();  \n        return res.status(HttpStatus.OK).json(users);  \n    }\n\n    /* ... */\n}\n\n```", "```js\n@Controller()  \nexport class UserController {  \n    /* ... */\n\n    @Post('users')  \n    public async create(@Body() body: any, @Res() res) {  \n       if (!body || (body && Object.keys(body).length === 0)) throw new Error('Missing some information.');  \n\n        await this.userService.create(body);  \n        return res.status(HttpStatus.CREATED).send();  \n    }  \n\n    /* ... */\n}\n\n```", "```js\n@Controller()  \nexport class UserController {  \n    /* ... */\n\n    @Get('users/:id')  \n    @UseGuards(CheckLoggedInUserGuard)\n    public async show(@Param() id: number, @Res() res) {  \n       if (!id) throw new Error('Missing id.');  \n\n        const user = await this.userService.findById(id);  \n        return res.status(HttpStatus.OK).json(user);  \n    }   \n\n    /* ... */\n}\n\n```", "```js\n@Controller()  \nexport class UserController {  \n    /* ... */\n    @Put('users/:id')  \n    @UseGuards(CheckLoggedInUserGuard)\n    public async update(@Param() id: number, @Body() body: any, @Res() res) {  \n       if (!id) throw new Error('Missing id.');  \n\n        await this.userService.update(id, body);  \n        return res.status(HttpStatus.OK).send();  \n    }\n\n```", "```js\n    @Delete('users/:id')  \n    @UseGuards(CheckLoggedInUserGuard)\n    public async delete(@Param() id: number, @Res() res) {  \n       if (!id) throw new Error('Missing id.');  \n\n        await this.userService.delete(id);  \n        return res.status(HttpStatus.OK).send();  \n    }  \n}\n\n```", "```js\n@Module({  \n    imports: [],  \n    controllers: [UserController],  \n    providers: [userProvider, UserService],\n    exports: [UserService]  \n})  \nexport class UserModule {}\n\n```", "```js\n@Module({  \n   imports: [  \n        DatabaseModule,  \n        // Here we specify the strategy\n        AuthenticationModule.forRoot('jwt'),  \n        UserModule  \n    ]\n})  \nexport class AppModule implements NestModule {  \n   public configure(consumer: MiddlewaresConsumer) {  \n       consumer  \n           .apply(AuthenticationMiddleware)  \n           .with(strategy)  \n           .forRoutes(  \n               { path: '/users', method: RequestMethod.GET },  \n                { path: '/users/:id', method: RequestMethod.GET },  \n                { path: '/users/:id', method: RequestMethod.PUT },  \n                { path: '/users/:id', method: RequestMethod.DELETE }  \n           );  \n    }  \n}\n\n```", "```js\n@Injectable()\nexport class AuthenticationMiddleware implements NestMiddleware {\n    constructor(private userService: UserService) { }\n\n    async resolve(strategy: string): Promise<ExpressMiddleware> {\n        return async (req, res, next) => {\n            return passport.authenticate(strategy, async (...args: any[]) => {\n                const [,  payload, err] = args;\n                if (err) {\n                    return res.status(HttpStatus.BAD_REQUEST).send('Unable to authenticate the user.');\n                }\n\n                const user = await this.userService.findOne({ where: { email: payload.email }});\n                req.user = user;\n                return next();\n            })(req, res, next);\n        };\n    }\n}\n\n```", "```js\n@Injectable()\nexport class CheckLoggedInUserGuard implements CanActivate {\n    canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {\n        const request = context.switchToHttp().getRequest();\n        return Number(req.params.userId) === req.user.id;\n    }\n}\n\n```", "```js\n@Controller()\n@UseGuards(CheckLoggedInUserGuard)  \nexport class UserController {/*...*/}\n\n```", "```js\n@Injectable()  \nexport class AuthenticationService {  \n   constructor(private readonly userService: UserService) { }  \n\n   createToken(email: string, ttl?: number) {  \n        const expiresIn = ttl || 60 * 60;  \n        const secretOrKey = 'secret';  \n        const user = { email };  \n        const token = jwt.sign(user, secretOrKey, { expiresIn });  \n        return {  \n            expires_in: expiresIn,  \n            access_token: token,  \n        };  \n   }  \n\n   async validateUser(payload: { email: string; password: string }): Promise<boolean> {  \n        const user = await this.userService.findOne({  \n            where: { email: payload.email }  \n        });  \n        return !!user;  \n   }  \n}\n\n```", "```js\n@Injectable()\nexport default class JwtStrategy extends PassportStrategy(Strategy) {  \n   constructor(private readonly authenticationService: AuthenticationService) {  \n       super({  \n            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),  \n            passReqToCallback: true,  \n            secretOrKey: 'secret'  \n        });\n    }  \n\n   public async validate(req, payload, done) {  \n       const isValid = await this.authenticationService.validateUser(payload);  \n        if (!isValid) {  \n           return done('Unauthorized', null);  \n        } else {  \n           return done(null, payload);  \n        }  \n   }  \n}\n\n```", "```js\n@Module({\n  imports: [UserModule],\n  providers: [AuthService, JwtStrategy],\n})\nexport class AuthModule {}\n\n```"]