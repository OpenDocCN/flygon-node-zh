["```js\nexport class CreateEntryCommand implements ICommand {\n    constructor(\n        public readonly title: string,\n        public readonly content: string,\n        public readonly userId: number\n    ) {}\n}\n\n```", "```js\nexport class UpdateEntryCommand implements ICommand {\n    constructor(\n        public readonly id: number,\n        public readonly title: string,\n        public readonly content: string\n    ) {}\n}\n\nexport class DeleteEntryCommand implements ICommand {\n    constructor(\n        public readonly id: number\n    ) {}\n}\n\n```", "```js\n@CommandHandler(CreateEntryCommand)\nexport class CreateEntryCommandHandler implements ICommandHandler<CreateEntryCommand> {\n    constructor(\n        @Inject('EntryRepository') private readonly entryRepository: typeof Entry,\n        @Inject('SequelizeInstance') private readonly sequelizeInstance\n    ) { }\n\n    async execute(command: CreateEntryCommand, resolve: () => void) {\n    }\n}\n\n```", "```js\nasync execute(command: CreateEntryCommand, resolve: () => void) {\n    await this.sequelizeInstance.transaction(async transaction => {\n        return await this.entryRepository.create<Entry>(command, {\n            returning: true,\n            transaction\n        });\n    });\n\n    resolve();\n}\n\n```", "```js\nasync execute(command: CreateEntryCommand, resolve: () => void) {\n    try {\n        await this.sequelizeInstance.transaction(async transaction => {\n            return await this.entryRepository.create<Entry>(command, {\n                returning: true,\n                transaction\n            });\n        });\n    } catch (error) {\n\n    } finally {\n        resolve();\n    }\n}\n\n```", "```js\nasync execute(command: CreateEntryCommand, resolve: (error?: Error) => void) {\n    let caught: Error;\n\n    try {\n        await this.sequelizeInstance.transaction(async transaction => {\n            return await this.entryRepository.create<Entry>(command, {\n                returning: true,\n                transaction\n            });\n        });\n    } catch (error) {\n        caught = error\n    } finally {\n        resolve(caught);\n    }\n}\n\n```", "```js\n@CommandHandler(UpdateEntryCommand)\nexport class UpdateEntryCommandHandler implements ICommandHandler<UpdateEntryCommand> {\n    constructor(\n        @Inject('EntryRepository') private readonly entryRepository: typeof Entry,\n        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize,\n        private readonly databaseUtilitiesService: DatabaseUtilitiesService\n    ) { }\n\n    async execute(command: UpdateEntryCommand, resolve: (error?: Error) => void) {\n        let caught: Error;\n\n        try {\n            await this.sequelizeInstance.transaction(async transaction => {\n                let entry = await this.entryRepository.findById<Entry>(command.id, { transaction });\n                if (!entry) throw new Error('The blog entry was not found.');\n\n                entry = this.databaseUtilitiesService.assign(\n                    entry,\n                    {\n                        ...command,\n                        id: undefined\n                    }\n                );\n                return await entry.save({\n                    returning: true,\n                    transaction,\n                });\n            });\n        } catch (error) {\n            caught = error\n        } finally {\n            resolve(caught);\n        }\n    }\n}\n\n```", "```js\n@CommandHandler(DeleteEntryCommand)\nexport class DeleteEntryCommandHandler implements ICommandHandler<DeleteEntryCommand> {\n    constructor(\n        @Inject('EntryRepository') private readonly entryRepository: typeof Entry,\n        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize\n    ) { }\n\n    async execute(command: DeleteEntryCommand, resolve: (error?: Error) => void) {\n        let caught: Error;\n\n        try {\n            await this.sequelizeInstance.transaction(async transaction => {\n                return await this.entryRepository.destroy({\n                    where: { id: command.id },\n                    transaction,\n                });\n            });\n        } catch (error) {\n            caught = error\n        } finally {\n            resolve(caught);\n        }\n\n        resolve();\n    }\n}\n\n```", "```js\n@Controller()\nexport class EntryController {\n    constructor(\n        private readonly entryService: EntryService,\n        private readonly commandBus: CommandBus\n    ) { }\n\n    @Post('entries')\n    public async create(@User() user: IUser, @Body() body: any, @Res() res) {\n        if (!body || (body && Object.keys(body).length === 0)) return res.status(HttpStatus.BAD_REQUEST).send('Missing some information.');\n\n        const error = await this.commandBus.execute(new CreateEntryCommand(\n            body.title,\n            body.content,\n            user.id\n        ));\n\n        if (error) {\n            return res.status(HttpStatus.INTERNAL_SERVER_ERROR).send(result);\n        } else {\n            return res.set('location', `/entries/${result.id}`).status(HttpStatus.CREATED).send();\n        }\n    }\n\n```", "```js\n@Controller()\nexport class EntryController {\n    constructor(\n        private readonly entryService: EntryService,\n        private readonly commandBus: CommandBus\n    ) { }\n\n    @Get('entries')\n    public async index(@User() user: IUser, @Res() res) {\n        const entries = await this.entryService.findAll();\n        return res.status(HttpStatus.OK).json(entries);\n    }\n\n    @Post('entries')\n    public async create(@User() user: IUser, @Body() body: any, @Res() res) {\n        if (!body || (body && Object.keys(body).length === 0)) return res.status(HttpStatus.BAD_REQUEST).send('Missing some information.');\n\n        const error = await this.commandBus.execute(new CreateEntryCommand(\n            body.title,\n            body.content,\n            user.id\n        ));\n\n        if (error) {\n            return res.status(HttpStatus.INTERNAL_SERVER_ERROR).send(result);\n        } else {\n            return res.set('location', `/entries/${result.id}`).status(HttpStatus.CREATED).send();\n        }\n    }\n\n    @Get('entries/:entryId')\n    public async show(@User() user: IUser, @Entry() entry: IEntry, @Res() res) {\n        return res.status(HttpStatus.OK).json(entry);\n    }\n\n    @Put('entries/:entryId')\n    public async update(@User() user: IUser, @Entry() entry: IEntry, @Param('entryId') entryId: number, @Body() body: any, @Res() res) {\n        if (user.id !== entry.userId) return res.status(HttpStatus.NOT_FOUND).send('Unable to find the entry.');\n        const error = await this.commandBus.execute(new UpdateEntryCommand(\n            entryId,\n            body.title,\n            body.content,\n            user.id\n        ));\n\n        if (error) {\n            return res.status(HttpStatus.INTERNAL_SERVER_ERROR).send(error);\n        } else {\n            return res.status(HttpStatus.OK).send();\n        }\n    }\n\n    @Delete('entries/:entryId')\n    public async delete(@User() user: IUser, @Entry() entry: IEntry, @Param('entryId') entryId: number, @Res() res) {\n        if (user.id !== entry.userId) return res.status(HttpStatus.NOT_FOUND).send('Unable to find the entry.');\n        const error = await this.commandBus.execute(new DeleteEntryCommand(entryId));\n\n        if (error) {\n            return res.status(HttpStatus.INTERNAL_SERVER_ERROR).send(error);\n        } else {\n            return res.status(HttpStatus.OK).send();\n        }\n    }\n}\n\n```", "```js\nexport const entryCommandHandlers = [\n    CreateEntryCommandHandler,\n    UpdateEntryCommandHandler,\n    DeleteEntryCommandHandler\n];\n\n```", "```js\n@Module({\n    imports: [CQRSModule, EntryModule],\n    controllers: [CommentController],\n    components: [commentProvider, CommentService, ...CommentCommandHandlers],\n    exports: [CommentService]\n})\nexport class EntryModule implements NestModule, OnModuleInit {\n    public constructor(\n        private readonly moduleRef: ModuleRef,\n        private readonly commandBus: CommandBus\n    ) {}\n\n    public onModuleInit() {\n        this.commandBus.setModuleRef(this.moduleRef);\n        this.commandBus.register(CommentCommandHandlers);\n    }\n}\n\n```", "```js\n@Table(tableOptions)\nexport class Entry extends Model<Entry> {\n\n    @Column({\n        type: DataType.TEXT,\n        allowNull: true,\n\n    })\n    public keywords: string;\n\n}\n\n```", "```js\nexport async function up(sequelize) {\n    // language=PostgreSQL\n    await sequelize.query(`\n        ALTER TABLE entries ADD COLUMN keywords TEXT;\n    `);\n\n    console.log('*keywords column added to entries table*');\n}\n\nexport async function down(sequelize) {\n    // language=PostgreSQL\n    await sequelize.query(`\n        ALTER TABLE entries DROP COLUMN keywords;\n    `);\n}\n\n```", "```js\n@Controller()\nexport class EntryController {\n\n    @Post('entries')\n    public async create(@User() user: IUser, @Body() body: any, @Res() res) {\n        if (!body || (body && Object.keys(body).length === 0)) return res.status(HttpStatus.BAD_REQUEST).send('Missing some information.');\n\n        const error = await this.commandBus.execute(new CreateEntryCommand(\n            body.title,\n            body.content,\n            body.keywords,\n            user.id\n        ));\n\n        if (error) {\n            return res.status(HttpStatus.INTERNAL_SERVER_ERROR).send(result);\n        } else {\n            return res.set('location', `/entries/${result.id}`).status(HttpStatus.CREATED).send();\n        }\n    }\n\n    @Put('entries/:entryId')\n    public async update(@User() user: IUser, @Entry() entry: IEntry, @Param('entryId') entryId: number, @Body() body: any, @Res() res) {\n        if (user.id !== entry.userId) return res.status(HttpStatus.NOT_FOUND).send('Unable to find the entry.');\n        const error = await this.commandBus.execute(new UpdateEntryCommand(\n            entryId,\n            body.title,\n            body.content,\n            body.keywords,\n            user.id\n        ));\n\n        if (error) {\n            return res.status(HttpStatus.INTERNAL_SERVER_ERROR).send(error);\n        } else {\n            return res.status(HttpStatus.OK).send();\n        }\n    }\n}\n\n```", "```js\nexport class CreateEntryCommand implements ICommand, IEntry {\n    constructor(\n        public readonly title: string,\n        public readonly content: string,\n        public readonly keywords: string[],\n        public readonly userId: number\n    ) {}\n}\n\nexport class UpdateEntryCommand implements ICommand, IEntry {\n    constructor(\n        public readonly id: number,\n        public readonly title: string,\n        public readonly content: string,\n        public readonly keywords: string[],\n        public readonly userId: number\n    ) {}\n}\n\n```", "```js\n@CommandHandler(CreateEntryCommand)\nexport class CreateEntryCommandHandler implements ICommandHandler<CreateEntryCommand> {\n\n    async execute(command: CreateEntryCommand, resolve: (error?: Error) => void) {\n        let caught: Error;\n\n        try {\n            await this.sequelizeInstance.transaction(async transaction => {\n                return await this.EntryRepository.create<Entry>({\n                    ...command,\n                    keywords: JSON.stringify(command.keywords)\n                }, {\n                    returning: true,\n                    transaction\n                });\n            });\n        } catch (error) {\n            caught = error;\n        } finally {\n            resolve(caught);\n        }\n    }\n}\n\n@CommandHandler(UpdateEntryCommand)\nexport class UpdateEntryCommandHandler implements ICommandHandler<UpdateEntryCommand> {\n\n    async execute(command: UpdateEntryCommand, resolve: (error?: Error) => void) {\n        let caught: Error;\n\n        try {\n            await this.sequelizeInstance.transaction(async transaction => {\n                let comment = await this.EntryRepository.findById<Entry>(command.id, { transaction });\n                if (!comment) throw new Error('The comment was not found.');\n\n                comment = this.databaseUtilitiesService.assign(\n                    comment,\n                    {\n                        ...command,\n                        id: undefined,\n                        keywords: JSON.stringify(command.keywords)\n                    }\n                );\n                return await comment.save({\n                    returning: true,\n                    transaction,\n                });\n            });\n        } catch (error) {\n            caught = error;\n        } finally {\n            resolve(caught);\n        }\n    }\n}\n\n```", "```js\nconst tableOptions: IDefineOptions = { timestamp: true, tableName: 'keywords' } as IDefineOptions;\n\n@DefaultScope({\n    include: [() => Entry]\n})\n@Table(tableOptions)\nexport class Keyword extends Model<Keyword> {\n    @PrimaryKey\n    @AutoIncrement\n    @Column(DataType.BIGINT)\n    public id: number;\n\n    @Column({\n        type: DataType.STRING,\n        allowNull: false,\n        validate: {\n            isUnique: async (value: string, next: any): Promise<any> => {\n                const isExist = await Keyword.findOne({ where: { keyword: value } });\n                if (isExist) {\n                    const error = new Error('The keyword already exists.');\n                    next(error);\n                }\n                next();\n            },\n        },\n    })\n    public keyword: string;\n\n    @CreatedAt\n    public createdAt: Date;\n\n    @UpdatedAt\n    public updatedAt: Date;\n\n    @DeletedAt\n    public deletedAt: Date;\n\n    @BelongsToMany(() => Entry, () => KeywordEntry)\n    public entries: Entry[];\n\n    @BeforeValidate\n    public static validateData(entry: Entry, options: any) {\n        if (!options.transaction) throw new Error('Missing transaction.');\n    }\n}\n\n```", "```js\nconst tableOptions: IDefineOptions = { timestamp: true, tableName: 'keywords_entries', deletedAt: false, updatedAt: false } as IDefineOptions;\n\n@Table(tableOptions)\nexport class KeywordEntry extends Model<KeywordEntry> {\n    @ForeignKey(() => Keyword)\n    @Column({\n        type: DataType.BIGINT,\n        allowNull: false\n    })\n    public keywordId: number;\n\n    @ForeignKey(() => Entry)\n    @Column({\n        type: DataType.BIGINT,\n        allowNull: false\n    })\n    public entryId: number;\n\n    @CreatedAt\n    public createdAt: Date;\n}\n\n```", "```js\nexport async function up(sequelize) {\n    // language=PostgreSQL\n    await sequelize.query(`\n        CREATE TABLE \"keywords\" (\n            \"id\" SERIAL UNIQUE PRIMARY KEY NOT NULL,\n            \"keyword\" VARCHAR(30) UNIQUE NOT NULL,\n            \"createdAt\" TIMESTAMP NOT NULL,\n            \"updatedAt\" TIMESTAMP NOT NULL,\n            \"deletedAt\" TIMESTAMP\n        );\n        CREATE TABLE \"keywords_entries\" (\n            \"keywordId\" INTEGER NOT NULL\n                CONSTRAINT \"keywords_entries_keywordId_fkey\"\n                REFERENCES keywords\n                ON UPDATE CASCADE ON DELETE CASCADE,\n            \"entryId\" INTEGER NOT NULL\n                CONSTRAINT \"keywords_entries_entryId_fkey\"\n                REFERENCES entries\n                ON UPDATE CASCADE ON DELETE CASCADE,\n            \"createdAt\" TIMESTAMP NOT NULL,\n            UNIQUE(\"keywordId\", \"entryId\")\n        );\n  `);\n\n    console.log('*Table keywords created!*');\n}\n\nexport async function down(sequelize) {\n    // language=PostgreSQL\n    await sequelize.query(`DROP TABLE keywords_entries`);\n    await sequelize.query(`DROP TABLE keywords`);\n}\n\n```", "```js\nexport const databaseProvider = {\n    provide: 'SequelizeInstance',\n    useFactory: async () => {\n        let config;\n        switch (process.env.NODE_ENV) {\n            case 'prod':\n            case 'production':\n            case 'dev':\n            case 'development':\n            default:\n                config = databaseConfig.development;\n        }\n\n        const sequelize = new Sequelize(config);\n        sequelize.addModels([User, Entry, Comment, Keyword, KeywordEntry]);\n        /* await sequelize.sync(); */\n        return sequelize;\n    },\n};\n\n```", "```js\nexport const keywordProvider = {\n    provide: 'KeywordRepository',\n    useValue: Keyword,\n};\n\nexport const keywordEntryProvider = {\n    provide: 'KeywordEntryRepository',\n    useValue: KeywordEntry\n};\n\n@Module({\n    imports: [],\n    controllers: [],\n    components: [keywordProvider, keywordEntryProvider],\n    exports: []\n})\nexport class KeywordModule {}\n\n```", "```js\nexport class UpdateKeywordLinksEvent implements IEvent {\n    constructor(\n        public readonly entryId: number,\n        public readonly keywords: string[]\n    ) { }\n}\n\n```", "```js\n@EventsHandler(UpdateKeywordLinksEvent)\nexport class UpdateKeywordLinksEventHandler implements IEventHandler<UpdateKeywordLinksEvent> {\n    constructor(\n        @Inject('KeywordRepository') private readonly keywordRepository: typeof Keyword,\n        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize,\n    ) { }\n\n    async handle(event: UpdateKeywordLinksEvent) {\n    }\n}\n\n```", "```js\n@EventsHandler(UpdateKeywordLinksEvent)\nexport class UpdateKeywordLinksEventHandler implements IEventHandler<UpdateKeywordLinksEvent> {\n    constructor(\n        @Inject('KeywordRepository') private readonly keywordRepository: typeof Keyword,\n        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize,\n    ) { }\n\n    async handle(event: UpdateKeywordLinksEvent) {\n        try {\n            await this.sequelizeInstance.transaction(async transaction => {\n                let newKeywords: string[] = [];\n                let removedKeywords: Keyword[] = [];\n\n                const keywordEntities = await this.keywordRepository.findAll({\n                    include: [{ model: Entry, where: { id: event.entryId }}],\n                    transaction\n                });\n\n                keywordEntities.forEach(keywordEntity => {\n                    if (event.keywords.indexOf(keywordEntity.keyword) === -1) {\n                        removedKeywords.push(keywordEntity);\n                    }\n                });\n\n                event.keywords.forEach(keyword => {\n                    if (keywordEntities.findIndex(keywordEntity => keywordEntity.keyword === keyword) === -1) {\n                        newKeywords.push(keyword)\n                    }\n                });\n\n                await Promise.all(\n                    newKeywords.map(\n                        keyword => this.ensureKeywordLinkExists(transaction, keyword, event.entryId)\n                    )\n                );\n                await Promise.all(\n                    removedKeywords.map(\n                        keyword => keyword.$remove('entries', event.entryId, { transaction })\n                    )\n                );\n            });\n        } catch (error) {\n            console.log(error);\n        }\n    }\n\n    async ensureKeywordLinkExists(transaction: Transaction, keyword: string, entryId: number) {\n        const keywordEntity = await this.ensureKeywordExists(transaction, keyword);\n        await keywordEntity.$add('entries', entryId, { transaction });\n    }\n\n    async ensureKeywordExists(transaction: Transaction, keyword: string): Promise<Keyword> {\n        const result = await this.keywordRepository.findOrCreate<Keyword>({\n            where: { keyword },\n            transaction\n        });\n        return result[0];\n    }\n}\n\n```", "```js\nexport const keywordEventHandlers = [\n    UpdateKeywordLinksEventHandler,\n    RemoveKeywordLinksEventHandler\n];\n\n```", "```js\n@Module({\n    imports: [CQRSModule],\n    controllers: [],\n    components: [keywordProvider, ...keywordEventHandlers],\n    exports: []\n})\nexport class KeywordModule implements OnModuleInit {\n    public constructor(\n        private readonly moduleRef: ModuleRef,\n        private readonly eventBus: EventBus\n    ) {}\n\n    public onModuleInit() {\n        this.eventBus.setModuleRef(this.moduleRef);\n        this.eventBus.register(keywordEventHandlers);\n    }\n}\n\n```", "```js\nexport class EntryModel extends AggregateRoot {\n  constructor(private readonly id: number) {\n    super();\n  }\n\n  updateKeywordLinks(keywords: string[]) {\n    this.apply(new UpdateKeywordLinksEvent(this.id, keywords));\n  }\n}\n\n```", "```js\n@CommandHandler(CreateEntryCommand)\nexport class CreateEntryCommandHandler implements ICommandHandler<CreateEntryCommand> {\n    constructor(\n        @Inject('EntryRepository') private readonly EntryRepository: typeof Entry,\n        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize,\n        private readonly eventPublisher: EventPublisher\n    ) { }\n\n    async execute(command: CreateEntryCommand, resolve: (error?: Error) => void) {\n        let caught: Error;\n\n        try {\n            const entry = await this.sequelizeInstance.transaction(async transaction => {\n                return await this.EntryRepository.create<Entry>({\n                    ...command,\n                    keywords: JSON.stringify(command.keywords)\n                }, {\n                    returning: true,\n                    transaction\n                });\n            });\n\n            const entryModel = this.eventPublisher.mergeObjectContext(new EntryModel(entry.id));\n            entryModel.updateKeywordLinks(command.keywords);\n            entryModel.commit();\n        } catch (error) {\n            caught = error;\n        } finally {\n            resolve(caught);\n        }\n    }\n}\n\n```", "```js\nconst Model = this.eventPublisher.mergeClassContext(EntryModel);\nconst entryModel = new Model(entry.id);\nentryModel.updateKeywordLinks(command.keywords);\nentryModel.commit();\n\n```", "```js\n@CommandHandler(UpdateEntryCommand)\nexport class UpdateEntryCommandHandler implements ICommandHandler<UpdateEntryCommand> {\n    constructor(\n        @Inject('EntryRepository') private readonly EntryRepository: typeof Entry,\n        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize,\n        private readonly databaseUtilitiesService: DatabaseUtilitiesService,\n        private readonly eventPublisher: EventPublisher\n    ) { }\n\n    async execute(command: UpdateEntryCommand, resolve: (error?: Error) => void) {\n        let caught: Error;\n\n        try {\n            await this.sequelizeInstance.transaction(async transaction => {\n                let entry = await this.EntryRepository.findById<Entry>(command.id, { transaction });\n                if (!entry) throw new Error('The comment was not found.');\n\n                entry = this.databaseUtilitiesService.assign(\n                    entry,\n                    {\n                        ...command,\n                        id: undefined,\n                        keywords: JSON.stringify(command.keywords)\n                    }\n                );\n                return await entry.save({\n                    returning: true,\n                    transaction,\n                });\n            });\n\n            const entryModel = this.eventPublisher.mergeObjectContext(new EntryModel(command.id));\n            entryModel.updateKeywordLinks(command.keywords);\n            entryModel.commit();\n        } catch (error) {\n            caught = error;\n        } finally {\n            resolve(caught);\n        }\n    }\n}\n\n```", "```js\n@Injectable()\nexport class KeywordService implements IKeywordService {\n    constructor(@Inject('KeywordRepository') private readonly keywordRepository: typeof Keyword,\n                @Inject('KeywordEntryRepository') private readonly keywordEntryRepository: typeof KeywordEntry) { }\n\n    public async findAll(search?: string, limit?: number): Promise<Array<Keyword>> {\n        let options: IFindOptions<Keyword> = {};\n\n        if (search) {\n            if (!limit || limit < 1 || limit === NaN) {\n                limit = 10;\n            }\n\n            options = {\n                where: {\n                    keyword: {\n                        [Op.like]: `%${search}%`\n                    }\n                },\n                limit\n            }\n        }\n\n        return await this.keywordRepository.findAll<Keyword>(options);\n    }\n\n    public async findById(id: number): Promise<Keyword | null> {\n        return await this.keywordRepository.findById<Keyword>(id);\n    }\n\n    public async findHotLinks(): Promise<Array<Keyword>> {\n        // Find the latest 5 keyword links\n        const latest5 = await this.keywordEntryRepository.findAll<KeywordEntry>({\n            attributes: {\n                exclude: ['entryId', 'createdAt']\n            },\n            group: ['keywordId'],\n            order: [[fn('max', col('createdAt')), 'DESC']],\n            limit: 5\n        } as IFindOptions<any>);\n\n        // Find the 5 keywords with the most links\n        const biggest5 = await this.keywordEntryRepository.findAll<KeywordEntry>({\n            attributes: {\n                exclude: ['entryId', 'createdAt']\n            },\n            group: 'keywordId',\n            order: [[fn('count', 'entryId'), 'DESC']],\n            limit: 5,\n            where: {\n                keywordId: {\n                    // Filter out keywords that already exist in the latest5\n                    [Op.notIn]: latest5.map(keywordEntry => keywordEntry.keywordId)\n                }\n            }\n        } as IFindOptions<any>);\n\n        // Load the keyword table data\n        const result = await Promise.all(\n            [...latest5, ...biggest5].map(keywordEntry => this.findById(keywordEntry.keywordId))\n        );\n\n        return result;\n    }\n}\n\n```", "```js\n@Controller()\nexport class KeywordController {\n    constructor(\n        private readonly keywordService: KeywordService\n    ) { }\n\n    @Get('keywords')\n    public async index(@Query('search') search: string, @Query('limit') limit: string, @Res() res) {\n        const keywords = await this.keywordService.findAll(search, Number(limit));\n        return res.status(HttpStatus.OK).json(keywords);\n    }\n\n    @Get('keywords/hot')\n    public async hot(@Res() res) {\n        const keywords = await this.keywordService.findHotLinks();\n        return res.status(HttpStatus.OK).json(keywords);\n    }\n\n    @Get('keywords/:keywordId')\n    public async show(@Param('keywordId') keywordId: string, @Res() res) {\n        const keyword = await this.keywordService.findById(Number(keywordId));\n        return res.status(HttpStatus.OK).json(keyword);\n    }\n}\n\n```", "```js\nexport class LinkKeywordEntryCommand implements ICommand {\n    constructor(\n        public readonly keyword: string,\n        public readonly entryId: number\n    ) { }\n}\n\nexport class UnlinkKeywordEntryCommand implements ICommand {\n    constructor(\n        public readonly keyword: string,\n        public readonly entryId: number\n    ) { }\n}\n\n```", "```js\n@CommandHandler(LinkKeywordEntryCommand)\nexport class LinkKeywordEntryCommandHandler implements ICommandHandler<LinkKeywordEntryCommand> {\n    constructor(\n        @Inject('KeywordRepository') private readonly keywordRepository: typeof Keyword,\n        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize\n    ) { }\n\n    async execute(command: LinkKeywordEntryCommand, resolve: (error?: Error) => void) {\n        let caught: Error;\n\n        try {\n            await this.sequelizeInstance.transaction(async transaction => {\n                const keyword = await this.keywordRepository.findOrCreate({\n                    where: {\n                        keyword: command.keyword\n                    },\n                    transaction\n                });\n\n                await keyword[0].$add('entries', command.entryId, { transaction });\n            });\n        } catch (error) {\n            caught = error;\n        } finally {\n            resolve(caught);\n        }\n    }\n}\n\n```", "```js\n@CommandHandler(UnlinkKeywordEntryCommand)\nexport class UnlinkKeywordEntryCommandHandler implements ICommandHandler<UnlinkKeywordEntryCommand> {\n    constructor(\n        @Inject('KeywordRepository') private readonly keywordRepository: typeof Keyword,\n        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize\n    ) { }\n\n    async execute(command: UnlinkKeywordEntryCommand, resolve: (error?: Error) => void) {\n        let caught: Error;\n\n        try {\n            await this.sequelizeInstance.transaction(async transaction => {\n                const keyword = await this.keywordRepository.findOrCreate<Keyword>({\n                    where: {\n                        keyword: command.keyword\n                    },\n                    transaction\n                });\n\n                await keyword[0].$remove('entries', command.entryId, { transaction });\n            });\n        } catch (error) {\n            caught = error;\n        } finally {\n            resolve(caught);\n        }\n    }\n}\n\n```", "```js\nexport const keywordCommandHandlers = [\n    LinkKeywordEntryCommandHandler,\n    UnlinkKeywordEntryCommandHandler\n];\n\n@Module({\n    imports: [CQRSModule],\n    controllers: [KeywordController],\n    components: [keywordProvider, keywordEntryProvider, ...keywordEventHandlers, KeywordService, ...keywordCommandHandlers],\n    exports: []\n})\nexport class KeywordModule implements OnModuleInit {\n    public constructor(\n        private readonly moduleRef: ModuleRef,\n        private readonly eventBus: EventBus,\n        private readonly commandBus: CommandBus\n    ) {}\n\n    public onModuleInit() {\n        this.commandBus.setModuleRef(this.moduleRef);\n        this.commandBus.register(keywordCommandHandlers);\n        this.eventBus.setModuleRef(this.moduleRef);\n        this.eventBus.register(keywordEventHandlers);\n    }\n}\n\n```", "```js\n@Injectable()\nexport class KeywordSagas {\n    constructor(\n        @Inject('KeywordRepository') private readonly keywordRepository: typeof Keyword,\n        @Inject('SequelizeInstance') private readonly sequelizeInstance: Sequelize,\n    ) { }\n\n    public updateKeywordLinks(events$: EventObservable<any>) {\n        return events$.ofType(UpdateKeywordLinksEvent).pipe(\n            mergeMap(event =>\n                merge( // From the rxjs package\n                    this.getUnlinkCommands(event),\n                    this.getLinkCommands(event)\n                )\n            )\n        );\n    }\n}\n\n```", "```js\nprivate getUnlinkCommands(event: UpdateKeywordLinksEvent) {\n    return from(this.keywordRepository.findAll({\n        include: [{ model: Entry, where: { id: event.entryId }}]\n    })).pipe(\n        // Filter keywordEntities so only those being removed are left\n        map(keywordEntities =>\n            keywordEntities.filter(keywordEntity => event.keywords.indexOf(keywordEntity.keyword) === -1)\n        ),\n        // Create new commands for each keywordEntity\n        map(keywordEntities => keywordEntities.map(keywordEntity => new UnlinkKeywordEntryCommand(keywordEntity.keyword, event.entryId))),\n        switchMap(commands => Observable.of(...commands))\n    );\n}\n\nprivate getLinkCommands(event: UpdateKeywordLinksEvent) {\n    return from(this.keywordRepository.findAll({\n        include: [{ model: Entry, where: { id: event.entryId }}]\n    })).pipe(\n        // Filter keywordEntities so only those being add are left\n        map(keywordEntities =>\n            event.keywords.filter(keyword => keywordEntities.findIndex(keywordEntity => keywordEntity.keyword === keyword) === -1)\n        ),\n        // Create new commands for each keyword\n        map(keywords => keywords.map(keyword => new LinkKeywordEntryCommand(keyword, event.entryId))),\n        switchMap(commands => Observable.of(...commands))\n    );\n}\n\n```", "```js\npublic updateKeywordLinks(events$: EventObservable<any>) {\n    return events$.ofType(UpdateKeywordLinksEvent).pipe(\n        mergeMap(event => this.compileKeywordLinkCommands(event))\n    );\n}\n\nprivate compileKeywordLinkCommands(event: UpdateKeywordLinksEvent) {\n    return from(this.keywordRepository.findAll({\n        include: [{ model: Entry, where: { id: event.entryId }}]\n    })).pipe(\n        switchMap(keywordEntities =>\n            of(\n                ...this.getUnlinkCommands(event, keywordEntities),\n                ...this.getLinkCommands(event, keywordEntities)\n            )\n        )\n    );\n}\n\nprivate getUnlinkCommands(event: UpdateKeywordLinksEvent, keywordEntities: Keyword[]) {\n    return keywordEntities\n        .filter(keywordEntity => event.keywords.indexOf(keywordEntity.keyword) === -1)\n        .map(keywordEntity => new UnlinkKeywordEntryCommand(keywordEntity.keyword, event.entryId));\n}\n\nprivate getLinkCommands(event: UpdateKeywordLinksEvent, keywordEntities: Keyword[]) {\n    return event.keywords\n        .filter(keyword => keywordEntities.findIndex(keywordEntity => keywordEntity.keyword === keyword) === -1)\n        .map(keyword => new LinkKeywordEntryCommand(keyword, event.entryId));\n}\n\n```"]