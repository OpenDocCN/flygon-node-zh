["```js\nasync function bootstrap() {\n    const app = await NestFactory.create(AppModule);\n    app.connectMicroservice({\n        transport: Transport.TCP,\n        options: {\n            port: 5667\n        }\n    });\n\n    await app.startAllMicroservicesAsync();\n    await app.listen(3001);\n}\n\n```", "```js\n@Controller()\nexport class UserController {\n\n    @Get('users')\n    public async index(@Res() res) {\n        const users = await this.userService.findAll();\n        return res.status(HttpStatus.OK).json(users);\n    }\n\n    @MessagePattern({cmd: 'users.index'})\n    public async rpcIndex() {\n        const users = await this.userService.findAll();\n        return users;\n    }\n}\n\n```", "```js\n@Controller()\nexport class UserController {\n    @Client({transport: Transport.TCP, options: { port: 5667 }})\n    client: ClientProxy\n\n    @Post('users')\n    public async create(@Req() req, @Res() res) {\n        this.client.send({cmd: 'users.index'}, {}).subscribe({\n            next: users => {\n                res.status(HttpStatus.OK).json(users);\n            },\n            error: error => {\n                res.status(HttpStatus.INTERNAL_SERVER_ERROR).json(error);\n            }\n        });\n    }\n\n    @MessagePattern({cmd: 'users.create'})\n    public async rpcCreate(data: any) {\n        if (!data || (data && Object.keys(data).length === 0)) throw new Error('Missing some information.');\n\n        await this.userService.create(data);\n    }\n}\n\n```", "```js\nexport class RpcValidationException extends RpcException {\n    constructor(public readonly validationErrors: ValidationError[]) {\n        super('Validation failed');\n    }\n}\n\n```", "```js\n@MessagePattern({cmd: 'users.create'})\npublic async rpcCreate(data: any) {\n    if (!data || (data && Object.keys(data).length === 0)) throw new RpcValidationException();\n\n    await this.userService.create(data);\n}\n\n```", "```js\n@Catch(RpcValidationException)\nexport class RpcValidationFilter implements RpcExceptionFilter {\n    public catch(exception: RpcValidationException): ErrorObservable {\n        return throwError({\n            error_code: 'VALIDATION_FAILED',\n            error_message: exception.getError(),\n            errors: exception.validationErrors\n        });\n    }\n}\n\n```", "```js\n@Post('users')\npublic async create(@Req() req, @Res() res) {\n    this.client.send({cmd: 'users.create'}, body).subscribe({\n        next: () => {\n            res.status(HttpStatus.CREATED).send();\n        },\n        error: error => {\n            if (error.error_code === 'VALIDATION_FAILED') {\n                res.status(HttpStatus.BAD_REQUEST).send(error);\n            } else {\n                res.status(HttpStatus.INTERNAL_SERVER_ERROR).send(error);\n            }\n        }\n    });\n}\n\n```", "```js\n@Injectable()\nexport class RpcValidationPipe extends ValidationPipe implements PipeTransform<any> {\n    public async transform(value: any, metadata: ArgumentMetadata) {\n        try {\n            await super.transform(value, metadata);\n        } catch (error) {\n            if (error instanceof BadRequestException) {\n                throw new RpcValidationException();\n            }\n\n            throw error;\n        }\n\n        return value;\n    }\n}\n\n```", "```js\nclass CreateUserRequest {\n      @IsEmail()\n      @IsNotEmpty()\n      @IsDefined()\n      @IsString()\n      public email: string;\n\n      @Length(8)\n      @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)\\S+$/)\n      @IsDefined()\n      @IsString()\n      public password: string;\n\n      @IsNotEmpty()\n      @IsDefined()\n      @IsString()\n      public firstName: string;\n\n      @IsNotEmpty()\n      @IsDefined()\n      @IsString()\n      public lastName: string;\n}\n\n```", "```js\n@MessagePattern({cmd: 'users.create'})\n@UsePipes(new RpcValidationPipe())\n@UseFilters(new RpcValidationFilter())\npublic async rpcCreate(data: CreateUserRequest) {\n    await this.userService.create(data);\n}\n\n```", "```js\n@Injectable()\nexport class RpcCheckLoggedInUserGuard implements CanActivate {\n    canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {\n        const data = context.switchToRpc().getData();\n        return Number(data.userId) === data.user.id;\n    }\n}\n\n```", "```js\n@Get('users/:userId')\n@UseGuards(CheckLoggedInUserGuard)\npublic async show(@Param('userId') userId: number, @Req() req, @Res() res) {\n    this.client.send({cmd: 'users.show'}, {userId, user: req.user}).subscribe({\n        next: user => {\n            res.status(HttpStatus.OK).json(user);\n        },\n        error: error => {\n            res.status(HttpStatus.INTERNAL_SERVER_ERROR).send(error);\n        }\n    });\n}\n\n@MessagePattern({cmd: 'users.show'})\n@UseGuards(RpcCheckLoggedInUserGuard)\npublic async rpcShow(data: any) {\n    return await this.userService.findById(data.userId);\n}\n\n```", "```js\n@Injectable()\nexport class CleanUserInterceptor implements NestInterceptor {\n    intercept(context: ExecutionContext, stream$: Observable<any>): Observable<any> {\n        return stream$.pipe(\n            map(user => JSON.parse(JSON.stringify(user))),\n            map(user => {\n                return {\n                    ...user,\n                    password: undefined\n                };\n            })\n        );\n    }\n}\n\n```", "```js\n@MessagePattern({cmd: 'users.show'})\n@UseGuards(RpcCheckLoggedInUserGuard)\n@UseInterceptors(CleanUserInterceptor)\npublic async rpcShow(data: any) {\n    return await this.userService.findById(data.userId);\n}\n\n```", "```js\nasync function bootstrap() {\n    const app = await NestFactory.create(AppModule);\n    app.connectMicroservice({\n        transport: Transport.REDIS,\n        options: {\n            url: process.env.REDIS_URL\n        }\n    });\n\n    await app.startAllMicroservicesAsync();\n    await app.listen(3001);\n}\n\n```", "```js\nexport const microserviceConfig: RedisOptions = {\n    transport: Transport.REDIS,\n    options: {\n        url: process.env.REDIS_URL\n    }\n};\n\n```", "```js\nasync function bootstrap() {\n    const app = await NestFactory.create(AppModule);\n    app.connectMicroservice(microserviceConfig);\n\n    await app.startAllMicroservicesAsync();\n    await app.listen(3001);\n}\n\n```", "```js\n@Controller()\nexport class UserController {\n    @Client(microserviceConfig)\n    client: ClientProxy\n}\n\n```", "```js\nexport const microserviceConfig: MqttOptions = {\n    transport: Transport.MQTT,\n    options: {\n        url: process.env.MQTT_URL\n    }\n};\n\n```", "```js\nexport const microserviceConfig: MqttOptions = {\n    transport: Transport.NATS,\n    options: {\n        url: process.env.NATS_URL\n    }\n};\n\n```", "```js\nsyntax = \"proto3\";\n\npackage example.nestBook;\n\nmessage User {\n    string firstName = 1;\n    string lastName = 2;\n    string email = 3;\n}\n\nmessage ShowUserRequest {\n    double userId = 1;\n}\n\nmessage ShowUserResponse {\n    User user = 1;\n}\n\nservice UserService {\n    rpc show (ShowUserRequest) returns (ShowUserResponse);\n}\n\n```", "```js\nexport const microserviceConfig: GrpcOptions = {\n    transport: Transport.GRPC,\n    options: {\n        url: '0.0.0.0:5667',\n        protoPath: join(__dirname, './nest-book-example.proto'),\n        package: 'example.nestBook'\n    }\n};\n\n```", "```js\n@Controller()\nexport class UserController implements OnModuleInit {\n    @Client(microserviceConfig)\n    private client: ClientGrpc;\n    private protoUserService: IProtoUserService;\n\n    constructor(\n        private readonly userService: UserService\n    ) {\n    }\n\n    public onModuleInit() {\n        this.protoUserService = this.client.getService<IProtoUserService>('UserService');\n    }\n}\n\n```", "```js\nimport { Observable } from 'rxjs';\n\nexport interface IProtoUserService {\n    show(data: any): Observable<any>;\n}\n\n```", "```js\n@Get('users/:userId')\n@UseGuards(CheckLoggedInUserGuard)\npublic async show(@Param('userId') userId: number, @Req() req, @Res() res) {\n    this.protoUserService.show({ userId: parseInt(userId.toString(), 10) }).subscribe({\n        next: user => {\n            res.status(HttpStatus.OK).json(user);\n        },\n        error: error => {\n            res.status(HttpStatus.INTERNAL_SERVER_ERROR).json(error);\n        }\n    });\n}\n\n@GrpcMethod('UserService', 'show')\npublic async rpcShow(data: any) {\n    const user =  await this.userService.findById(data.userId);\n    return {\n        user: {\n            firstName: user.firstName,\n            lastName: user.lastName,\n            email: user.email\n        }\n    };\n}\n\n```", "```js\nexport class UserController implements OnModuleInit {\n    @GrpcMethod()\n    public async rpcShow(data: any) {\n    }\n}\n\n```", "```js\nexport class RabbitMQTransportServer extends Server implements CustomTransportStrategy {\n    private server: amqp.Connection = null;\n    private channel: amqp.Channel = null;\n\n    constructor(\n        private readonly url: string,\n        private readonly queue: string\n    ) {\n        super();\n    }\n}\n\n```", "```js\npublic async listen(callback: () => void) {\n    await this.init();\n    callback();\n}\n\npublic close() {\n    this.channel && this.channel.close();\n    this.server && this.server.close();\n}\n\nprivate async init() {\n    this.server = await amqp.connect(this.url);\n    this.channel = await this.server.createChannel();\n    this.channel.assertQueue(`${this.queue}_sub`, { durable: false });\n    this.channel.assertQueue(`${this.queue}_pub`, { durable: false });\n}\n\n```", "```js\npublic async listen(callback: () => void) {\n    await this.init();\n    this.channel.consume(`${this.queue}_sub`, this.handleMessage.bind(this), {\n        noAck: true,\n    });\n    callback();\n}\n\nprivate async handleMessage(message: amqp.Message) {\n    const { content } = message;\n    const packet = JSON.parse(content.toString()) as ReadPacket & PacketId;\n    const handler = this.messageHandlers[JSON.stringify(packet.pattern)];\n\n    if (!handler) {\n        return this.sendMessage({\n            id: packet.id,\n            err: NO_PATTERN_MESSAGE\n        });\n    }\n\n    const response$ = this.transformToObservable(await handler(packet.data)) as Observable<any>;\n    response$ && this.send(response$, data => this.sendMessage({\n        id: packet.id,\n        ...data\n    }));\n}\n\nprivate sendMessage(packet: WritePacket & PacketId) {\n    const buffer = Buffer.from(JSON.stringify(packet));\n    this.channel.sendToQueue(`${this.queue}_pub`, buffer);\n}\n\n```", "```js\nexport class RabbitMQTransportClient extends ClientProxy {\n    private server: amqp.Connection;\n    private channel: amqp.Channel;\n    private responsesSubject: Subject<amqp.Message>;\n\n    constructor(\n        private readonly url: string,\n        private readonly queue: string) {\n        super();\n    }\n\n    public async close() {\n        this.channel && await this.channel.close();\n        this.server && await this.server.close();\n    }\n\n    public connect(): Promise<void> {\n        return new Promise(async (resolve, reject) => {\n            try {\n                this.server = await amqp.connect(this.url);\n                this.channel = await this.server.createChannel();\n\n                const { sub, pub } = this.getQueues();\n                await this.channel.assertQueue(sub, { durable: false });\n                await this.channel.assertQueue(pub, { durable: false });\n\n                this.responsesSubject = new Subject();\n                this.channel.consume(pub, (message) => { this.responsesSubject.next(message); }, { noAck: true });\n                resolve();\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n\n    protected async publish(partialPacket: ReadPacket, callback: (packet: WritePacket) => void) {\n    }\n\n    private getQueues() {\n        return { pub: `${this.queue}_pub`, sub: `${this.queue}_sub` };\n    }\n}\n\n```", "```js\nprotected async publish(partialPacket: ReadPacket, callback: (packet: WritePacket) => void) {\n    if (!this.server || !this.channel) {\n        await this.connect();\n    }\n\n    const packet = this.assignPacketId(partialPacket);\n    const { sub } = this.getQueues();\n\n    this.responsesSubject.asObservable().pipe(\n        pluck('content'),\n        map(content => JSON.parse(content.toString()) as WritePacket & PacketId),\n        filter(message => message.id === packet.id),\n        take(1)\n    ).subscribe(({err, response, isDisposed}) => {\n        if (isDisposed || err) {\n            callback({\n                err,\n                response: null,\n                isDisposed: true\n            });\n        }\n\n        callback({err, response});\n    });\n\n    this.channel.sendToQueue(sub, Buffer.from(JSON.stringify(packet)));\n}\n\n```", "```js\nexport const microserviceConfig = {\n    url: process.env.AMQP_URL\n};\n\nexport const microserviceServerConfig: (channel: string) => CustomStrategy = channel => {\n    return {\n        strategy: new RabbitMQTransportServer(microserviceConfig.url, channel)\n    }\n};\n\n```", "```js\nasync function bootstrap() {\n    const app = await NestFactory.create(AppModule);\n    app.connectMicroservice(microserviceServerConfig('nestjs_book'));\n\n    await app.startAllMicroservicesAsync();\n    await app.listen(3001);\n}\n\n```", "```js\n@Controller()\nexport class UserController {\n    client: ClientProxy;\n\n    constructor(private readonly userService: UserService) {\n        this.client = new RabbitMQTransportClient(microserviceConfig.url, 'nestjs_book');\n    }\n}\n\n```", "```js\nconst ClientProxy = {\n  provide: 'ClientProxy',\n  useFactory: () => new RabbitMQTransportClient(microserviceConfig.url, 'nestjs_book')\n};\n\n@Module({\n    imports: [],\n    controllers: [],\n    components: [ClientProxy],\n    exports: [ClientProxy]\n})\nexport class RabbitMQTransportModule {}\n\n```", "```js\n@Controller()\nexport class UserController {\n\n    constructor(\n        private readonly userService: UserService,\n        @Inject('ClientProxy')\n        private readonly client: ClientProxy\n    ) {\n    }\n\n```", "```js\nasync function bootstrap() {\n    const app = await NestFactory.create(AppModule);\n    const rpcApp = await NestFactory.createMicroservice(AppModule, microserviceServerConfig('nestjs_book'));\n    rpcApp.useGlobalFilters(new RpcValidationFilter());\n\n    await rpcApp.listenAsync();\n    await app.listen(process.env.PORT || 3000);\n}\n\n```", "```js\n@MessagePattern({cmd: 'users.create'})\npublic async rpcCreate(data: CreateUserRequest) {\n    if (!data || (data && Object.keys(data).length === 0)) throw new RpcValidationException();\n    await this.userService.create(data);\n}\n\n```", "```js\nasync function bootstrapApp() {\n    const app = await NestFactory.create(AppModule);\n\n    await app.listen(process.env.PORT || 3000);\n}\n\nasync function bootstrapRpc() {\n    const rpcApp = await NestFactory.createMicroservice(AppModule, microserviceServerConfig('nestjs_book'));\n    rpcApp.useGlobalFilters(new RpcValidationFilter());\n\n    await rpcApp.listenAsync();\n}\n\nif (cluster.isMaster) {\n    const appWorkers = [];\n    const rpcWorkers = [];\n\n    for (let i = 0; i < os.cpus().length; i++) {\n        const app = cluster.fork({\n            APP_TYPE: 'NestApplication'\n        });\n        const rpc = cluster.fork({\n            APP_TYPE: 'NestMicroservice'\n        });\n\n        appWorkers.push(app);\n        rpcWorkers.push(rpc);\n    }\n\n    cluster.on('exit', function(worker, code, signal) {\n        if (appWorkers.indexOf(worker) > -1) {\n            const index = appWorkers.indexOf(worker);\n            const app = cluster.fork({\n                APP_TYPE: 'NestApplication'\n            });\n            appWorkers.splice(index, 1, app);\n        } else if (rpcWorkers.indexOf(worker) > -1) {\n            const index = rpcWorkers.indexOf(worker);\n            const rpc = cluster.fork({\n                APP_TYPE: 'NestMicroservice'\n            });\n            rpcWorkers.splice(index, 1, rpc);\n        }\n    });\n} else {\n    if (process.env.APP_TYPE === 'NestApplication') {\n        bootstrapApp();\n    } else if (process.env.APP_TYPE === 'NestMicroservice') {\n        bootstrapRpc();\n    }\n}\n\n```"]