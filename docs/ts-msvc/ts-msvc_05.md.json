["```ts\nvar serviceCommand = CommandsFactory.getOrCreate(\"Service on port :\"+ service.port +\":\"+ port)\n .circuitBreakerErrorThresholdPercentage(service.errorThreshold)\n .timeout(service.timeout)\n .run(makeRequest)\n .circuitBreakerRequestVolumeThreshold(service.concurrency)\n .circuitBreakerSleepWindowInMilliseconds(service.timeout)\n .statisticalWindowLength(10000)\n .statisticalWindowNumberOfBuckets(10)\n .errorHandler(isErrorHandler)\n .build();\n serviceCommand.service = service;\n commands.push(serviceCommand);\n```", "```ts\nconst express = require('express')\nconst httpProxy = require('express-http-proxy')\nconst app = express();\nconst productServiceProxy= httpProxy('https://10.0.0.1/') \n//10.0.0.1 is product container location\n// Authentication\napp.use((req, res, next) => {\n    // TODO: Central Authentication logic for all\n    next()\n    })\n// Proxy request\napp.get('/products/:productId', (req, res, next) => {\n    productServiceProxy(req, res, next)\n```", "```ts\nhttp:\n  port: 8990\n  serviceEndpoints:\n    example: # will be referenced in proxy policy\n    url: 'http://example.com'\n  apiEndpoints:\n  api:\n    path: '/*'\n  pipelines:\n  example-pipeline:\n    apiEndpoints: # process all request matching \"api\" apiEndpoint\n    - api\n  policies:\n  - jwt:\n  - action:\n  secretOrPublicKeyFile: '/app/key.pem'\n  - proxy:\n  - action:\n  serviceEndpoint: example # reference to serviceEndpoints Section\n```", "```ts\nzuul:\n  routes:\n    httpbin:\n      path: /**\n      serviceId: httpbin\n    httpbin:\n    ribbon:\n      listOfServers: httpbin.org,eu.httpbin.org\n    ribbon:\neureka:\n  client:\n    serviceUrl:\n    defaultZone:  \n    ${EUREKA_URL:http://user:password@localhost:5000}/eureka/\n```", "```ts\n#user gateway;\n worker_processes 1;\n events {worker_connections 1024;}\n http {\n     include mime.types;\n     default_type application/json;\n     keepalive_timeout 65;\n     server {\n         listen 443 ssl;\n         server_name yourdomain.com;\n         ssl_certificate cert.pem;\n         ssl_certificate_key cert.key;\n         ssl_session_cache shared:SSL:1m;\n         ssl_session_timeout 5m;\n         ssl_ciphers HIGH:!aNULL:!MD5;\n         ssl_prefer_server_ciphers on;\n         location public1.yourdomain.com {proxy_pass  \n         http://localhost:9000;}\n         location public2.yourdomain.com {proxy_pass \n         http://localhost:9001;}\n         location public3.yourdomain.com {proxy_pass   \n         http://localhost:9002;}\n     }\n }\n```", "```ts\nconstructor(host, user, password, queues, prefetch) {\n    super();\n    this._url = `amqp://${user}:${password}@${host}`;\n    this._queues = queues || [ 'default' ];\n    this._prefetch = prefetch;\n}\n```", "```ts\nconnect() {\n    return amqp.connect(this._url)\n    .then(connection => (this._connection =  \n    connection).createChannel())\n    .then(channel => {\n        this._channel = channel;\n        channel.prefetch(this._prefetch);\n        var promises = [];\n        for (var queue of this._queues) {\n            promises.push(\n            channel.assertQueue(queue, { durable: true })\n            .then(result => channel.consume(result.queue, \n            (message) => {\n                if (message != null) {\n                    this.emit('messageReceived',  \n                    JSON.parse(message.content), \n                    result.queue, message);\n                }\n            }, { noAck: false }))\n            );\n        }\n        return Promise.all(promises);\n    });\n}\n```", "```ts\nsend(queue, message) {\n    var messageBuff = new Buffer(JSON.stringify(message));\n    return this._channel.assertQueue(queue, { durable: true })\n    .then(result => this._channel.sendToQueue(result.queue, \n    messageBuff, { persistent: true }));\n}\n```", "```ts\n...\nconstructor(){ this._conn = new RabbitMqConnection(host, user, password, queues, 1);}\n...\naddTask(queue, task) {\n    return this._conn.send(queue, task);\n}\n...\n```"]