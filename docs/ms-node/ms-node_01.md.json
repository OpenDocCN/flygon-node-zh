["```js\n// find-byte.c \nint find_byte(const char *buffer, int size, const char b) {\n   for (int i = 0; i < size; i++) {\n         if (buffer[i] == b) {\n               return i;\n         }\n   }\n   return -1; \n}\n```", "```js\n// combine-text.js\nconst s1 = \"first string\";\nconst s2 = \"second string\";\nlet s3 = s1 + s2;\n```", "```js\n// combine-text.c \nconst char *s1 = \"first string\";\nconst char *s2 = \"second string\";\nint size = strlen(s1) + strlen(s2);\nchar *buffer = (char *)malloc(size + 1); // One more for the 0x00 byte that terminates strings \nstrcpy(buffer, s1);\nstrcat(buffer, s2);\nfree(buffer); // Never forget to free memory!\n```", "```js\n// find-byte.js\nfunction find_byte(buffer, b) {\n  let i;\n  for (i = 0; i < buffer.length; i++) {\n    if (buffer[i] == b) {\n      return i;\n    }\n  }\n  return -1; // Not found\n}\nlet buffer = Buffer.from(\"ascii A is byte value sixty-five\", \"utf8\");\nlet r = find_byte(buffer, 65); // Find the first byte with value 65\nconsole.log(r); // 6 bytes into the buffer\n```", "```js\n// speed-loop.js\nfunction main() {\n  const cycles = 1000000000;\n  let start = Date.now();\n  for (let i = 0; i < cycles; i++) {\n    /* Empty loop */\n  }\n  let end = Date.now();\n  let duration = (end - start) / 1000;\n  console.log(\"JavaScript looped %d times in %d seconds\", cycles, duration);\n}\nmain();\n```", "```js\n$ node --version\nv9.3.0\n$ node speed-loop.js\nJavaScript looped 1000000000 times in 0.635 seconds\n```", "```js\n/* speed-loop.c */\n#include <stdio.h>\n#include <time.h>\nint main() {\n  int cycles = 1000000000;\n  clock_t start, end;\n  double duration;\n  start = clock();\n  for (int i = 0; i < cycles; i++) {\n    /* Empty loop */\n  }\n  end = clock();\n  duration = ((double)(end - start)) / CLOCKS_PER_SEC;\n  printf(\"C looped %d times in %lf seconds\\n\", cycles,duration);\n  return 0;\n}\n```", "```js\n$ gcc --version\nApple LLVM version 8.1.0 (clang-802.0.42)\n$ gcc speed-loop.c -o speed-loop\n$ ./speed-loop\nC looped 1000000000 times in 2.398294 seconds\n```", "```js\n# speed-loop.py\n\nimport time\n\ndef main():\n\n  cycles = 1000000000\n  start = time.perf_counter()\n\n  for i in range(0, cycles):\n    pass # Empty loop\n\n  end = time.perf_counter()\n  duration = end - start\n  print(\"Python looped %d times in %.3f seconds\" % (cycles, duration))\n\nmain()\n```", "```js\n$ python3 --version\nPython 3.6.1\n$ python3 speed-loop.py\nPython looped 1000000000 times in 31.096 seconds\n```", "```js\nint mkdir(const char *path, mode_t mode);\n```", "```js\nfs.mkdir(path[, mode], callback)\n```", "```js\npthread_t my_thread;\nint x = 0;\n/* Make a thread and have it run my_function(&x) */\npthread_create(&my_thread, NULL, my_function, &x);\n```", "```js\n<button onclick=\"myFunction()\">Click me</button>\n```", "```js\nWindow.onload = function() {\n  // When all requested document resources are loaded,\n  // do something with the resulting environment\n}\nelement.onclick = function() {\n  // Do something when the user clicks on this element\n}\n```", "```js\n// File counter.js\n// Load Node's 'events' module, and point directly to EventEmitter there\nconst EventEmitter = require('events').EventEmitter;\n// Define our Counter function\nconst Counter = function(i) { // Takes a starting number\n  this.increment = function() { // The counter's increment method\n    i++; // Increment the count we hold\n    this.emit('incremented', i); // Emit an event named incremented\n  }\n}\n// Base our Counter on Node's EventEmitter\nCounter.prototype = new EventEmitter(); // We did this afterwards, not before!\n// Now that we've defined our objects, let's see them in action\n// Make a new Counter starting at 10\nconst counter = new Counter(10);\n// Define a callback function which logs the number n you give it\nconst callback = function(n) {\n  console.log(n);\n}\n// Counter is an EventEmitter, so it comes with addListener\ncounter.addListener('incremented', callback);\ncounter.increment(); // 11\ncounter.increment(); // 12\n```", "```js\n$ node counter.js\n11\n12\n```", "```js\ncounter.removeListener('incremented', callback).\n```", "```js\n// File stream.js\n// Use Node's stream module, and get Readable inside\nlet Readable = require('stream').Readable;\n// Make our own readable stream, named r\nlet r = new Readable;\n// Start the count at 0\nlet count = 0;\n// Downstream code will call r's _read function when it wants some data from r\nr._read = function() {\n  count++;\n  if (count > 10) { // After our count has grown beyond 10\n    return r.push(null); // Push null downstream to signal we've got no more data\n  }\n  setTimeout(() => r.push(count + '\\n'), 500); // A half second from now, push our count on a line\n};\n// Have our readable send the data it produces to standard out\nr.pipe(process.stdout);\n```", "```js\n$ node stream.js\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n```", "```js\n// File stream2file.js\n// Bring in Node's file system module\nconst fs = require('fs');\n// Make the file counter.txt we can fill by writing data to writeable stream w\nconst w = fs.createWriteStream('./counter.txt', { flags: 'w', mode: 0666 });\n...\n// Put w beneath r instead\nr.pipe(w);\n```", "```js\n<head>\n<script src=\"img/fileA.js\"></script>\n<script src=\"img/fileB.js\"></script>\n<script src=\"img/fileC.js\"></script>\n<script src=\"img/fileD.js\"></script>\n...\n</head>\n```", "```js\n{\n  \"name\": \"mypackage1\",\n  \"version\": \"0.1.2\",\n  \"dependencies\": {\n    \"jquery\": \"^3.1.0\",\n    \"bluebird\": \"^3.4.1\",\n  },\n  \"license\": \"MIT\"\n}\n```", "```js\nconst dgram = require('dgram');\nlet client = dgram.createSocket(\"udp4\");\nlet server = dgram.createSocket(\"udp4\");\nlet message = process.argv[2] || \"message\";\nmessage = Buffer.from(message);\nserver\n.on('message', msg => {\n  process.stdout.write(`Got message: ${msg}\\n`);\n  process.exit();\n})\n.bind(41234);\nclient.send(message, 0, message.length, 41234, \"localhost\");\n```", "```js\n$ node receive.js\n```", "```js\n$ node send.js\n```", "```js\n$ node receive.js\nMessage received!\n```", "```js\n$ node -h\n```", "```js\n$ node --v8-options\n```", "```js\n$ node \u2013e \"console.log(process.versions.v8)\"\n```", "```js\nlet a = 7;\na = 7.77;\n```", "```js\n// program.js\nlet someFunc = function foo(){}\nconsole.log(%FunctionGetName(someFunc));\n```", "```js\nnode --allow-natives-syntax program.js\n// 'someFunc', the function name, is printed to the console.\n```", "```js\nlet operand = 3;\nfunction square() {\n    return operand * operand;\n}\n// Make first pass to gather type information\nsquare();\n// Ask that the next call of #square trigger an optimization attempt;\n// Call\n%OptimizeFunctionOnNextCall(square);\nsquare();\n```", "```js\n [deoptimize context: c39daf14679]\n [optimizing: square / c39dafca921 - took 1.900, 0.851, 0.000 ms]\n```", "```js\n%OptimizeFunctionOnNextCall(square);\noperand = 3.01;\nsquare();\n```", "```js\n**** DEOPT: square at bailout #2, address 0x0, frame size 8\n [deoptimizing: begin 0x2493d0fca8d9 square @2]\n ...\n [deoptimizing: end 0x2493d0fca8d9 square => node=3, pc=0x29edb8164b46, state=NO_REGISTERS, alignment=no padding, took 0.033 ms]\n [removing optimized code for: square]\n```", "```js\nlet a = [];\na[2] = 'foo';\na[23] = 'bar';\n```", "```js\nconst {promisify} = require('util');\nconst fs = require('fs');\n\n// Promisification happens here\nlet readFileAsync = promisify(fs.readFile);\n\nlet [executable, absPath, target, ...message] = process.argv;\n\nconsole.log(message.length ? message.join(' ') : `Running file ${absPath} using binary ${executable}`);\n\nreadFileAsync(target, {encoding: 'utf8'})\n.then(console.log)\n.catch(err => {\n  let message = err.message;\n  console.log(`\n    An error occurred!\n    Read error: ${message}\n  `);\n});\n```", "```js\nlet foo = 'bar';\n\nif(foo == 'bar') {\n    let foo = 'baz';\n    console.log(foo); // 1st\n}\nconsole.log(foo); // 2nd\n\n// baz\n// bar\n// If we had used var instead of let:\n// baz\n// baz\n```", "```js\nconst foo = 1;\nfoo = 2; // Error: assignment to a constant variable\n```", "```js\nconst foo = { bar: 1 }\nconsole.log(foo.bar) // 1\nfoo.bar = 2;\nconsole.log(foo.bar) // 2\n```", "```js\nlet obj = {\n    foo: 'foo!',\n    bar: 'bar!',\n    baz: 'baz!'\n};\n\n// assign keys to local variables with same names\nlet {foo, baz} = obj;\n\n// Note that we \"skipped\" #bar\nconsole.log(foo, baz); // foo! baz!\n```", "```js\nfunction (a, b) {\n    // Grab any arguments after a & b and convert to proper Array\n    let args = Array.prototype.slice.call(arguments, f.length);\n}\n```", "```js\nfunction (a, b, ...args) {\n    // #args is already an Array!\n}\n```", "```js\nconst week = ['mon','tue','wed','thur','fri'];\nconst weekend = ['sat','sun'];\n\nconsole.log([...week, ...weekend]); // ['mon','tue','wed','thur','fri','sat','sun']\n\nweek.push(...weekend);\nconsole.log(week); // ['mon','tue','wed','thur','fri','sat','sun']\n```", "```js\nfunction Counter() {\n    this.count = 0;\n\n    setInterval(function() {\n        console.log(this.count++);\n    }, 1000);\n}\n\nnew Counter();\n```", "```js\nsetInterval(() => { // arrow function to the rescue!\n  console.log(this);\n  console.log(this.count++);\n}, 1000);\n// Counter { count: 0 }\n// 0\n// Counter { count: 1 }\n// 1\n// ...\n```", "```js\nlet name = 'Sandro';\nconsole.log('My name is ' + name);\nconsole.log(`My name is ${name}`);\n// My name is Sandro\n// My name is Sandro\n```", "```js\nconsole.log(`2 + 2 = ${2+2}`)  // 2 + 2 = 4\n```", "```js\nfor(let c of 'Mastering Node.js') {\n    console.log(c);\n    // M\n    // a\n    // s\n    // ...\n}\n```", "```js\nconsole.log([...'Mastering Node.js']);\n// ['M', 'a', 's',...]\n```", "```js\nlet targ = 'The rain in Spain lies mostly on the plain';\nconsole.log(targ.startsWith('The', 0)); // true\nconsole.log(targ.startsWith('The', 1)); // false\nconsole.log(targ.endsWith('plain')); // true\nconsole.log(targ.includes('rain', 5)); // false\n```", "```js\nconst size = process.argv[2];\nconst n = process.argv[3] || 100;\nconst buffers = [];\nlet i;\nfor (i = 0; i < n; i++) {\n  buffers.push(Buffer.alloc(size));\n  process.stdout.write(process.memoryUsage().heapTotal + \"\\n\");\n}\n```", "```js\n$ node process.js 1000000 100\n```", "```js\n$ node process.js 1000000 100 > output.txt\n```", "```js\n(global (fileSystem (readDir (anonymous function) ) ) )\n```", "```js\n$ node\n```", "```js\n$ node\n> 2+2\n4\n```", "```js\n> a\nReferenceError: a is not defined\n at repl:1:1\n at sigintHandlersWrap (vm.js:22:35)\n at sigintHandlersWrap (vm.js:96:12)\n at ContextifyScript.Script.runInThisContext (vm.js:21:12)\n at REPLServer.defaultEval (repl.js:346:29)\n at bound (domain.js:280:14)\n at REPLServer.runBound [as eval] (domain.js:293:12)\n at REPLServer.<anonymous> (repl.js:545:10)\n at emitOne (events.js:101:20)\n at REPLServer.emit (events.js:188:7)\n> a = 7\n7\n> a\n7\n```", "```js\nrequire('repl').start(\"> \").context.sayHello = function() {\n  return \"Hello\";\n};\n```", "```js\n// File client.js\nlet net = require(\"net\");\nlet sock = net.connect(8080);\nprocess.stdin.pipe(sock);\nsock.pipe(process.stdout);\n\n// File server.js\nlet repl = require(\"repl\")\nlet net = require(\"net\")\nnet.createServer((socket) => {\n  repl\n  .start({\n    prompt: \"> \",\n    input: socket,\n    output: socket,\n    terminal: true\n  }).on('exit', () => {\n    socket.end();\n  })\n}).listen(8080);\n```"]