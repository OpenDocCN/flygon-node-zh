["```js\n/hello_module\n  binding.gyp\n  hello.cc\n  index.js\n```", "```js\n#include <node.h>\n\nnamespace hello_module {\n\n    using v8::FunctionCallbackInfo;\n    using v8::Isolate;\n    using v8::Local;\n    using v8::Object;\n    using v8::String;\n    using v8::Value;\n\n    // Our first native function\n    void sayHello(const FunctionCallbackInfo<Value>& args) {\n      Isolate* isolate = args.GetIsolate();\n      args.GetReturnValue().Set(String::NewFromUtf8(isolate, \"Hello Node from native code!\"));\n    }\n\n    // The initialization function for our module\n    void init(Local<Object> exports) {\n      NODE_SET_METHOD(exports, \"sayHello\", sayHello);\n    }\n\n    // Export the initialization function\n    NODE_MODULE(NODE_GYP_MODULE_NAME, init)\n}\n```", "```js\n{\n \"targets\": [\n   {\n     \"target_name\": \"hello\",\n     \"sources\": [ \"hello.cc\" ]\n   }\n ]\n} \n```", "```js\n $ node-gyp configure\n```", "```js\n$ node-gyp configure\n gyp info it worked if it ends with ok\n gyp info using node-gyp@3.6.2\n gyp info using node@8.7.0 | darwin | x64\n gyp info spawn /usr/bin/python\n gyp info spawn args [ '/usr/local/lib/node_modules/node-gyp/gyp/gyp_main.py',\n gyp info spawn args   'binding.gyp',\n gyp info spawn args   '-f',\n gyp info spawn args   'make',\n gyp info spawn args   '-I',\n\n ...\n\n gyp info spawn args   '--generator-output',\n gyp info spawn args   'build',\n gyp info spawn args   '-Goutput_dir=.' ]\n gyp info ok\n```", "```js\n$ node-gyp build\n gyp info it worked if it ends with ok\n gyp info using node-gyp@3.6.2\n gyp info using node@8.7.0 | darwin | x64\n gyp info spawn make\n gyp info spawn args [ 'BUILDTYPE=Release', '-C', 'build' ]\n     CXX(target) Release/obj.target/hello_native/hello.o\n     SOLINK_MODULE(target) Release/hello_native.node\n gyp info ok \n```", "```js\n// index.js\nmodule.exports = require('./build/Release/hello');\n```", "```js\nconst {sayHello} = require('./hello_module');\nconsole.log(sayHello())\n```", "```js\n$ node hello.js\nHello Node from native code!\n```", "```js\n#include <node.h>\n\nnamespace calculator_module {\n\n  using v8::Exception;\n  using v8::FunctionCallbackInfo;\n  using v8::Isolate;\n  using v8::Local;\n  using v8::Number;\n  using v8::Object;\n  using v8::String;\n  using v8::Value;\n\n  void Add(const FunctionCallbackInfo<Value>& args) {\n    Isolate* isolate = args.GetIsolate();\n\n    // Check argument arity\n    if (args.Length() < 2) {\n      isolate->ThrowException(Exception::TypeError(\n        String::NewFromUtf8(isolate, \"Must send two argument to #add\")));\n      return;\n    }\n\n    // Check argument types\n    if (!args[0]->IsNumber() || !args[1]->IsNumber()) {\n      isolate->ThrowException(Exception::TypeError(\n        String::NewFromUtf8(isolate, \"#add only accepts numbers\")));\n      return;\n    }\n\n    // The actual calculation now\n    double value = args[0]->NumberValue() + args[1]->NumberValue();\n    Local<Number> num = Number::New(isolate, value);\n\n    // Set the return value (using the passed in FunctionCallbackInfo<Value>&)\n    args.GetReturnValue().Set(num);\n  }\n\n  void Subtract(const FunctionCallbackInfo<Value>& args) {\n    Isolate* isolate = args.GetIsolate();\n\n    if (args.Length() < 2) {\n      isolate->ThrowException(Exception::TypeError(\n        String::NewFromUtf8(isolate, \"Must send two argument to #subtract\")));\n      return;\n    }\n\n    if (!args[0]->IsNumber() || !args[1]->IsNumber()) {\n      isolate->ThrowException(Exception::TypeError(\n        String::NewFromUtf8(isolate, \"#subtract only accepts numbers\")));\n      return;\n    }\n\n    double value = args[0]->NumberValue() - args[1]->NumberValue();\n    Local<Number> num = Number::New(isolate, value);\n\n    args.GetReturnValue().Set(num);\n  }\n\n  void Init(Local<Object> exports) {\n    NODE_SET_METHOD(exports, \"add\", Add);\n    NODE_SET_METHOD(exports, \"subtract\", Subtract);\n  }\n\n  NODE_MODULE(NODE_GYP_MODULE_NAME, Init)\n}\n```", "```js\nLocal<Number> num = Number::New(args[0]->NumberValue() + args[1]->NumberValue());\n return scope.Close(num);\n```", "```js\nvoid Init(Handle<Object> exports) {\n  exports->Set(String::NewSymbol(\"add\"),\n    FunctionTemplate::New(Add)->GetFunction());\n  exports->Set(String::NewSymbol(\"subtract\"),\n    FunctionTemplate::New(Subtract)->GetFunction());\n }\n```", "```js\nlet calculator = require('./build/Release/calculator');\nconsole.log(calculator.add(2,3));\nconsole.log(calculator.subtract(3,2));\n// 5\n// 1\n```", "```js\n// package.json\n{\n  \"name\": \"hello\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"build\": \"node-gyp rebuild\",\n    \"start\": \"node index.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"nan\": \"^2.8.0\",\n    \"node-gyp\": \"^3.6.2\"\n  },\n  \"gypfile\": true\n}\n```", "```js\n// binding.gyp\n{\n  \"targets\": [{\n     \"include_dirs\": [\n        \"<!(node -e \\\"require('nan')\\\")\"\n      ],\n      \"target_name\": \"hello\",\n      \"sources\": [\n        \"hello.cc\"\n      ]\n  }]\n}\n```", "```js\n#include <nan.h>\n\nNAN_METHOD(sayHello) {\n    auto message = Nan::New(\"Hello Node from NAN code!\").ToLocalChecked();\n    // 'info' is an implicit bridge object between JavaScript and C++\n    info.GetReturnValue().Set(message);\n}\n\nNAN_MODULE_INIT(Initialize) {\n    // Similar to the 'export' statement in Node -- export the sayHello method\n    NAN_EXPORT(target, sayHello);\n}\n\n// Create and Initialize function created with NAN_MODULE_INIT macro\nNODE_MODULE(hello, Initialize);\n```", "```js\nconst {Hello} = require('./build/Release/hello');\nconsole.log(Hello());\n```", "```js\n$ npm run build\n```", "```js\n$ node index.js\n// Hello Node from NAN code!\n```", "```js\n{\n  \"targets\": [\n    {\n      \"target_name\": \"nan_addon\",\n      \"sources\": [\n        \"addon.cc\",\n        \"sync.cc\",\n        \"async.cc\"\n      ],\n      \"include_dirs\": [\"<!(node -e \\\"require('nan')\\\")\"]\n    }\n  ]\n}\n```", "```js\n// addons.h\nusing namespace Nan;\n\nint Run (int cycles) {\n    // using volatile prevents compiler from optimizing loop (slower)\n    volatile int i = 0;\n    for (; i < cycles; i++) {}\n    return cycles;\n}\n```", "```js\n// sync.cc\n#include <nan.h>\nint Run(int cycles);\n\n// Simple synchronous access to the `Run()` function\nNAN_METHOD(RunSync) {\n // Expect a number as first argument\n int cycles = info[0]->Uint32Value();\n int result = Run(cycles);\n\n info.GetReturnValue().Set(result);\n}\n```", "```js\n// async.cc\n#include <nan.h>\n\nusing v8::Local;\nusing v8::Number;\nusing v8::Value;\nusing namespace Nan;\n\nint Run(int cycles);\n\nclass Worker : public AsyncWorker {\n public:\n  Worker(Callback *callback, int cycles)\n    : AsyncWorker(callback), cycles(cycles) {}\n  ~Worker() {}\n\n  // This executes in the worker thread.\n  // #result is being place on \"this\" (private.result)\n  void Execute () {\n    result = Run(cycles);\n  }\n\n  // When the async work is complete execute this function in the main event loop\n  // We're sending back two arguments to fulfill standard Node callback\n  // pattern (error, result) -> (Null(), New<Number>(result))\n  void HandleOKCallback () {\n    HandleScope scope;\n    Local<Value> argv[] = {\n        Null()\n      , New<Number>(result)\n    };\n    callback->Call(2, argv);\n  }\n\n private:\n  int cycles;\n  int result;\n};\n\nNAN_METHOD(RunAsync) {\n  int cycles = To<int>(info[0]).FromJust();\n  Callback *callback = new Callback(To<v8::Function>(info[1]).ToLocalChecked());\n\n  AsyncQueueWorker(new Worker(callback, cycles));\n}\n```", "```js\nconst addon = require('./build/Release/nan_addon');\nconst width = 1e9;\n\nfunction log(type, result, start) {\n    const end = Date.now() - start;\n    console.log(`${type} returned <${result}> in ${end}ms`)\n}\n\nfunction sync() {\n    const start = Date.now();\n    const result = addon.runSync(width);\n    log('Sync', result, start);\n}\n\nfunction async() {\n    const start = Date.now();\n    addon.runAsync(width, (err, result) => {\n        log('Async', result, start);\n    });\n}\n\nconsole.log('1');\nasync();\nconsole.log('2');\nsync();\nconsole.log('3');\n```", "```js\n1\n2\nSync returned <1000000000> in 1887ms\n3\nAsync returned <1000000000> in 1889ms\n```", "```js\n1\nAsync returned <1000000000> in 1889ms\n2\nSync returned <1000000000> in 1887ms\n3\n```"]