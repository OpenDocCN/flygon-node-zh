["```js\nfunction fetch() {\n  $.getJSON(\"/service\", (data) => {\n    // Do something with data\n    updateDisplay(data);\n    // Call again in 5 seconds\n    setTimeout(fetch, 5000);\n  });\n}\nfetch(); \n```", "```js\nfunction fetch() {\n  clearTimeout(caller);\n  let symbol = $(\"#symbol\").val();\n\n  $.getJSON(`/?symbol=${symbol}`, function(data) {\n    if(!data.callIn) {\n      return;\n    }\n    caller = setTimeout(fetch, data.callIn);\n    if(data.error) {\n      return console.error(data.error);\n    }\n    let quote = data.quote;\n    let keys = fetchNumericFields(quote);\n\n    ...\n\n    updateDisplay(symbol, quote, keys);\n  });\n}\n```", "```js\nhttps.get(query, res => {\n let data = \"\";\n res.on('readable', function() {\n   let d;\n   while(d = this.read()) {\n     data += d.toString();\n   }\n }).on('end', function() {\n   let out = {};\n   try {\n     data = JSON.parse(data);\n     out.quote = data;\n     out.callIn = 5000;\n\n     Object.keys(out.quote).forEach(k => {\n       // Creating artificial change (random)\n       // Normally, the data source would change regularly.\n       v = out.quote[k];\n       if(_.isFinite(v)) {\n         out.quote[k] = +v + Math.round(Math.random());\n       }\n     })\n\n   } catch(e) {\n     out = {\n       error: \"Received empty data set\",\n       callIn: 10000\n     };\n   }\n   response.writeHead(200, {\n     \"Content-type\" : \"application/json\"\n   });\n   response.end(JSON.stringify(out));\n  });\n}).on('error', err => {\n  response.writeHead(200, {\n    \"Content-type\" : \"application/json\"\n  });\n  response.end(JSON.stringify({\n    error: err.message,\n    callIn: null\n  }));\n});\n```", "```js\nlet conn = new WebSocket(\"ws://localhost:8080\", ['json', 'xml']); \n```", "```js\n<head>\n  <title></title>\n   <script>\n\n     let conn = new WebSocket(\"ws://localhost:8080\", 'json');\n     conn.onopen = () => {\n       conn.send('Hello from the client!');\n     };\n     conn.onerror = (error) => {\n       console.log('Error! ' + error);\n     };\n     conn.onclose = () => {\n       console.log(\"Server has closed the connection!\");\n     };\n     conn.onmessage = (msg) => {\n       console.log('Received: ' + msg.data);\n     };\n   </script>\n</head>\n\n```", "```js\nlet SocketServer = require('ws').Server;\n  let wss = new SocketServer({port: 8080});\n  wss.on('connection', ws => {\n    ws.on('message', (message) => {\n      console.log('received: %s', message);\n    });\n    ws.send(\"You've connected!\");\n });\n\n```", "```js\nws.close(); \n```", "```js\n$ npm install socket.io \n```", "```js\nlet io = require('socket.io').listen(8080);\nio.sockets.on('connection', socket => {\n  socket.emit('broadcast', { message: 'Hi!' });\n  socket.on('clientmessage', data => {\n    console.log(\"Client said\" + data);\n  });\n});\n```", "```js\n<script src=\"img/socket.io.js\"></script>\n <script>\n   let socket = io.connect('http://localhost:8080');\n   socket.on('broadcast', data => {\n     console.log(`Server sent: ${JSON.stringify(data)}`);\n     socket.emit('clientmessage', { message: 'ohai!' });\n   });\n </script> \n```", "```js\nio.sockets.on('connection', socket => {\n  let id = socket.id;\n\n  socket.on('mousemove', data => {\n    data.id = id;\n    socket.broadcast.emit('moving', data);\n  });\n\n  socket.on('disconnect', () => {\n    socket.broadcast.emit('clientdisconnect', id);\n  });\n});\n```", "```js\n<head>\n     <style type=\"text/css\">\n     /* CSS styling for the pointers and canvas */\n     </style>\n     <script src=\"img/socket.io.js\"></script>\n     <script src=\"img/script.js\"></script>\n </head>\n <body>\n     <div id=\"pointers\"></div>\n     <canvas id=\"canvas\" width=\"2000\" height=\"1000\"></canvas>\n </body>\n\n```", "```js\nlet socket = io.connect(\"/\");\nlet prev = {};\nlet canvas = document.getElementById('canvas');\nlet context = canvas.getContext('2d');\nlet pointerContainer = document.getElementById(\"pointers\");\n\nlet pointer = document.createElement(\"div\");\npointer.setAttribute(\"class\", \"pointer\");\n\nlet drawing = false;\nlet clients = {};\nlet pointers = {};\n\nfunction drawLine(fromx, fromy, tox, toy) {\n  context.moveTo(fromx, fromy);\n  context.lineTo(tox, toy);\n  context.stroke();\n}\nfunction now() {\n  return new Date().getTime();\n}\nlet lastEmit = now();\ncanvas.onmouseup = canvas.onmousemove = canvas.onmousedown = function(e) {\n  switch(e.type) {\n    case \"mouseup\":\n      drawing = false;\n      break;\n\n    case \"mousemove\":\n      if(now() - lastEmit > 50) {\n        socket.emit('mousemove', {\n          'x' : e.pageX,\n          'y' : e.pageY,\n          'drawing' : drawing\n        });\n        lastEmit = now();\n      }\n      if(drawing) {\n        drawLine(prev.x, prev.y, e.pageX, e.pageY);\n        prev.x = e.pageX;\n        prev.y = e.pageY;\n      }\n      break;\n\n    case \"mousedown\":\n      drawing = true;\n      prev.x = e.pageX;\n      prev.y = e.pageY;\n      break;\n\n    default: \n      break;\n  }\n};\n```", "```js\nsocket.on('moving', data => {\n  if (!clients.hasOwnProperty(data.id)) {\n    pointers[data.id] = pointerContainer.appendChild(pointer.cloneNode());\n  }\n  pointers[data.id].style.left = data.x + \"px\";\n  pointers[data.id].style.top = data.y + \"px\";\n\n  if (data.drawing && clients[data.id]) {\n    drawLine(clients[data.id].x, clients[data.id].y, data.x, data.y);\n  }\n  clients[data.id] = data;\n  clients[data.id].updated = now();\n});\n\n```", "```js\nsocket.on(\"clientdisconnect\", id => {\n  delete clients[id];\n  if (pointers[id]) {\n    pointers[id].parentNode.removeChild(pointers[id]);\n  }\n}); \n```", "```js\nlet eventSource = new EventSource('/login'); \n```", "```js\n<script>\n  let eventSource = new EventSource('/login');\n  eventSource.addEventListener('message', (broadcast) => {\n    console.log(\"got message: \" + broadcast);\n  });\n  eventSource.addEventListener('open', () => {\n    console.log(\"connection opened\");\n  });\n  eventSource.addEventListener('error', () => {\n    console.log(\"connection error/closed\");\n  });\n </script> \n```", "```js\nconst http = require(\"http\");\nconst url = require(\"url\");\nhttp.createServer((request, response) => {\n  let parsedURL = url.parse(request.url, true);\n  let pathname = parsedURL.pathname;\n  let args = pathname.split(\"/\");\n  let method = args[1];\n  if (method === \"login\") {\n    response.writeHead(200, {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      \"Connection\": \"keep-alive\"\n    });\n    response.write(\":\" + Array(2049).join(\" \") + \"\\n\");\n    response.write(\"retry: 2000\\n\");\n    response.on(\"close\", () => {\n      console.log(\"client disconnected\");\n    });\n    setInterval(() => {\n      response.write(\"data: \" + new Date() + \"\\n\\n\");\n    }, 1000);\n    return;\n  }\n}).listen(8080);\n```", "```js\nresponse.write(\":\" + Array(2049).join(\" \") + \"\\n\");\nresponse.write(\"retry: 2000\\n\");\n```", "```js\nsetInterval(() => {\n  response.write(\"data: \" + new Date() + \"\\n\\n\");\n }, 1000);\n```", "```js\n<html>\n <head>\n     <script>\n       let ev = new EventSource('/login');\n       ev.addEventListener(\"message\", broadcast => {\n         document.getElementById(\"clock\").innerHTML = broadcast.data;\n       });\n     </script>\n </head>\n <body>\n     <div id=\"clock\"></div>\n </body>\n </html>\n```", "```js\nresponse.write(\"id:\" + (++message_counter) + \"\\n\");\nresponse.write(\"data: I'm a message\\n\\n\");\nresponse.write(\"retry: 10000\\n\\n\");\nresponse.write(\"id:\" + (++message_counter) + \"\\n\");\nresponse.write(\"event: stock\\n\");\nresponse.write(\"data: \" + JSON.stringify({price: 100, change: -2}) + \"\\n\\n\");\nresponse.write(\"event: stock\\n\");\nresponse.write(\"data: \" + stock.price + \"\\n\");\nresponse.write(\"data: \" + stock.change + \"\\n\");\nresponse.write(\"data: \" + stock.symbol + \"\\n\\n\");\nresponse.write(\"data: Hello World\\n\\n\");\n```", "```js\n event: actionA\\n\n data: Message A here\\n\\n\n\n event: actionB\\n\n data: Message B here\\n\\n\n```", "```js\nev.addEventListener(\"actionA\", (broadcast) => {\n  console.log(broadcast.data);\n});\nev.addEventListener(\"actionB\", (broadcast) => {\n  console.log(broadcast.data);\n}); \n```", "```js\nlet clients = {};\nlet clientQMap = {};\nlet questions = {};\nlet answers    = {};\n\nfunction removeClient(id) {\n  if(id) {\n    delete clients[id];\n    delete clientQMap[id];\n  }\n}\n```", "```js\n\n http.createServer((request, response) => {\n   let parsedURL = url.parse(request.url, true);\n   let pathname = parsedURL.pathname;\n   let args = pathname.split(\"/\");\n   //  Lose initial null value\n   args.shift();\n   let method = args.shift();\n   let parameter = decodeURIComponent(args[0]);\n   let sseUserId = request.headers['_sse_user_id_'];\n   if (method === \"login\") {\n     response.writeHead(200, {\n       \"Content-Type\": \"text/event-stream\",\n       \"Cache-Control\": \"no-cache\"\n   });\n   response.write(\":\" + Array(2049).join(\" \") + \"\\n\"); // 2kB\n   response.write(\"retry: 2000\\n\");\n   removeClient(sseUserId);\n   // A very simple id system. You'll need something more secure.\n   sseUserId = (USER_ID++).toString(36);\n   clients[sseUserId] = response;\n   broadcast(sseUserId, {\n     type : \"login\",\n     userId : sseUserId\n   });\n   broadcast(sseUserId, {\n     type : \"questions\",\n     questions : questions\n   });\n   response.on(\"close\", () => {\n     removeClient(sseUserId);\n   });\n\n   // To keep the conn alive we send a \"heartbeat\" every 10 seconds.\n   // https://bugzilla.mozilla.org/show_bug.cgi?id=444328\n   setInterval(() => {\n     broadcast(sseUserId, new Date().getTime(), \"ping\");\n   }, 10000);\n   return;\n}).listen(8080);\n```", "```js\nsseUserId = (USER_ID++).toString(36);\nclients[sseUserId] = response;\n```", "```js\nbroadcast(sseUserId, sseUserId, \"login\");\n```", "```js\n evSource.addEventListener('login', broadcast => {\n   USER_ID = JSON.parse(broadcast.data);\n });\n let xhr = new XMLHttpRequest();\n xhr.open(\"POST\", \"/...\");\n xhr.setRequestHeader('_sse_user_id_', USER_ID);\n ...\n```", "```js\nlet broadcast = function(toId, msg, eventName) {\n  if (toId === \"*\") {\n    for (let p in clients) {\n      broadcast(p, msg);\n    }\n    return;\n  }\n  let clientSocket = clients[toId];\n  if (!clientSocket) {\n    return;\n  }\n  eventName && clientSocket.write(`event: ${eventName}\\n`);\n  clientSocket.write(`id: ${++UNIQUE_ID}\\n`);\n  clientSocket.write(`data: ${JSON.stringify(msg)}\\n\\n`);\n }\n\n```", "```js\nif (method === \"askquestion\") {\n  // Already asked?\n  if (questions[parameter]) {\n    return response.end();\n  }\n  questions[parameter] = sseUserId;    \n  broadcast(\"*\", {\n    type : \"questions\",\n    questions : questions\n  });\n  return response.end();\n} \n```", "```js\nif (method === \"addanswer\") {\n     ...\n  answers[curUserQuestion] = answers[curUserQuestion] || [];\n  answers[curUserQuestion].push(parameter);\n  for (var id in clientQMap) {\n    if (clientQMap[id] === curUserQuestion) {\n      broadcast(id, {\n        type : \"answers\",\n        question : curUserQuestion,\n        answers : answers[curUserQuestion]\n      });\n    }\n  }\n  return response.end();\n}\n```", "```js\nif (method === \"selectquestion\") {\n  if (parameter && questions[parameter]) {\n    clientQMap[sseUserId] = parameter;\n    broadcast(sseUserId, {\n      type : \"answers\",\n      question : parameter,\n      answers : answers[parameter] ? answers[parameter] : []\n    });\n  }\n   return response.end();\n}\n```", "```js\n let USER_ID = null;\n let evSource = new EventSource('/login');\n let answerContainer = document.getElementById('answers');\n let questionContainer = document.getElementById('questions');\n\n let showAnswer = (answers) => {\n   answerContainer.innerHTML = \"\";\n   let x = 0;\n   for (; x < answers.length; x++) {\n     let li = document.createElement('li');\n     li.appendChild(document.createTextNode(answers[x]));\n     answerContainer.appendChild(li);\n   }\n }\n\n let showQuestion = (questions) => {\n   questionContainer.innerHTML = \"\";\n   for (let q in questions) {\n     //... show questions, similar to #showAnswer\n   }\n }\n\n evSource.addEventListener('message', (broadcast) => {\n   let data = JSON.parse(broadcast.data);\n   switch (data.type) {\n     case \"questions\":\n       showQuestion(data.questions);\n     break;\n     case \"answers\":\n       showAnswer(data.answers);\n     break;\n     case \"notification\":\n       alert(data.message);\n     break;\n     default:\n       throw \"Received unknown message type\";\n     break;\n   }\n });\n\n evSource.addEventListener('login', (broadcast) => {\n   USER_ID = JSON.parse(broadcast.data);\n });\n\n```", "```js\nnpm i\nnpm run build\nnpm start\n// Now navigate to localhost:8080 and start editing.\n// Open another browser to localhost:8080 to see collaboration in action!\n```", "```js\nconst sharedb = require('sharedb/lib/client');\nconst richText = require('rich-text');\nconst Quill = require('quill');\n\nsharedb.types.register(richText.type);\n\nconst socket = new WebSocket('ws://' + window.location.host);\nconst connection = new sharedb.Connection(socket);\n\nwindow.disconnect = () => connection.close();\nwindow.connect = () => connection.bindToSocket(new WebSocket('ws://' + window.location.host));\n\n// 0: Name of collection\n// 1: ID of document\nlet doc = connection.get('examples', 'richtext');\n\ndoc.subscribe(err => {\n  if(err) {\n    throw err;\n  }\n  let quill = new Quill('#editor', {\n    theme: 'snow'\n  });\n  quill.setContents(doc.data);\n  // ... explained below\n});\n```", "```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  ...\n  <link href=\"quill.snow.css\" rel=\"stylesheet\">\n</head>\n<body>\n  <div id=\"editor\"></div>\n  <script src=\"img/bundle.js\"></script>\n</body>\n</html>\n```", "```js\ndoc.subscribe(err => {\n  ...\n  quill.setContents(doc.data);\n  quill.on('text-change', (delta, oldDelta, source) => {\n   ...\n   doc.submitOp(delta, {\n     source: quill\n   });\n  });\n  doc.on('op', (op, source) => {\n    ...\n    quill.updateContents(op);\n  });\n}\n```", "```js\nconst http = require('http');\nconst express = require('express');\nconst ShareDB = require('sharedb');\nconst richText = require('rich-text');\nconst WebSocket = require('ws');\nconst WebSocketJSONStream = require('websocket-json-stream');\n\nShareDB.types.register(richText.type);\n\nconst app = express();\napp.use(express.static('static'));\napp.use(express.static('node_modules/quill/dist'));\n\nconst backend = new ShareDB();\nconst connection = backend.connect();\n\n// 0: Name of collection\n// 1: ID of document\nlet doc = connection.get('examples', 'richtext');\n\ndoc.fetch(err => {\n  if (err) {\n    throw err;\n  }\n  if (doc.type === null) {\n    return doc.create([\n      {insert: 'Say Something!'}\n    ], 'rich-text', startServer);\n  }\n  startServer();\n});\n\nfunction startServer() {\n  const server = http.createServer(app);\n  const wss = new WebSocket.Server({server: server});\n  wss.on('connection', (ws, req) => {\n    backend.listen(new WebSocketJSONStream(ws));\n  });\n  server.listen(8080, () => console.log('Editor now live on http://localhost:8080'));\n}\n```", "```js\nbackend.listen(new WebSocketJSONStream(ws))\n```"]