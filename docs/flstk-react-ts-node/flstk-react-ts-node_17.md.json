["```ts\n    npm install \n    ```", "```ts\n    typeorm. pg is the client to communicate with Postgres. bcryptjs is an encryption library that we will use to encrypt our passwords before inserting into the database. cors is needed to allow us to receive client-side requests from a different domain, other than our server's domain. In modern apps, it's possible the client-side code is not being served from the same server as the server-side code. This is especially true when we are creating an API such as GraphQL, which may be used by multiple clients. You'll also see this when we start integrating our client's React app with the server, as they will run on different ports.`class-validator` is a dependency for assigning decorators for validation. We'll discuss this in more detail later with the help of examples.\n    ```", "```ts\n    PG_HOST=localhost\n    ```", "```ts\n    PG_PORT=5432\n    ```", "```ts\n    PG_ACCOUNT=superforumsvc\n    ```", "```ts\n    PG_PASSWORD=<your-password>\n    ```", "```ts\n    PG_DATABASE=SuperForum\n    ```", "```ts\n    PG_SYNCHRONIZE=true\n    ```", "```ts\n    PG_ENTITIES=\"src/repo/**/*.*\"\n    ```", "```ts\n    PG_ENTITIES_DIR=\"src/repo\"\n    ```", "```ts\n    PG_LOGGING=false\n    ```", "```ts\n    require(\"dotenv\").config();\n    ```", "```ts\n    module.exports = [\n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0type: \"postgres\",\n    ```", "```ts\n    \u00a0\u00a0\u00a0\u00a0host: process.env.PG_HOST,\n    \u00a0\u00a0\u00a0\u00a0port: process.env.PG_PORT,\n    \u00a0\u00a0\u00a0\u00a0username: process.env.PG_ACCOUNT,\n    \u00a0\u00a0\u00a0\u00a0password: process.env.PG_PASSWORD,\n    \u00a0\u00a0\u00a0\u00a0database: process.env.PG_DATABASE,\n    \u00a0\u00a0\u00a0\u00a0synchronize: process.env.PG_SYNCHRONIZE,\n    \u00a0\u00a0\u00a0\u00a0logging: process.env.PG_LOGGING,\n    \u00a0\u00a0\u00a0\u00a0entities: [process.env.PG_ENTITIES],\n    \u00a0\u00a0\u00a0\u00a0cli: {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0entitiesDir: process.env.PG_ENTITIES_DIR\n    \u00a0\u00a0\u00a0\u00a0},\n    \u00a0\u00a0}\n    ];\n    ```", "```ts\n    import { Entity, PrimaryGeneratedColumn, Column } from \"typeorm\";\n    ```", "```ts\n    import { Length } from \"class-validator\";\n    ```", "```ts\n    @Entity({ name: \"Users\" })\n    ```", "```ts\n    export class User {\n    \u00a0\u00a0@PrimaryGeneratedColumn({ name: \"id\", type: \"bigint\" })\n    \u00a0\u00a0id: string;\n    ```", "```ts\n    \u00a0\u00a0@Column(\"varchar\", {\n    \u00a0\u00a0\u00a0\u00a0name: \"Email\",\n    \u00a0\u00a0\u00a0\u00a0length: 120,\n    \u00a0\u00a0\u00a0\u00a0unique: true,\n    \u00a0\u00a0\u00a0\u00a0nullable: false,\n    \u00a0\u00a0})\n    \u00a0\u00a0email: string;\n    ```", "```ts\n    \u00a0\u00a0@Column(\"varchar\", {\n    \u00a0\u00a0\u00a0\u00a0name: \"UserName\",\n    \u00a0\u00a0\u00a0\u00a0length: 60,\n    \u00a0\u00a0\u00a0\u00a0unique: true,\n    \u00a0\u00a0\u00a0\u00a0nullable: false,\n    \u00a0\u00a0})\n    \u00a0\u00a0userName: string;\n    \u00a0\u00a0@Column(\"varchar\", { name: \"Password\", length: 100,\u00a0\u00a0\u00a0nullable: false })\n    @Length(8, 100)\n    ```", "```ts\n    \u00a0\u00a0password: string;\n    ```", "```ts\n    \u00a0\u00a0@Column(\"boolean\", { name: \"Confirmed\", default: false, \n    \u00a0\u00a0\u00a0\u00a0nullable: false })\n    \u00a0\u00a0confirmed: boolean;\n    ```", "```ts\n    \u00a0\u00a0@Column(\"boolean\", { name: \"IsDisabled\", default: \u00a0\u00a0\u00a0\u00a0false, nullable: false }) \n    \u00a0\u00a0isDisabled: boolean;\n    }\n    ```", "```ts\n    import express from \"express\";\n    import session from \"express-session\";\n    import connectRedis from \"connect-redis\";\n    import Redis from \"ioredis\";\n    import { createConnection } from \"typeorm\";\n    require(\"dotenv\").config();\n    ```", "```ts\n    const main = async () => {\n    \u00a0\u00a0const app = express();\n    \u00a0\u00a0const router = express.Router();\n    await createConnection();\n    ```", "```ts\n    \u00a0\u00a0const redis = new Redis({\n    \u00a0\u00a0\u00a0\u00a0port: Number(process.env.REDIS_PORT),\n    \u00a0\u00a0\u00a0\u00a0host: process.env.REDIS_HOST,\n    \u00a0\u00a0\u00a0\u00a0password: process.env.REDIS_PASSWORD,\n    \u00a0\u00a0});\n    \u00a0\u00a0const RedisStore = connectRedis(session);\n    \u00a0\u00a0const redisStore = new RedisStore({\n    \u00a0\u00a0\u00a0\u00a0client: redis,\n    \u00a0\u00a0});\n    \u00a0\u00a0app.use(\n    \u00a0\u00a0\u00a0\u00a0session({\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0store: redisStore,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0name: process.env.COOKIE_NAME,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sameSite: \"Strict\",\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0secret: process.env.SESSION_SECRET,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0resave: false,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0saveUninitialized: false,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cookie: {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path: \"/\",\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0httpOnly: true,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0secure: false,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxAge: 1000 * 60 * 60 * 24,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\n    \u00a0\u00a0\u00a0\u00a0} as any)\n    );\n    ```", "```ts\n    \u00a0\u00a0app.use(router);\n    \u00a0\u00a0router.get(\"/\", (req, res, next) => {\n    \u00a0\u00a0\u00a0\u00a0if (!req.session!.userId) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0req.session!.userId = req.query.userid;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0console.log(\"Userid is set\");\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0req.session!.loadedCount = 0;\n    \u00a0\u00a0\u00a0\u00a0} else {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0req.session!.loadedCount = Number(req.session!.\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0loadedCount) + 1;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0res.send(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0`userId: ${req.session!.userId}, loadedCount: \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0${req.session!.loadedCount}`\n    \u00a0\u00a0\u00a0\u00a0);\n    \u00a0\u00a0});\n    \u00a0\u00a0app.listen({ port: process.env.SERVER_PORT }, () => {\n    \u00a0\u00a0\u00a0\u00a0console.log(`Server ready on port \n    \u00a0\u00a0\u00a0\u00a0\u00a0${process.env.SERVER_PORT}`);\n    \u00a0\u00a0});\n    };\n    main();\n    ```", "```ts\n    pgAdmin and go to the Users table with all of its columns created for us:![Figure 14.9 \u2013 New Users table\n    ](img/Figure_14.09_B15508.jpg)Figure 14.9 \u2013 New Users tableThis is such a huge time saver! Could you imagine if we had to create each of our tables manually ourselves? With all of their fields and constraints? This would take hours.Notice that our columns have the same settings as from our decorators. For example, our email has a variety of characters, with a length of 120, and is not nullable. \n    ```", "```ts\n    import { Entity, PrimaryGeneratedColumn, Column } from \"typeorm\";\n    import { Length } from \"class-validator\";\n    ```", "```ts\n    @Entity({ name: \"Threads\" })\n    export class Thread {\n    \u00a0\u00a0@PrimaryGeneratedColumn({ name: \"Id\", type: \"bigint\" })\n    \u00a0\u00a0id: string;\n    \u00a0\u00a0@Column(\"int\", { name: \"Views\", default: 0, nullable: \u00a0\u00a0\u00a0false })\n    \u00a0\u00a0views: number;\n    \u00a0\u00a0@Column(\"boolean\", { name: \"IsDisabled\", default: \u00a0\u00a0\u00a0\u00a0false, nullable: false }) \n    \u00a0\u00a0isDisabled: boolean;\n    \u00a0\u00a0@Column(\"varchar\", { name: \"Title\", length: 150, \u00a0\u00a0\u00a0nullable: false })\n    \u00a0\u00a0@Length(5, 150)\n    \u00a0\u00a0title: string;\n    \u00a0\u00a0@Column(\"varchar\", { name: \"Body\", length: 2500, \u00a0\u00a0\u00a0nullable: true\n    \u00a0\u00a0\u00a0})\n    \u00a0\u00a0@Length(10, 2500)\n    \u00a0\u00a0body: string;\n    }\n    ```", "```ts\n    @Entity({ name: \"ThreadItems\" })\n    export class ThreadItem {\n    \u00a0\u00a0@PrimaryGeneratedColumn({ name: \"Id\", type: \"bigint\" })\n    \u00a0\u00a0id: string;\n    \u00a0\u00a0@Column(\"int\", { name: \"Views\", default: 0, nullable:\u00a0\u00a0\u00a0false })\n    \u00a0\u00a0views: number;\n    \u00a0\u00a0@Column(\"boolean\", { name: \"IsDisabled\", default: \u00a0\u00a0\u00a0false, nullable: false })\n    \u00a0\u00a0isDisabled: boolean;\n    \u00a0\u00a0@Column(\"varchar\", { name: \"Body\", length: 2500, \u00a0\u00a0\u00a0nullable: true\n    \u00a0\u00a0\u00a0})\n    \u00a0\u00a0@Length(10, 2500)\n    \u00a0\u00a0body: string;\n    }\n    ```", "```ts\n    @OneToMany(() => Thread, (thread) => thread.user)\n    \u00a0\u00a0threads: Thread[];\n    ```", "```ts\n    @ManyToOne(\n    \u00a0\u00a0\u00a0\u00a0() => User,\n    \u00a0\u00a0\u00a0\u00a0(user:User) => user.threads\n    \u00a0\u00a0)\n    \u00a0\u00a0user: User;\n    ```", "```ts\n    @OneToMany(\n    \u00a0\u00a0\u00a0\u00a0() => ThreadItem,\n    \u00a0\u00a0\u00a0\u00a0threadItems => threadItems.thread\n    \u00a0\u00a0)\n    \u00a0\u00a0threadItems: ThreadItem[];\n    ```", "```ts\n    @ManyToOne(() => User, (user) => user.threads)\n    \u00a0\u00a0user: User;\n    ```", "```ts\n    \u00a0\u00a0@ManyToOne(() => Thread, (thread) => thread.\u00a0\u00a0\u00a0threadItems)\n    \u00a0\u00a0thread: Thread;\n    ```", "```ts\n    @Entity({ name: \"ThreadPoints\" })\n    export class ThreadPoint {\n    \u00a0\u00a0@PrimaryGeneratedColumn({ name: \"Id\", type: \"bigint\" }) \n    \u00a0\u00a0\u00a0\u00a0// for typeorm\n    \u00a0\u00a0id: string;\n    \u00a0\u00a0@Column(\"boolean\", { name: \"IsDecrement\", default: \u00a0\u00a0\u00a0false, nullable: false })\n    \u00a0\u00a0isDecrement: boolean;\n    \u00a0\u00a0@ManyToOne(() => User, (user) => user.threadPoints)\n    \u00a0\u00a0user: User;\n    \u00a0\u00a0@ManyToOne(() => Thread, (thread) => thread.\u00a0\u00a0\u00a0threadPoints)\n    \u00a0\u00a0thread: Thread;\n    }\n    ```", "```ts\n    @OneToMany(() => ThreadPoint, (threadPoint) => threadPoint.user)\n    \u00a0\u00a0threadPoints: ThreadPoint[];\n    ```", "```ts\n    @OneToMany(() => ThreadPoint, (threadPoint) => \n     threadPoint.thread)\n    \u00a0\u00a0threadPoints: ThreadPoint[];\n    ```", "```ts\n    @Entity({ name: \"ThreadItemPoints\" })\n    export class ThreadItemPoint {\n    \u00a0\u00a0@PrimaryGeneratedColumn({ name: \"Id\", type: \"bigint\" }) \n    \u00a0\u00a0\u00a0\u00a0// for typeorm\n    \u00a0\u00a0id: string;\n    \u00a0\u00a0@Column(\"boolean\", { name: \"IsDecrement\", default: \u00a0\u00a0false,\n    \u00a0\u00a0\u00a0nullable: false })\n    \u00a0\u00a0isDecrement: boolean;\n    \u00a0\u00a0@ManyToOne(() => User, (user) => user.threadPoints)\n    \u00a0\u00a0user: User;\n    \u00a0\u00a0@ManyToOne(() => ThreadItem, (threadItem) => \n    \u00a0\u00a0\u00a0\u00a0threadItem.threadItemPoints)\n    \u00a0\u00a0threadItem: ThreadItem;\n    }\n    ```", "```ts\n    @OneToMany(() => ThreadItemPoint, (threadItemPoint) => \n     threadItemPoint.user)\n    \u00a0\u00a0threadItemPoints: ThreadItemPoint[];\n    ```", "```ts\n    @OneToMany(\n    \u00a0\u00a0\u00a0\u00a0() => ThreadItemPoint,\n    \u00a0\u00a0\u00a0\u00a0(threadItemPoint) => threadItemPoint.threadItem\n    \u00a0\u00a0)\n    \u00a0\u00a0threadItemPoints: ThreadItemPoint[];\n    ```", "```ts\n    @Entity({ name: \"ThreadCategories\" })\n    export class ThreadCategory {\n    \u00a0\u00a0@PrimaryGeneratedColumn({ name: \"Id\", type: \"bigint\" }) \n    \u00a0\u00a0\u00a0\u00a0// for typeorm\n    \u00a0\u00a0id: string;\n    \u00a0\u00a0@Column(\"varchar\", {\n    \u00a0\u00a0\u00a0\u00a0name: \"Name\",\n    \u00a0\u00a0\u00a0\u00a0length: 100,\n    \u00a0\u00a0\u00a0\u00a0unique: true,\n    \u00a0\u00a0\u00a0\u00a0nullable: false,\n    \u00a0\u00a0})\n    \u00a0\u00a0name: string;\n    \u00a0\u00a0@Column(\"varchar\", {\n    \u00a0\u00a0\u00a0\u00a0name: \"Description\",\n    \u00a0\u00a0\u00a0\u00a0length: 150,\n    \u00a0\u00a0\u00a0\u00a0nullable: true,\n    \u00a0\u00a0})\n    \u00a0\u00a0description: string;\n    \u00a0\u00a0@OneToMany(() => Thread, (thread) => thread.category)\n    \u00a0\u00a0threads: Thread[];\n    }\n    ```", "```ts\n    @ManyToOne(() => ThreadCategory, (threadCategory) => \n    \u00a0\u00a0threadCategory.threads)\n    \u00a0\u00a0category: ThreadCategory;\n    ```", "```ts\n    import { Column, BaseEntity } from \"typeorm\";\n    export class Auditable extends BaseEntity {\n    \u00a0\u00a0@Column(\"varchar\", {\n    \u00a0\u00a0\u00a0\u00a0name: \"CreatedBy\",\n    \u00a0\u00a0\u00a0\u00a0length: 60,\n    \u00a0\u00a0\u00a0\u00a0default: () => `getpgusername()`,\n    \u00a0\u00a0\u00a0\u00a0nullable: false,\n    \u00a0\u00a0})\n    \u00a0\u00a0createdBy: string;\n    ```", "```ts\n    \u00a0\u00a0@Column(\"timestamp with time zone\", {\n    \u00a0\u00a0\u00a0\u00a0name: \"CreatedOn\",\n    \u00a0\u00a0\u00a0\u00a0default: () => `now()`,\n    \u00a0\u00a0\u00a0\u00a0nullable: false,\n    \u00a0\u00a0})\n    \u00a0\u00a0createdOn: Date;\n    ```", "```ts\n    \u00a0\u00a0@Column(\"varchar\", {\n    \u00a0\u00a0\u00a0\u00a0name: \"LastModifiedBy\",\n    \u00a0\u00a0\u00a0\u00a0length: 60,\n    \u00a0\u00a0\u00a0\u00a0default: () => `getpgusername()`,\n    \u00a0\u00a0\u00a0\u00a0nullable: false,\n    \u00a0\u00a0})\n    \u00a0\u00a0lastModifiedBy: string;\n    \u00a0\u00a0@Column(\"timestamp with time zone\", {\n    \u00a0\u00a0\u00a0\u00a0name: \"LastModifiedOn\",\n    \u00a0\u00a0\u00a0\u00a0default: () => `now()`,\n    \u00a0\u00a0\u00a0\u00a0nullable: false,\n    \u00a0\u00a0})\n    \u00a0\u00a0lastModifiedOn: Date;\n    }\n    ```", "```ts\n    export class User extends Auditable {\n    ```", "```ts\n    export const isEmailValid = (email: string) => {\n    if (!email) return \"Email cannot be empty\";\n    ```", "```ts\n    \u00a0\u00a0if (!email.includes(\"@\")) {\n    \u00a0\u00a0\u00a0\u00a0return \"Please enter valid email address.\";\n    ```", "```ts\n    \u00a0\u00a0}\n    \u00a0\u00a0if (/\\s+/g.test(email)) {\n    \u00a0\u00a0\u00a0\u00a0return \"Email cannot have whitespaces\";\n    ```", "```ts\n    \u00a0\u00a0}\n    \u00a0\u00a0return \"\";\n    };\n    ```", "```ts\n    import { User } from \"./User\";\n    import bcrypt from \"bcryptjs\";\n    import { isPasswordValid } from \"../common/validators/PasswordValidator\";\n    import { isEmailValid } from \"../common/validators/EmailValidator\";\n    ```", "```ts\n    const saltRounds = 10;\n    ```", "```ts\n    export class UserResult {\n    \u00a0\u00a0constructor(public messages?: Array<string>, public \u00a0\u00a0\u00a0user?:\n    \u00a0\u00a0\u00a0User) {}\n    }\n    ```", "```ts\n    export const register = async (\n    \u00a0\u00a0email: string,\n    \u00a0\u00a0userName: string,\n    \u00a0\u00a0password: string\n    ): Promise<UserResult> => {\n    ```", "```ts\n    \u00a0\u00a0const result = isPasswordValid(password);\n    \u00a0\u00a0if (!result.isValid) {\n    \u00a0\u00a0\u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0messages: [\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Passwords must have min length 8, 1 upper \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0character, 1 number, and 1 symbol\",\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0],\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0}\n    \u00a0\u00a0const trimmedEmail = email.trim().toLowerCase();\n    \u00a0\u00a0const emailErrorMsg = isEmailValid(trimmedEmail);\n    \u00a0\u00a0if (emailErrorMsg) {\n    \u00a0\u00a0\u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0messages: [emailErrorMsg],\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0}\n    ```", "```ts\n    \u00a0\u00a0const salt = await bcrypt.genSalt(saltRounds);\n    \u00a0\u00a0const hashedPassword = await bcrypt.hash(password, \u00a0\u00a0\u00a0salt);\n    ```", "```ts\n    \u00a0\u00a0const userEntity = await User.create({\n    \u00a0\u00a0\u00a0\u00a0email: trimmedEmail,\n    \u00a0\u00a0\u00a0\u00a0userName,\n    \u00a0\u00a0\u00a0\u00a0password: hashedPassword,\n    \u00a0\u00a0}).save();\n    ```", "```ts\n    \u00a0\u00a0userEntity.password = \"\"; // blank out for security\n    \u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0\u00a0user: userEntity\n    \u00a0\u00a0};\n    };\n    ```", "```ts\n    import express from \"express\";\n    import session from \"express-session\";\n    import connectRedis from \"connect-redis\";\n    import Redis from \"ioredis\";\n    import { createConnection } from \"typeorm\";\n    import { register } from \"./repo/UserRepo\";\n    import bodyParser from \"body-parser\";\n    ```", "```ts\n    require(\"dotenv\").config();\n    const main = async () => {\n    \u00a0\u00a0const app = express();\n    \u00a0\u00a0const router = express.Router();\n    \u00a0\u00a0await createConnection();\n    \u00a0\u00a0const redis = new Redis({\n    \u00a0\u00a0\u00a0\u00a0port: Number(process.env.REDIS_PORT),\n    \u00a0\u00a0\u00a0\u00a0host: process.env.REDIS_HOST,\n    \u00a0\u00a0\u00a0\u00a0password: process.env.REDIS_PASSWORD,\n    \u00a0\u00a0});\n    \u00a0\u00a0const RedisStore = connectRedis(session);\n    \u00a0\u00a0const redisStore = new RedisStore({\n    \u00a0\u00a0\u00a0\u00a0client: redis,\n    \u00a0\u00a0});\n    \u00a0\u00a0app.use(bodyParser.json());\t\n    ```", "```ts\n    \u00a0\u00a0app.use(\n    \u00a0\u00a0\u00a0\u00a0session({\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0store: redisStore,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0name: process.env.COOKIE_NAME,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sameSite: \"Strict\",\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0secret: process.env.SESSION_SECRET,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0resave: false,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0saveUninitialized: false,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cookie: {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0path: \"/\",\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0httpOnly: true,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0secure: false,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxAge: 1000 * 60 * 60 * 24,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\n    \u00a0\u00a0\u00a0\u00a0} as any)\n    \u00a0\u00a0);\n    ```", "```ts\n    \u00a0\u00a0app.use(router);\n    \u00a0\u00a0router.post(\"/register\", async (req, res, next) => {\n    \u00a0\u00a0\u00a0\u00a0try {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0console.log(\"params\", req.body);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const userResult = await register(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0req.body.email,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0req.body.userName,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0req.body.password\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (userResult && userResult.user) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res.send(`new user created, userId: ${userResult.\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0user.id}`);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else if (userResult && userResult.messages) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res.send(userResult.messages[0]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0next();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0} catch (ex) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res.send(ex.message);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0});\n    ```", "```ts\n    \u00a0\u00a0app.listen({ port: process.env.SERVER_PORT }, () => {\n    \u00a0\u00a0\u00a0\u00a0console.log(`Server ready on port\n    \u00a0\u00a0\u00a0\u00a0\u00a0${process.env.SERVER_PORT}`);\n    \u00a0\u00a0});\n    };\n    main();\n    ```", "```ts\n    export const login = async (\n    \u00a0\u00a0userName: string,\n    \u00a0\u00a0password: string\n    ): Promise<UserResult> => {\n    \u00a0\u00a0const user = await User.findOne({\n    \u00a0\u00a0\u00a0\u00a0where: { userName },\n    \u00a0\u00a0});\n    \u00a0\u00a0if (!user) {\n    \u00a0\u00a0\u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0messages: [userNotFound(userName)],\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0}\n    \u00a0\u00a0if (!user.confirmed) {\n    \u00a0\u00a0\u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0messages: [\"User has not confirmed their \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0registration email yet.\"],\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0}\n    \u00a0\u00a0const passwordMatch = await bcrypt.compare(password, \n    \u00a0\u00a0\u00a0\u00a0user?.password);\n    \u00a0\u00a0if (!passwordMatch) {\n    \u00a0\u00a0\u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0messages: [\"Password is invalid.\"],\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0}\n    \u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0user: user,\n    \u00a0\u00a0};\n    };\n    ```", "```ts\n    router.post(\"/login\", async (req, res, next) => {\n    \u00a0\u00a0\u00a0\u00a0try {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0console.log(\"params\", req.body);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const userResult = await login(req.body.userName, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0req.body.password);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (userResult && userResult.user) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0req.session!.userId = userResult.user?.id;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res.send(`user logged in, userId: \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0${req.session!.userId}`);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else if (userResult && userResult.messages) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res.send(userResult.messages[0]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0next();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0} catch (ex) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res.send(ex.message);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0});\n    ```", "```ts\n    export class QueryArrayResult<T> {\n    \u00a0\u00a0constructor(public messages?: Array<string>, public \u00a0\u00a0\u00a0entities?: Array<T>) {}\n    }\n    ```", "```ts\n    export const createThread = async (\n    \u00a0\u00a0userId: string,\n    \u00a0\u00a0categoryId: string,\n    \u00a0\u00a0title: string,\n    \u00a0\u00a0body: string\n    ): Promise<QueryArrayResult<Thread>> => {\n    ```", "```ts\n    \u00a0\u00a0const titleMsg = isThreadTitleValid(title);\n    \u00a0\u00a0if (titleMsg) {\n    \u00a0\u00a0\u00a0\u00a0return {\t\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0messages: [titleMsg],\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0}\n    \u00a0\u00a0const bodyMsg = isThreadBodyValid(body);\n    \u00a0\u00a0if (bodyMsg) {\n    \u00a0\u00a0\u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0messages: [bodyMsg],\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0}\n    ```", "```ts\n    \u00a0\u00a0// users must be logged in to post\n    \u00a0\u00a0const user = await User.findOne({\n    \u00a0\u00a0\u00a0\u00a0id: userId,\n    \u00a0\u00a0});\n    \u00a0\u00a0if (!user) {\n    \u00a0\u00a0\u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0messages: [\"User not logged in.\"],\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0}\n    ```", "```ts\n    \u00a0\u00a0const category = await ThreadCategory.findOne({\n    \u00a0\u00a0\u00a0\u00a0id: categoryId,\n    \u00a0\u00a0});\n    \u00a0\u00a0if (!category) {\n    \u00a0\u00a0\u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0messages: [\"category not found.\"],\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0}\n    ```", "```ts\n    \u00a0\u00a0const thread = await Thread.create({\n    \u00a0\u00a0\u00a0\u00a0title,\n    \u00a0\u00a0\u00a0\u00a0body,\n    \u00a0\u00a0\u00a0\u00a0user,\n    \u00a0\u00a0\u00a0\u00a0category,\n    \u00a0\u00a0}).save();\n    \u00a0\u00a0if (!thread) {\n    \u00a0\u00a0\u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0messages: [\"Failed to create thread.\"],\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0}\n    ```", "```ts\n    \u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0messages: [\"Thread created successfully.\"],\n    \u00a0\u00a0};\n    };\n    ```", "```ts\n    router.post(\"/createthread\", async (req, res, next) => {\n    \u00a0\u00a0\u00a0\u00a0try {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0console.log(\"userId\", req.session);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0console.log(\"body\", req.body);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const msg = await createThread(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0req.session!.userId, // notice this is from \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0session!\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0req.body.categoryId,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0req.body.title,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0req.body.body\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0);\n    ```", "```ts\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res.send(msg);\n    \u00a0\u00a0\u00a0\u00a0} catch (ex) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0console.log(ex);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res.send(ex.message);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0});\n    ```", "```ts\n    export const getThreadById = async (\n    \u00a0\u00a0id: string\n    ): Promise<QueryOneResult<Thread>> => {\n    \u00a0\u00a0const thread = await Thread.findOne({ id });\n    \u00a0\u00a0if (!thread) {\n    \u00a0\u00a0\u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0messages: [\"Thread not found.\"],\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0}\n    \u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0entity: thread,\n    \u00a0\u00a0};\n    };\n    ```", "```ts\n    export const getThreadsByCategoryId = async (\n    \u00a0\u00a0categoryId: string\n    ): Promise<QueryArrayResult<Thread>> => {\n    \u00a0\u00a0const threads = await Thread.\u00a0\u00a0\u00a0createQueryBuilder(\"thread\")\n    \u00a0\u00a0\u00a0\u00a0.where(`thread.\"categoryId\" = :categoryId`, { \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0categoryId })\n    \u00a0\u00a0\u00a0\u00a0.leftJoinAndSelect(\"thread.category\", \"category\")\n    \u00a0\u00a0\u00a0\u00a0.orderBy(\"thread.createdOn\", \"DESC\")\n    \u00a0\u00a0\u00a0\u00a0.getMany();\n    ```", "```ts\n    \u00a0\u00a0if (!threads) {\n    \u00a0\u00a0\u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0messages: [\"Threads of category not found.\"],\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0}\n    \u00a0\u00a0console.log(threads);\n    \u00a0\u00a0return {\n    \u00a0\u00a0\u00a0\u00a0entities: threads,\n    \u00a0\u00a0};\n    };\n    ```", "```ts\n    router.post(\"/threadbycategory\", async (req, res, next) => {\n    \u00a0\u00a0\u00a0\u00a0try {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const threadResult = await \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0getThreadsByCategoryId(req.body.categoryId);\n    ```", "```ts\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (threadResult && threadResult.entities) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0let items = \"\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0threadResult.entities.forEach((th) => {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0items += th.title + \", \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0});\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res.send(items);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else if (threadResult && threadResult.messages) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res.send(threadResult.messages[0]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    ```", "```ts\n    \u00a0\u00a0\u00a0\u00a0} catch (ex) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0console.log(ex);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res.send(ex.message);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0});\n    ```"]