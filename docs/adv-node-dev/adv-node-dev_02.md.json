["```js\nnpm install mongodb@3.0.2 --save\n```", "```js\nconst MongoClient = require('mongodb').MongoClient; \n```", "```js\nMongoClient.connect('mongodb://')\n```", "```js\nMongoClient.connect('mongodb://localhost:27017/TodoApp'); \n```", "```js\nMongoClient.connect('mongodb://localhost:27017/TodoApp', (err, client) => { \n\n});\n```", "```js\nMongoClient.connect('mongodb://localhost:27017/TodoApp', (err, client) => {\n  if(err){\n    console.log('Unable to connect to MongoDB server');\n  }\n  console.log('Connected to MongoDB server');\n});\n```", "```js\nif(err) { \n    return console.log('Unable to connect to MongoDB server'); \n  } \n```", "```js\nMongoClient.connect('mongodb://localhost:27017/TodoApp', (err, client) => {\n  if(err) { \n    return console.log('Unable to connect to MongoDB server'); \n  } \n  console.log('Connected to MongoDB server');\n  const db = client.db('TodoApp');\n  client.close(); \n}); \n```", "```js\nnode playground/mongodb-connect.js\n```", "```js\ndb.collection('Todos')\n```", "```js\nconst MongoClient = require('mongodb').MongoClient;\n\nMongoClient.connect('mongodb://localhost:27017/TodoApp', (err, client) => {\n  if(err){\n    console.log('Unable to connect to MongoDB server');\n  }\n  console.log('Connected to MongoDB server');\n  const db = client.db('TodoApp');\n  db.collection('Todos').insertOne({\n    text: 'Something to do',\n    completed: false\n  }, (err, result) => {\n\n  });\n  client.close();\n});\n```", "```js\ndb.collection('Todos').insertOne({ \n  text: 'Something to do', \n  completed: false \n}, (err, result) => { \n  if(err){ \n    return console.log('Unable to insert todo', err); \n  }\n```", "```js\ndb.collection('Todos').insertOne({ \n  text: 'Something to do', \n  completed: false \n}, (err, result) => { \n  if(err){ \n    return console.log('Unable to insert todo', err); \n  }\n\n  console.log(JSON.stringify(result.ops, undefined, 2)); \n}); \n```", "```js\nnode playground/ mongodb-connect.js\n```", "```js\n//Insert new doc into Users(name, age, location)\ndb.collection('Users')\n```", "```js\n//Insert new doc into Users(name, age, location)\ndb.collection('Users').insertOne({\n  name: 'Andrew',\n  age: 25,\n  location: 'Philadelphia'\n}\n```", "```js\n//Insert new doc into Users(name, age, location)\ndb.collection('Users').insertOne({\n  name: 'Andrew',\n  age: 25,\n  location: 'Philadelphia'\n}, (err, result) => {\n  if(err) {\n    return console.log('Unable to insert user', err);\n  }\n  console.log(result.ops);\n});\n```", "```js\nnode playground/mongodb-connect.js\n```", "```js\ndb.collection('Users').insertOne({\n  _id: 123,\n  name: 'Andrew',\n  age: 25,\n  location: 'Philadelphia'\n}\n```", "```js\ndb.collection('Users').insertOne({\n  name: 'Andrew',\n  age: 25,\n  location: 'Philadelphia'\n}, (err, result) => {\n  if(err) {\n    return console.log('Unable to insert user', err);\n  }\n\n  console.log(result.ops);\n});\n```", "```js\nconsole.log(result.ops[0]._id);\n```", "```js\nconsole.log(result.ops[0]._id.getTimestamp()); \n```", "```js\nconst MongoClient = require('mongodb').MongoClient;\n\nvar user = {name: 'andrew', age: 25};\n```", "```js\nvar user = {name: 'andrew', age: 25};\nvar {name} = user;\n```", "```js\nvar user = {name: 'andrew', age: 25};\nvar {name} = user;\nconsole.log(name);\n```", "```js\n// const MongoClient = require('mongodb').MongoClient;\nconst MongoClient = require('mongodb').MongoClient;\n```", "```js\nconst {MongoClient} = require('mongodb');\n```", "```js\nconst {MongoClient, ObjectID} = require('mongodb');\n```", "```js\nconst {MongoClient, ObjectID} = require('mongodb');\n\nvar obj = new ObjectID(); \n```", "```js\nconsole.log(obj); \n```", "```js\nvar obj = new ObjectID();\nconsole.log(obj);\n```", "```js\n{\n  text : \"Walk the dog\",\n  completed : false\n}\n```", "```js\ndb.collection('Todos').find();\n```", "```js\ndb.collection('Todos').find().toArray().then((docs) => {\n\n});\n```", "```js\ndb.collection('Todos').find().toArray().then((docs) => {\n\n}, (err) => { \n  console.log('Unable to fetch todos', err); \n}); \n```", "```js\n  db.collection('Todos').find().toArray().then((docs) => {\n    console.log('Todos');\n    console.log(JSON.stringify(docs, undefined, 2));\n  }, (err) => {\n    console.log('Unable to fetch todos', err);\n  });\n```", "```js\n//const MongoClient = require('mongodb').MongoClient;\nconst {MongoClient, ObjectID} = require('mongodb');\n\nMongoClient.connect('mongodb://localhost:27017/TodoApp', (err, client) => {\n  if(err){ \n    console.log('Unable to connect to MongoDB server');\n  } \n  console.log('Connected to MongoDB server');\n  const db = client.db('TodoApp');\n\n  db.collection('Todos').find().toArray().then((docs) => {\n    console.log('Todos');\n    console.log(JSON.stringify(docs, undefined, 2));\n  }, (err) => {\n    console.log('Unable to fetch todos', err);\n  });\n  //client.close();\n});\n```", "```js\nnode playground/mongodb-find.js\n```", "```js\ndb.collection('Todos').find({completed: false}).toArray().then((docs) => {\n```", "```js\ndb.collection('Todos').find({_id: ''}).toArray().then((docs) => {\n```", "```js\ndb.collection('Todos').find({\n  _id: '5a867e78c3a2d60bef433b06'\n}).toArray().then((docs) => {\n```", "```js\ndb.collection('Todos').find({\n  _id: new ObjectID('5a867e78c3a2d60bef433b06');\n})\n```", "```js\ndb.collection('Todos').find({}).count().then((count) => {\n```", "```js\ndb.collection('Todos').find({}).count().then((count) => {\n   console.log('Todos count:');\n}, (err) => {\n   console.log('Unable to fetch todos', err);\n});\n```", "```js. Now, I can pass in the `count`.\n\n```", "```js\n\nNow that we have this in place, we have a way to count up all of the Todos in the `Todos` collection. Inside the Terminal, I'm going to go ahead and shut down our previous script and rerun it:\n\n![](img/9fd9155b-32b9-4c22-9771-82a526d89065.png)\n\nWe get `Todos count` too, which is correct. The cursor that we have, a call to find, returns everything in the Todos collection. If you count all of that up, you're going to get those two Todo items.\n\nOnce again, these are `count` and `toArray`; they're just a subset of all of the awesome methods you have available to you. We will be using other methods, whether it be the MongoDB native driver or, as you'll see later, the library Mongoose, but for now let's go ahead and do a challenge, given what you know.\n\n# Querying users collection\n\nTo get started, let's head into Robomongo, open up the Users collection, and take a look at all the documents we have inside of there. We currently have five. If you don't have the exact same number or yours are a little different, that's fine. I'm going to highlight them, right-click them, and click Expand Recursively. This is going to show me all of the key-value pairs for each document:\n\n![](img/389ebd7e-0161-4c1b-a31d-bab563cc5621.png)\n\nCurrently, aside from the ID, they're all identical. The name's Andrew, the age is 25, and the location is Philadelphia. I'm going to tweak the name property for two of them. I'm going to right-click the first document, and change the name to something like `Jen`. Then, I'll go ahead and do the same thing for the second document. I'm going to edit that document and change the name from `Andrew` to `Mike`. Now I have one document with a name of `Jen`, one with `Mike`, and three with `Andrew`.\n\nWe're going to query our users, looking for all of the users with the name equal to the name that you provided in the script. In this case, I'm going to try to query for all documents in the `Users` collection where the name is `Andrew`. Then, I'm going to print them into the screen, and I will expect to get three back. The two with the names `Jen` and `Mike` should not show up.\n\nThe first thing we need to do is fetch from the collection. This is going to be the `Users` collection as opposed to the `Todos` collection we've used in this chapter. In the `db.collection`, we're looking for the `Users` collection and now we're going to go ahead and call `find`, passing in our query. We want a query, fetching all documents where the `name` is equal to the string `Andrew`.\n\n```", "```js\n\nThis is going to return the cursor. In order to actually get the documents, we have to call `toArray`. We now have a promise; we can attach a `then` call onto `toArray` to do something with the `docs`. The documents are going to come back as the first argument in our success handler, and right inside of the function itself we can print the docs to the screen. I'm going to go ahead and use `console.log(JSON.stringify())`, passing in our three classic arguments: the object itself, `docs`, `undefined`, and `2` for formatting:\n\n```", "```js\n\nWith this in place, we have now done. We have a query, and it should work. We can test it by running it from the Terminal. Inside the Terminal, I'm going to go ahead and shut down the previous connection and rerun the script:\n\n![](img/4fd344a9-de63-45ff-a7b0-fd5353c06e3b.png)\n\nWhen I do this, I get my three documents back. All of them have a `name` equal to `Andrew`, which is correct because of the query we set up. Notice the documents with a name equal to `Mike` or `Jen` are nowhere to be found.\n\nWe now know how to insert and query data from the database. Up next, we're going to take a look at how we can remove and update documents.\n\n# Setting up the repo\n\nBefore we go any further, I do want to add version control to this project. In this section, we're going to create a new repo locally, make a new GitHub repository, and push our code to that GitHub repository. If you're already familiar with Git or GitHub, you can go ahead and do that on your own; you don't need to go through this section. If you're new to Git and it doesn't make sense just yet, that's also fine. Simply follow along, and we'll go through the whole process.\n\nThis section is going to be really simple; nothing MongoDB- related here. To get started, I am going to go ahead and initialize a new Git repository from the Terminal by using `git init`. This is going to initialize a new repository, and I can always run `git status` like this to take a look at the files that are untracked:\n\n![](img/8c2070ea-2d27-43e3-b609-f3a4948be5bc.png)\n\nHere we have our `playground` folder, which we want to add under version control, and we have `package.json`. We also have `node_modules`. We do not want to track this directory. This contains all of our npm libraries. To ignore `node_modules`, in Atom we're going to make the `.gitignore` file in the root of our project. If you remember, this lets you specify files and folders that you want to leave out of your version control. I'm going to create a new file called `.gitignore`. In order to ignore the `node_modules` directory, all we have to do is type it exactly as it's shown here:\n\n```", "```js\n\nI'm going to save the file and rerun `git status` from the Terminal. We get the `.gitignore` folder showing up, and the `node_modules` folder is nowhere in sight:\n\n![](img/ce67bd02-10cd-4cf0-b6ba-6754e2b5a4aa.png)\n\nThe next thing we're going to do is make our first commit, using two commands. First up, I'm going to use `git add .` to add everything to the next commit. Then, I can make the commit using `git commit` with the `-m` flag. A good message for this commit would be `Init commit`:\n\n```", "```js\n\nNow before we go, I do want to make a GitHub repository and get this code up there. This is going to require me to open up the browser and go to [github.com](http://www.github.com). Once you're logged in we can make a new repo. I'm going to make a new repo and give it a name:\n\n![](img/e42875c4-0a3d-41cb-8ee9-f150f3c02dcf.png)\n\nI'm going to go with `node-course-2-todo-api`. You can name yours something else if you wish. I'm going to go with this one to keep the course files organized. Now I can go ahead and create this repository, and as you may recall, GitHub actually gives us a few helpful commands:\n\n![](img/77b896c2-0987-4c37-a6d7-7fe02ea00204.png)\n\nIn this case, we're pushing an existing repository from the command line. We already went through the steps of initializing the repository, adding our files and making our first commit. That means I can take the following two lines, copy them, head over to the Terminal, and paste them in:\n\n```", "```js\n\nYou might need to do these one at a time, depending on your operating system. On the Mac, when I try to paste in multiple commands it's going to run all but the last, and then I just have to hit enter to run the last one. Take a moment to knock that out for your operating system. You might need to run it as one command, or you might be able to paste it all in and hit *enter*. Either way, what we have here is our code pushed up to GitHub. I can prove that it's pushed up by refreshing the repository page:\n\n![](img/1bd89ea4-3f8b-4cb0-9ff0-194e62d0d9e0.png)\n\nRight there we have all of our source code, the `.gitignore` file, `package.json`, and we have our `playground` directory with our MongoDB scripts.\n\nThat's it for this section. We'll explore how to delete data from a MongoDB collection in the next section.\n\n# Deleting documents\n\nIn this section, you're going to learn how to delete documents from your MongoDB collections. Before we get into that, in order to explore the methods that let us delete multiple documents or just one, we want to create a few more Todos. Currently, the `Todos` collection only has two items, and we're going to need a few more in order to play around with all these methods involving deletion.\n\nNow, I do have two. I'm going to go ahead and create a third by right-clicking and then going to Insert Document.... We'll make a new document with a `text` property equal to something like `Eat lunch`, and we'll set `completed` equal to `false`:\n\n```", "```js\n\nNow before we save this, I am going to copy it to the clipboard. We're going to create a few duplicate Todos so we can see how we can delete items based off of specific criteria. In this case, we're going to be deleting multiple Todos with the same text value. I'm going to copy that to the clipboard, click Save, and then I'll create two more with the exact same structure. Now we have three Todos that are identical except for the ID, and we have two that have unique text properties:\n\n![](img/8fc55286-909e-408d-8951-e315c454287f.png)\n\nLet's go ahead and move into Atom and start writing some code.\n\n# Exploring methods to delete data\n\nI'm going to duplicate the `mongodb-find` file, creating a brand-new file called `mongodb-delete.js`. In here, we'll explore the methods for deleting data. I'm also going to remove all of the queries that we set up in the previous section. I am going to keep the `db.close` method commented out, as once again we don't want to close the connection just yet; it's going to interfere with these statements we're about to write.\n\nNow, there are three methods that we'll be using in order to remove data.\n\n*   The first one is going to be `deleteMany`. The `deleteMany` method will let us target many documents and remove them.\n*   We'll also be using `deleteOne`, which targets one document and removes it.\n*   And finally, we'll be using `findOneAndDelete`. The `findOneAndDelete` method lets you remove an individual item and it also returns those values. Imagine I want to delete a Todo. I delete the Todo, but I also get the Todo object back so I can tell the user exactly which one got deleted. This is a really useful method.\n\n# The deleteMany method\n\nNow, we're going to start off with `deleteMany`, and we're going to target those duplicates we just created. The goal in this section, is to delete every single Todo inside of the Todos collection that has a `text` property equal to `Eat lunch`. Currently, there are three out of five that fit that criteria.\n\nIn Atom, we can go ahead and kick things off by doing `db.collection`. This is going to let us target our Todos collection. Now, we can go ahead and use the collection method `deleteMany`, passing in the arguments. In this case, the only argument we need is our object, and this object is just like the object we passed to find. With this, we can target our Todos. In this case, we're going to delete every Todo where the `text` equals `Eat lunch`.\n\n```", "```js\n\nWe didn't use any punctuation in RoboMongo, so we're also going to avoid punctuation over in Atom; it needs to be exactly the same.\n\nNow that we have this in place, we could go ahead and tack on a `then` call to do something when it either succeeds or fails. For now, we'll just add a success case. We are going to get a result argument passed back to the callback, and we can print that to the `console.log(result)` screen, and we'll take a look at exactly what is in this result object a bit later.\n\n```", "```js\n\nWith this in place, we now have a script that deletes all Todos where the text value is `Eat lunch`. Let's go ahead and run it, and see exactly what happens. In the Terminal, I'm going to run this file. It's in the `playground` folder, and we just called it `mongodb-delete.js`:\n\n```", "```js\n\nNow when I run it, we get a lot of output:\n\n![](img/7744c074-3a75-4b6b-8dc0-2d5f890da471.png)\n\nA really important piece of output, the only important piece actually, is up at the very top. If you scroll to the top, what you're going to see is this `result` object. We get `ok` set to `1`, which means things did go as expected, and we get `n` set to `3`. `n` is the number of records that were deleted. In this case, we had three Todos that match that criteria, so three Todos were deleted. This is how you can target and delete many Todos.\n\n# The deleteOne Method\n\nNow, aside from `deleteMany`, we have `deleteOne`, and `deleteOne` works exactly the same as `deleteMany`, only it deletes the first item it sees that matches the criteria and then it stops.\n\nTo illustrate exactly how this works, we're going to create two items inside of our collection. If I give things a refresh, you will see that we now only have two documents:\n\n![](img/9a571ad9-8625-46c8-813d-118afc431db6.png)\n\nThese are the ones we started with. I'm going to insert documents again using the same data that's already in my clipboard. This time we'll just make two document, two that are identical.\n\n# The deleteOne method\n\nThe goal here is to use `deleteOne` to delete the document where the text equals `Eat lunch`, but since we're using `deleteOne` and not `deleteMany`, one of these should stay around and one of them should go away.\n\nBack inside of Atom, we can go ahead and get started by calling `db.collection` with the collection name we want to target. In this case it's `Todos` again, and we're going to use `deleteOne`. The `deleteOne` method takes that same criteria. We're going to target documents where `text` equals `Eat lunch`.\n\nThis time though, instead of deleting multiple documents we're just going to delete the one, and we are still going to get that same exact result. To prove it, I'll just print to the screen like we did previously with `console.log(result)`:\n\n```", "```js\n\nWith this in place, we can now rerun our script and see what happens. In the Terminal, I'm going to shut down our current connection and rerun it:\n\n![](img/30033a3b-581d-4d26-9540-f20270b17f0a.png)\n\nWe get a similar-looking object, a bunch of junk we don't really care about, but once again if we scroll to the top we have a `result` object, where `ok` is `1` and the number of deleted documents is also `1`. Even though multiple documents did pass this criteria it only deleted the first one, and we can prove that by going over to Robomongo, right-clicking up above, and viewing the documents again. This time around, we have three Todos.\n\nWe do still have one of the Todos with the `Eat lunch` text:\n\n![](img/d13d8b43-2602-4ce3-9343-ca45bc01c592.png)\n\nAnd now that we know how to use these two methods, I want to take a look at my favorite method. This is `findOneAndDelete`.\n\n# The findOneAndDelete method\n\nMost of the time, when I'm deleting a document, I only have the ID. This means that I don't exactly know what the text is or the completed status, and that can be really useful depending on your user interface. For example, if I delete a Todo, maybe I want to show that next, saying *You deleted the Todo that says Eat lunch*, with a little undo button in case they didn't mean to take that action. Getting the data back as well as deleting it can be really useful.\n\nIn order to explore `findOneAndDelete`, we're going to once again target the Todo where the `text` equals `Eat lunch`. I'm going to go ahead and comment out `deleteOne`, and next we can get started by accessing the appropriate collection. The method is called `findOneAndDelete`. The `findOneAndDelete` method takes a very similar set of arguments. The only thing we need to pass in is the query. This is going to be identical to the ones we have in the previous screenshot. This time though, let's go ahead and target Todos that had a `completed` value set to `false`.\n\nNow there are two Todos that fit this query, but once again we're using a `findOne` method, which means it's only going to target the first one it sees, the one with a `text` property of `Something to do`. Back in Atom, we can get this done by targeting Todos where `completed` equals `false`. Now, instead of getting back a result object with an `ok` property and an `n` property, the `findOneAndDelete` method actually gets that document back. This means we can tack on a `then` call, we can get our result, and we can print it to the screen once again with `console.log(result)`:\n\n```", "```js\n\nNow that we have this in place, let's test things out over in the Terminal. In the Terminal, I'm going to shut down the script and start it up again:\n\n![](img/c21e6884-fda6-41aa-aa79-316cdfcf9085.png)\n\nWe get a few different things in our result object. We do get an `ok` set to `1`, letting us know things went as planned. We have a `lastErrorObject`; we'll talk about that in just a second; and we have our `value` object. This is the actual document we deleted. This is why the `findOneAndDelete` method is super handy. It gets that document back as well as deleting it.\n\nNow in this particular case, the `lastErrorObject`, once again just has our `n` property, and we can see the number of Todos that were deleted. There is other information that could potentially be in `lastErrorObject`, but that's only going to happen when we use other methods, so we'll look at that when the time comes. For now, when you delete a Todo, we just get the number back.\n\nWith this in place, we now have three different ways we can target our MongoDB documents and remove them.\n\n# Using the deleteMany and findOneAndDelete methods\n\nWe're going to go ahead and go over a quick challenge to test your skills. Inside of Robomongo, we can look at the data we have in the `Users` collection. I'm going to open it up, highlight all the data, and expand it recursively so we can view it:\n\n![](img/93f0f8e8-ab68-4b27-a89e-83c04cd39268.png)\n\nWe have the name Jen; we have Mike; we have Andrew, Andrew and Andrew. This is perfect data. Yours might look a little different, but the goal is to use two methods. First up, look for any duplicates, anything that has a name set to the name of another document. In this case, I have three documents where the name is Andrew. What I want to do is use `deleteMany` to target all of these documents and remove them. I also want to use `findOneAndDelete` to delete another document; it doesn't matter which one. And I want you to delete it by ID.\n\nIn the end, both statements should show their effect over inside of Robomongo. When I'm done, I'm hoping to see these three documents deleted. They all have the name Andrew, and I'm hoping to see the document where the name Mike is deleted, because I'm going to target this one by ID in my `findOneAndDelete` method call.\n\nFirst up, I'm going to write my scripts, one for deleting users where the name is `Andrew` and one for deleting the document with the ID. In order to grab the ID, I am going to go ahead and edit it and simply grab the text inside of quotes, and then I can cancel the update and move into Atom.\n\n# Removing duplicate documents\n\nFirst up, we're going to go ahead and try to remove the duplicate users, and I'm going to do this by using `db.collection`. We're going to target the `Users` collection, and in this particular case, we're going to be using the `deleteMany` method. Here, we're going to try to delete all of the users where the `name` property equals `Andrew`.\n\n```", "```js\n\nNow I could tack on a then call to check for success or errors, or I could just leave it like this, which is what I'm going to do. If you use a callback or the promise then method, that is perfectly fine. As long as the deletion happens, you're good to go.\n\n# Targeting the documents using ID\n\nNext up, I'm going to write the other statement. We're going to target the `Users` collection once again. Now, we're going to go ahead and use the `findOneAndDelete` method. In this particular case, I am going to be deleting the Todo where the `_id` equals the ObjectId I have copied to the clipboard, which means I need to create a `new ObjectID`, and I also need to go ahead and pass in the value from the clipboard inside of quotes.\n\n```", "```js\n\nEither single or double would work. Make sure the capitalization of `ObjectID` is identical to what you have defined, otherwise this creation will not happen.\n\nNow that we have the ID created and passed in as the `_id` property, we can go ahead and tack on a `then` callback. Since I'm using `findOneAndDelete`, I am going to print that document to the screen. Right here I'll get my argument, `results`, and I'm going to print it to the screen using our pretty- printing method,`console.log(JSON.stringify())`, passing in those three arguments, the `results`, `undefined`, and the spacing, which I'm going to use as `2`.\n\n```", "```js\n\nWith this in place, we are now ready to go.\n\n# Running the findOneAndDelete and deleteMany statements\n\nLet's go ahead and comment out\u00a0`findOneAndDelete` first. We'll run the `deleteMany` statement. Over in the Terminal, I can shut down the current connection, start it up again, and if we go over to Robomongo, we should see that those three documents were deleted. I'm going to right-click on `Users`\u00a0and view the documents:\n\n![](img/f0a3f3dc-cabf-4503-bc29-7152fe580144.png)\n\nWe just get the two documents back. Anything where the name was `Andrew` is now removed, which means our statement worked as expected, and this is fantastic.\n\nNext up, we can run our `findOneAndDelete` statement. In this case, we're expecting that that one document, the one where the\u00a0`name` equals `Mike`, gets removed. I'm going to go ahead and make sure I save the file. Once I do, I can move into the Terminal and rerun the script. This time around, we get the document back where the\u00a0`name` is `Mike`. We did target the correct one, and it does appear that one item was deleted:\n\n![](img/b3fb5a61-5cdd-45ea-85fc-52ebca362ae0.png)\n\nI can always go ahead and verify this by refreshing the collection inside of Robomongo:\n\n![](img/84ba63a2-1cd9-48ff-90df-833865eb2282.png)\n\nI get my collection with just one document inside of it. We are now done. We know how to delete documents from our MongoDB collections; we can delete multiple documents; we can target just one, or we can target one and get its value back.\n\n# Making commit for the deleting documents methods\n\nBefore we go, let's go ahead and make a commit, pushing it up to GitHub. In the Terminal, I can shut down the script and I can run `git status` to see what files we have untracked. Here, we have our `mongodb-delete` file. I can add it using `git add .`\u00a0and then I can commit, using `git commit` with the `-m` flag. Here, I can go ahead and provide a commit message, which is going to be\u00a0`Add delete script`:\n\n```", "```js\n\nI'm going to make that commit and I am going to push it up to GitHub using `git push`, which will default to the origin remote. When you only have one remote, the first one is going to be called origin. This is the default name, just like master is the default branch. With this in place, we are now done. Our code is up on GitHub. The topic of the next section is updating, which is where you're going to learn how to update documents inside of a collection.\n\n# Updating data\n\nYou know how to insert, delete, and fetch documents out of MongoDB. In this section, you're going to learn how to update documents in your MongoDB collections. To kick things off, as usual, we're going to duplicate the last script we wrote, and we'll update it for this section.\n\nI'm going to duplicate the `mongodb-delete` file, renaming it to `mongodb-update.js`, and this is where we'll write our update statements. I'm also going to delete all of the statements we wrote, which is the deleted data. Now that we have this in place, we can explore the one method we'll be looking at in this section. This one is called `findOneAndUpdate`. It's kind of similar to `findOneAndDelete`. It lets us update an item and get the new document back. So if I update a Todo, set it as\u00a0`completed` equal to `true`, I will get that document back in the response. Now in order to get started, we're going to be updating one of the items that we have inside of our Todos collection. If I view the documents, we currently have two. The goal here is going to be to update the second item, the one where `text` equals `Eat lunch`. We're going to try to set the `completed` value to `true`, which would be a pretty common action.\n\nIf I check off a Todo item, we want to toggle that completed Boolean value. Back inside of Atom, we're going to kick things off by accessing the appropriate collection. That'll be `db.collection`. The collection name is `Todos`, and the method we'll be using is `findOneAndUpdate`. Now, `findOneAndUpdate` is going to take the most arguments we've used so far, so let's go ahead and look up the documentation for it for future reference.\n\nOver inside of Chrome, we currently have the Cursor tab open. This is where we have the `count` method defined. If we scroll next the Cursor tab, we have our other tabs. The one we're looking for is `Collection`. Now, inside of the Collection section, we have our typedefs and our methods. We're looking at methods here, so if I scroll down, we should be able to find `findOneAndUpdate` and click it. Now, `findOneAndUpdate` takes quite a few arguments. The first one is the `filter`. The `update` argument lets us target the document we want to update. Maybe we have the text, or most likely we have the ID of the document. Next up is the actual updates we want to make. We don't want to update the ID, we just want to filter by ID. In this case, the updates are going to be updating the completed Boolean. Then we have some options, which we are going to define. We'll use just one of them. We also have our `callback`. We're going to leave off the callback as we've been doing so so far, in favor of promises. As you can see on the documentation page, it returns a promise if no callback is passed in, and that's exactly what we expect. Let's go ahead and start filling out the appropriate arguments for `findOneAndUpdate`, kicking things off with the\u00a0`filter`. What I'm going to do is filter by ID. In Robomongo, I can grab the ID of this document. I'm going to edit it and copy the ID to the clipboard. Now, in Atom, we can start querying the first object, `filter`. We're only looking for documents where the `_id` equals `new ObjectID` with the value that we copied to the clipboard. This is all we need for the `filter` argument. Next up is going to be the actual updates we want to apply, and this is not exactly straightforward. What we have to do here is learn about the MongoDB update operators.\n\nWe can view a complete list of these operators and exactly what they are by googling `mongodb update operators`. When I do this, we're looking for the [mongodb.com](http://www.mongodb.com) documentation:\n\n![](img/6f97eb20-78fa-402b-a775-9cfc27409e28.png)\n\nNow this documentation is specific to MongoDB, which means it's going to work with all of the drivers. In this case, it is going to work with our Node.js driver. If we scroll down further, we can look at all of the update operators we have access to. The most important, and the one we're going to get started with, is the `$set` operator. This lets us set a field's value inside of our update, which is exactly what we want to do. There's other operators, like increment. This one, `$inc`, lets you increment a field's value, like the age field in our `Users` collection. Although these are super useful, we're going to get started with `$set`. In order to use one of these operators, what we need to do is type it out, `$set`, and then set it equal to an object. In this object, these are the things that we're actually going to be setting. For example, we want to set `completed` equal to `true`. If we tried to put `completed` equal to `true` at the root of the object like this, it would not work as expected. We have to use these update operators, which means we need this. Now that we have our updates in place using the set update operator, we can go ahead and provide our third and final argument. If you head over to the documentation for `findOneAndUpdate`, we can take a look at the `options` real quick. The one we care about is `returnOriginal`.\n\nThe `returnOriginal` method is defaulted to `true`, which means that it returns the original document, not the updated one, and we don't want that. When we update a document, we want to get back that updated document. What we're going to do is set `returnOriginal` to `false`, and that's going to happen in our third and final argument. This one is also going to be an object, `returnOriginal`, which is going to be setting equal to `false`.\n\nWith this in place, we are done. We can tack on a `then` call to do something with the results. I'll get my result back and I can simply print it to the screen, and we can take a look at exactly what comes back:\n\n```", "```js\n\nNow, let's go ahead and run this from the Terminal. I'm going to save my file inside the Terminal. We're going to be running `node`. The file is in the `playground` folder, and we will call it\u00a0`mongodb-update.js`. I'm going to run the following script:\n\n```", "```js\n\nWe get back the value prop, just like we did when we used `findOneAndDelete`, and this has our document with the completed value set to true, which is the brand-new value we just set, which is fantastic:\n\n![](img/6ea4eeaf-5eb6-4035-be14-aa56c0efb3c1.png)\n\nIf we head over to Robomongo, we can confirm that the value was indeed updated. We can see this in the old document, where the value is false. I'm going to open up a new view for Todos:\n\n![](img/936011e3-b25f-4701-ac2d-f15393c3216f.png)\n\nWe have Eat lunch, with a completed value of true. Now that we have this in place, we know how to insert, delete, update, and read documents from our MongoDB collections. To wrap this section up, I want to give you a quick challenge. Over inside of the `Users` collection, you should have a document. It should have a name. It's probably not `Jen`; it's probably something that you set. What I want you to do is update this name to your name. Now if it's already your name, that's fine; you can change it to something else. I also want you to use\u00a0`$inc`, the increment operator that we talked about, to increment this by 1\\. Now I'm not going to tell you exactly how increment works. What I want you to do is head over to the docs, click on the `operator`, and then scroll down to see the examples. There's examples for each operator. It's going to become really useful for you to learn how to read documentation. Now, documentation for libraries is not always going to be the same; everyone does it a little differently; but once you learn how to read the docs for one library, it gets a lot easier to read the docs for others, and I can only teach so much in this course. The real goal of this course is to get you writing your own code, doing your own research, and looking up your own documentation, so your goal once again is to update this document, setting the name to something other than what it's currently set to, and incrementing the age by 1.\n\nTo kick things off, I'm going to grab the ID of the document in Robomongo, since this is the document I want to update. I'll copy the ID to the clipboard, and now we can focus on writing that statement in Atom. First up, we'll update the name, since we already know how to do that. In Atom, I'm going to go ahead and duplicate the statement:\n\n```", "```js\n\nI'll copy it and paste it. Back inside of Atom, we can start swapping things out. First up, we're going to swap out the old ID for the new one, and we're going to change what we passed to set. Instead of updating `completed`, we want to update `name`. I'm going to set the\u00a0`name` equal to something other than `Jen`. I'm going to go ahead and use my name, `Andrew`. Now, we are going to keep `returnOriginal` set to `false`. We want to get the new document back, not the original. Now, the other thing that we need to do is increment the age. This is going to be done via the increment operator, which you should have explored using the documentation over inside of Chrome. If you click on `$inc`, it's going to bring you to the `$inc` part of the documentation, and if you scroll down, you should be able to see an example. Right here, we have an example of what it looks like to increment:\n\n![](img/ea8c2677-365e-4533-80bb-e53952b498a4.png)\n\nWe set `$inc` just like we set `set`. Then, inside of the object, we specify the things we want to increment, and the degree to which we want to increment them. It could be `-2`, or in our case, it would be positive, `1`. In Atom, we can implement this, as shown in the following code:\n\n```", "```js\n\nI'll set `$inc` equal to an object, and in there, we'll increment the `age` by `1`. With this in place, we are now done. Before I run this file, I am going to comment out to the other call to `findOneAndUpdate`, just leaving the new one. I also need to swap out the collection. We're no longer updating the Todos collection; we're updating the `Users` collection. Now, we are good to go. We're setting the\u00a0`name` equal to `Andrew` and we're incrementing the `age` by `1`, which means that we would expect the age in Robomongo to be 26 instead of 25\\. Let's go ahead and run this by restarting the script over in the Terminal:\n\n![](img/92d5c78a-7d25-4e19-aad4-155256400d0a.png)\n\nWe can see our new document, where the name is indeed `Andrew` and the age is indeed `26`, and this is fantastic. Now that you know how to use the increment operator, you can also go off and learn all of the other operators you have available to you inside of your update calls. I can double-check that everything worked as expected in Robomongo. I'm going to go ahead and refresh the `Users` collection:\n\n![](img/4bce35a0-d75f-4431-8e26-93dbc12f7e02.png)\n\nWe have our updated document right here. Well, let's wrap this section up by committing our changes. In the Terminal, I'm going to run `git status` so we can view all of the changes to the repository:\n\n![](img/a0f74cdc-051d-4c3b-9a02-3539a35a2383.png)\n\nHere, we just have one untracked file, our `mongodb-update` script. I'm going to use `git add .` to add that to the next commit, and then I'll use `git commit` to actually make the commit. I am going to provide the\u00a0`-m` argument for `message` so we can specify a message, which is going to be\u00a0`Add update script`:\n\n```", "```js\n\nAnd now we can run the commit command and push it up to GitHub, so our code is backed up on our GitHub repository:\n\n```"]