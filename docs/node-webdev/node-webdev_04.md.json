["```js\\1\n\nThe `require` function is given a\u00a0*module identifier,* and it searches for the module named by that identifier. If found, it loads the module definition into the Node.js runtime and making its functions available. In this case, the `fs` object contains the code (and data) exported by the `fs` module. The `fs` module is part of the Node.js core and provides filesystem functions.\n\nBy declaring `fs` as `const`, we have a little bit of assurance against making coding mistakes. We could mistakenly assign a value to `fs`, and then the program would fail, but as a `const` we know the reference to the `fs` module will not be changed.\n\nThe file,\u00a0`ls.js`, is itself a module because every source file we use on Node.js is a module. In this case, it does not export anything but is instead a script that consumes other modules.\n\nWhat does it mean to say the `fs` object contains the code exported by the `fs` module? In a CommonJS module, there is an object, `module`, provided by Node.js, with which the module's author describes the module. Within this object is a field, `module.exports`, containing the functions and data exported by the module.\u00a0The return value of the\u00a0`require`\u00a0function is the object.\u00a0The object is the interface provided by the module to other modules. Anything added to the `module.exports` object is available to other pieces of code, and everything else is hidden. As a convenience, the `module.exports` object is also available as `exports`.\u00a0\n\nThe\u00a0`module`\u00a0object contains\u00a0several\u00a0fields that you might find useful. Refer to the online Node.js documentation for details.\n\nBecause `exports` is an alias of `module.exports`, the following two lines of code are equivalent:\n\n```", "```js\\1\n\nAny assignment to\u00a0`exports`\u00a0will break the alias, and it will no longer be equivalent to\u00a0`module.exports`. Assignments to `exports.something` are okay, but assigning to `exports` will cause failure. If your intent is to assign a single object or function to be returned by\u00a0`require`, do this instead:\n\n```", "```js\\1\n\nWe have one variable, `count`, which is not attached to the `exports` object, and a function, `next`, which is attached. Because `count` is not attached to `exports`, it is private to the module.\u00a0\n\nAny module can have private implementation details that are not exported and are therefore not available to any other code.\n\nNow, let's use the module we just wrote:\n\n```", "```js\\1\n\nThis says that HTTP requests on the `/assets/vendor/jquery` URL are to be handled by the static handler in Express, from the contents of a directory relative to the directory containing the module. Don't worry about the details because we'll discuss this more carefully in a later chapter. Just notice that `__dirname` is useful to calculate a filename relative to the location of the module source code.\n\nTo see it in action, create a file named `dirname.js` containing the following:\n\n```", "```js\\1\n\nSimple enough, but as we'll see later these values are not directly available in ES6 modules.\n\nNow that we've got a taste for CommonJS modules, let's take a look at ES2015 modules.\n\n## Examining the ES6/ES2015 module format\n\nES6 modules are a new module format\u00a0designed for all JavaScript environments. While Node.js has always had a good module system, browser-side JavaScript has not. That meant the browser-side community had to use non-standardized solutions. The CommonJS module format was one of those non-standard solutions, which was borrowed for use in Node.js. Therefore, ES6 modules are a big improvement for the entire JavaScript world, by getting everyone on the same page with a common module\u00a0format\u00a0and mechanisms.\n\nAn issue we have to deal with is the file extension to use for ES6 modules. Node.js needs to know whether to parse using the CommonJS or ES6 module syntax. To distinguish between them, Node.js uses the file extension `.mjs` to denote ES6 modules, and `.js` to denote CommonJS modules. However, that's not the entire story since Node.js can be configured to recognize the\u00a0`.js` files as ES6 modules. We'll give the exact particulars later in this chapter.\n\nThe ES6 and CommonJS modules are conceptually similar. Both support exporting data and functions from a module, and both support hiding implementation inside a module. But they are very different in many practical ways.\n\nLet's start with defining an ES6 module. Create a file named\u00a0`simple2.mjs`\u00a0in the same directory as the\u00a0`simple.js`\u00a0example that we looked at earlier:\n\n```", "```js\\1\n\nThe effect of this is similar to the following:\n\n```", "```js\\1\n\nThe\u00a0`import`\u00a0statement does what it says: it imports objects exported from a module. Because it uses the `import * as foo`\u00a0syntax, it imports everything from the module, attaching everything to an object, in this case named `simple2`. This version of the\u00a0`import`\u00a0statement is most similar to a traditional Node.js\u00a0`require`\u00a0statement because it creates an object with fields containing the objects exported from the module.\n\nThis is how the code executes:\n\n```", "```js\\1\n\nIn this case, the import is treated similarly to an ES2015 destructuring assignment. With this style of import, we specify exactly what is to be imported, rather than importing everything. Furthermore, instead of attaching the imported things to a common object, and therefore executing\u00a0`simple2.next()`, the imported things are executed using their simple name, as in\u00a0`next()`.\n\nThe import for `default as simple`\u00a0is the\u00a0way to declare an alias of an imported thing. In this case, it is necessary so that the default export has a name other than *default*.\u00a0\n\nNode.js modules can be used from the ES2015\u00a0`.mjs`\u00a0code. Create a file named\u00a0`ls.mjs`\u00a0containing the following:\n\n```", "```js\\1\n\nThe last thing to note about ES2015 module code is that the\u00a0`import`\u00a0and\u00a0`export`\u00a0statements must be top-level code. Try putting an\u00a0`export`\u00a0inside a simple block like this:\n\n```", "```js\\1\n\nWhile there are a few more\u00a0details\u00a0about the ES2015 modules, these are their most important attributes.\n\nRemember that the objects injected into CommonJS modules are not available to ES6 modules. The\u00a0`__dirname` and `__filename`\u00a0objects are the most important, since there are many cases where we compute a filename relative to the currently executing module. Let us explore how to handle that issue.\n\n### Injected objects in ES6 modules\n\nJust as for CommonJS modules, certain objects are injected into ES6 modules. Furthermore, ES6 modules do not receive the `__dirname`, and\u00a0`__filename`\u00a0objects or other objects that are injected into CommonJS modules.\n\nThe `import.meta` meta-property is the only value injected into ES6 modules. In Node.js it contains a single field, `url`. This is the URL from which the currently executing module was loaded.\n\nUsing `import.meta.url`, we can compute `__dirname` and `__filename`.\n\n### Computing the missing\u00a0__dirname\u00a0variable in ES6 modules\n\nIf we make a duplicate of `dirname.js` as `dirname.mjs`, so it will be interpreted as an ES6 module, we get the following:\n\n```", "```js\\1\n\nWe are importing a couple of useful functions from the\u00a0`url` and `path`\u00a0core packages. While we could take the `import.meta.url` object and do our own computations, these functions already exist. The computation is to extract the pathname portion of the module URL, to compute `__filename`, and then use `dirname` to compute `__dirname`.\n\n```", "```js\\1\n\nThis, of course, informs Node.js that the package defaults to ES6 modules. Therefore, this command interprets the module as an ES6 module:\n\n```", "```js\\1\n\nIf instead, the `type` field had the\u00a0`commonjs`, or the `--input-type` flag specified as `commonjs`, or if both those were completely missing, then `my-module.js` would be interpreted as a CommonJS module.\n\nThese rules also apply to the\u00a0`import`\u00a0statement, the `import()`\u00a0function, and the\u00a0`require()` function. We will cover those commands in more depth in a later section. In the meantime, let's learn how the `import()` function partly resolves the inability to use ES6 modules in a CommonJS module.\u00a0\n\n### Using ES6 modules from CommonJS using import()\n\nThe `import` statement in ES6 modules is a statement, and not a function like `require()`. This means that `import` can only be given a static string, and you cannot compute the module identifier to import. Another limitation is that `import` only works in ES6 modules, and therefore a CommonJS module cannot load an ES6 module. Or, can it?\n\nSince the `import()` function is available in both CommonJS and ES6 modules, that means we should be able to use it to import ES6 modules in a CommonJS module.\u00a0\n\nTo see how this works, create a file named `simple-dynamic-import.js` containing the following:\n\n```", "```js\\1\n\nThis is a CommonJS module successfully executing code contained in an ES6 module simply by using `import()`.\n\nNotice that `import()` was called not in the global scope of the module, but inside an async function. As we saw earlier, the ES6 module keyword statements like `export` and `import` must be called in the global scope. However,\u00a0`import()` is an asynchronous function, limiting our ability to use it in the global scope.\n\nThe\u00a0`import`\u00a0statement is itself an asynchronous process, and by extension the\u00a0`import()`\u00a0function is asynchronous, while the Node.js\u00a0`require()`\u00a0function is synchronous.\u00a0\n\nIn this case, we executed\u00a0`import()` inside an `async` function using the `await` keyword. Therefore, even if `import()` were used in the global scope, it would be tricky getting a global-scope variable to hold the reference to that module. To see, why let's rewrite that example as `simple-dynamic-import-fail.js`:\n\n```", "```js\\1\n\nWe see that `simple2` does indeed contain a pending Promise, meaning that `import()` has not yet finished. Since `simple2` does not contain a reference to the module, attempts to call the exported function fail.\n\nThe best we could do in the global scope is to attach the\u00a0`.then`\u00a0and `.catch` handlers to the `import()` function call. That would wait until the Promise transitions to either a success or failure state, but the loaded module would be inside the callback function. We'll see this example later in the chapter.\n\nLet's now see how modules hide implementation details.\n\n## Hiding implementation details with encapsulation in CommonJS and ES6 modules\n\nWe've already seen a couple of examples of how\u00a0modules hide implementation details\u00a0with the `simple.js` example and the programs we examined in [Chapter 2](bd2253cb-6a41-4fc5-ae86-cc9632d44da4.xhtml), *Setting up Node.js*. Let's take a closer look.\n\nNode.js modules provide a simple encapsulation mechanism to hide implementation details while exposing an API. To review, in CommonJS modules the exposed API is assigned to the `module.exports` object, while in ES6 modules the exposed API is declared with the `export` keyword. Everything else inside a module is not available to code outside the module.\n\nIn practice, CommonJS modules are treated as if they were written as follows:\n\n```", "```js\\1\n\nThen, create a file named\u00a0`module2.js`,\u00a0containing the following:\n\n```", "```js\\1\n\nThis artificial example demonstrates\u00a0encapsulation\u00a0of the values in\u00a0`module1.js`\u00a0from those in\u00a0`module2.js`. The\u00a0`A`\u00a0and\u00a0`B`\u00a0values in\u00a0`module1.js`\u00a0don't overwrite\u00a0`A`\u00a0and\u00a0`B`\u00a0in\u00a0`module2.js`\u00a0because they're encapsulated within\u00a0`module1.js`. The\u00a0`values`\u00a0function in\u00a0`module1.js`\u00a0does allow\u00a0code\u00a0in\u00a0`module2.js`\u00a0access to the values; however,\u00a0`module2.js`\u00a0cannot directly access those values. We can modify the object\u00a0`module2.js`\u00a0received from\u00a0`module1.js`. But doing so does not change the values within\u00a0`module1.js`.\n\nIn Node.js modules can also be data, not just code.\n\n## Using JSON modules\n\nNode.js supports using `require('./path/to/file-name.json')` to import a JSON file in a CommonJS module. It is equivalent to the following code:\n\n```", "```js\\1\n\nNow create a file named `showdata.js`\u00a0containing the following:\n\n```", "```js\\1\n\nThe `console.log` function outputs information to the Terminal. When it receives an object, it prints out the object content like this. And this demonstrates that `require` correctly read the JSON file since the resulting object matched the JSON.\n\nIn an ES6 module, this is done with the `import` statement and requires a special flag. Create a file named `showdata-es6.mjs` containing the following:\n\n```", "```js\\1\n\nCurrently using `import` to load a JSON file is an experimental feature. Enabling the feature requires these command-line arguments, causing this warning to be printed. We also see that instead of `data` being an anonymous object, it is an object with the type\u00a0`Module`.\n\nNow let's look at how to use ES6 modules on some older Node.js releases.\n\n## Supporting ES6 modules on older Node.js versions\n\nInitially, ES6 module support was an experimental feature in Node.js 8.5 and became a fully supported feature in Node.js 14\\. With the right tools, we can use it on earlier Node.js implementations.\u00a0\n\nFor an example of using Babel to transpile ES6 code for older Node.js versions, see\u00a0[https://blog.revillweb.com/using-es2015-es6-modules-with-babel-6-3ffc0870095b](https://blog.revillweb.com/using-es2015-es6-modules-with-babel-6-3ffc0870095b).\n\nThe better method of using ES6 modules on Node.js 6.x is the `esm` package. Simply do the following:\n\n```", "```js\\1\n\nIt is, of course, possible to use Babel in such cases to convert the full set of ES2015+ features to run on older Node.js releases.\n\nFor more information about esm, see:\u00a0\n[https://medium.com/web-on-the-edge/es-modules-in-node-today-32cff914e4b](https://medium.com/web-on-the-edge/es-modules-in-node-today-32cff914e4b). The article describes an older release of the `esm` module, at the time named `@std/esm`.\n\nTh current documentation for the esm package is available at:\u00a0[https://www.npmjs.com/package/esm](https://www.npmjs.com/package/esm).\n\nIn this section, we've learned about how to define a Node.js module and various ways to use both CommonJS and ES6 modules. But we've left out some very important things: what is the module identifier and all the ways to locate and use modules. In the next section, we cover these topics.\n\n# Finding and loading modules using require and import\n\nIn the course of learning about modules for Node.js, we've used the `require` and `import` features without going into detail about how modules are found and all the options available. The algorithm for finding Node.js modules is very flexible. It supports finding modules that are siblings of the currently executing module, or have been installed local to the current project, or have been installed globally.\n\nFor both\u00a0`require`\u00a0and\u00a0`import`, the command takes a\u00a0*module identifier*. The algorithm Node.js uses is in charge of resolving the module identifier into a file containing the module, so that Node.js can load the module.\n\nThe official documentation for this is in the Node.js documentation, at\u00a0[https://nodejs.org/api/modules.html](https://nodejs.org/api/modules.html). [The official documentation for ES6 modules also discusses how the algorithm differs, at](https://nodejs.org/api/modules.html)[https://nodejs.org/api/esm.html](https://nodejs.org/api/esm.html)[.](https://nodejs.org/api/modules.html)\n\nUnderstanding the module resolution algorithm is one key to success with Node.js. This algorithm determines how best to structure the code in a Node.js application.\u00a0While debugging problems with loading the correct version of a given package, we need to know how Node.js finds packages.\n\nFirst, we must consider several types of modules, starting with the simple file modules we've already used.\n\n## Understanding File modules\n\nThe\u00a0CommonJS and ES6 modules we've just looked at are what the Node.js documentation describes as a **file module**. Such modules are contained within a single file, whose filename ends with\u00a0`.js`, `.cjs`,\u00a0`.mjs`, `.json`, or `.node`. The latter are compiled from C or C++ source code, or even other languages such as Rust, while the former are, of course, written in JavaScript or JSON.\u00a0\n\nThe\u00a0*module identifier* of a file module must start with\u00a0`./`\u00a0or `../`. This signals Node.js that the module identifier refers to a local file. As should already be clear,\u00a0this module identifier refers to a pathname\u00a0relative to the currently executing module.\n\nIt is also possible to use an absolute pathname as the module identifier. In a CommonJS module, such an identifier might be `/path/to/some/directory/my-module.js`. In an ES6 module, since the module identifier is actually a URL, then we must use a `file://` URL like `file:///path/to/some/directory/my-module.mjs`. There are not many cases where we would use an absolute module identifier, but the capability does exist.\n\nOne difference between CommonJS and ES6 modules is the ability to use extensionless module identifiers. The CommonJS module loader allows us to do this, which you should save as `extensionless.js`:\n\n```", "```js\\1\n\nAnd we can run it with the `node` command using an extension-less module identifier.\n\nBut if we specify an extension-less identifier for an ES6 module:\n\n```", "```js\\1\n\nThis loads the module named `module-name.mjs` with a query string containing `query=1`. By default, this is ignored by the Node.js module loader, but there is an experimental loader hook feature by which you can do something with the module identifier URL.\n\nThe next type of module to consider is those baked into Node.js, the core modules.\n\n## Understanding the Node.js core modules\n\nSome modules are pre-compiled into the Node.js binary. These are the core Node.js modules documented on the Node.js website at\u00a0[https://nodejs.org/api/index.html](https://nodejs.org/api/index.html).\n\nThey start out as source code within the Node.js build tree. The build process compiles them into the binary so that the modules are always available.\n\nWe've already seen how the core modules are used. In a CommonJS module, we might use the following:\n\n```", "```js\\1\n\nIn both cases, we're loading the `http` and `fs` core modules that would then be used by other code in the module.\n\nMoving on, we will next talk about more complex module structures.\n\n## Using a directory as a module\n\nWe commonly organize\u00a0stuff into a directory structure. The stuff\u00a0here is a technical term referring to internal file modules, data files, template files, documentation, tests, assets, and more. Node.js allows us to create an entry-point module into such a directory structure.\n\nFor example, with a module identifier like `./some-library`\u00a0that refers to a directory, then there must be a file named `index.js`, `index.cjs`, `index.mjs`, or `index.node` in the directory. In such a case, the module loader loads the appropriate\u00a0`index` module even though the module identifier did not reference a full pathname. The pathname is computed by appending the file it finds in the directory.\n\nOne common use for this is that the `index` module provides an API for a library stored in the directory and that other modules in the directory contain what's meant to be private implement details.\n\nThis may be a little confusing because the word\u00a0*module*\u00a0is being overloaded with two meanings. In some cases, a\u00a0module\u00a0is a file, and in other cases, a\u00a0module\u00a0is a directory containing one or more file\u00a0modules.\n\nWhile overloading the word\u00a0*module* this way might be a little confusing, it's going to get even more so as we consider the packages we install from other sources.\n\n## Comparing installed packages and modules\n\nEvery programming platform supports the distribution of libraries or packages that are meant to be used in a wide array of applications. For example, where the Perl community has CPAN, the Node.js community has the `npm` registry. A Node.js\u00a0*installed package* is the same as we just described as a\u00a0*folder as a module*, in that the package format is simply a directory containing a `package.json` file along with the code and other files comprising the package.\n\nThere is the same risk of confusion caused by overloading the word\u00a0*module*\u00a0since an installed package is typically the same as the *directories as modules* concept just described. Therefore, it's useful to refer to an installed package with the word\u00a0*package*.\n\nThe `package.json` file describes the package. A minimal set of fields are defined by Node.js, specifically as follows:\n\n```", "```js\\1\n\nWith this, code using such a package can load the inner module using `require('module-name/cjsmodule')` or `import 'module-name/es6module'`. Notice that the filenames do not have to match what's exported.\n\nIn a\u00a0`package.json`\u00a0file using this `exports` feature, a request for an inner module not listed in\u00a0`exports` will fail. Supposing the package has a\u00a0`./src/hidden-module.js`\u00a0file, calling `require('module-name/src/hidden-module.js')` will fail.\n\nAll these modules and packages are meant to be used in the context of a Node.js project. Let's take a brief look at a typical project.\n\n## Studying an example project directory structure\n\nA typical Node.js project is a directory containing a\u00a0`package.json`\u00a0file declaring the characteristics of the package, especially its dependencies. That, of course, describes a directory module, meaning that each module is its own project. At the end of the day, we create applications, for example, an Express application, and these applications depend on one or more (possibly thousands of) packages that are to be installed:\n\n![](img/cf27a654-d58c-4078-b716-46e60c3cc2d2.png)\n\nThis is an Express application (we'll start using Express in [Chapter 5](582d3898-0135-430c-8b6e-8326f287e18b.xhtml), *Your First Express Application*) containing a few modules installed in the `node_modules` directory. A typical Express application uses `app.js` as the main module for the application, and has code and asset files distributed in the `public`, `routes`, and `views` directories. Of course, the project dependencies are installed in the\u00a0`node_modules` directory.\n\nBut let's focus on the content of the `node_modules` directory versus the actual project files. In this screenshot, we've selected the `express` package. Notice it has a `package.json`\u00a0file and there is an `index.js`\u00a0file. Between those two files, Node.js will recognize the `express` directory as a module, and calling `require('express')` or `import 'express'` will be satisfied by this directory.\n\nThe `express` directory has its own `node_modules` directory, in which are installed two packages. The question is, why are those packages installed in `express/node_modules` rather than as a sibling of the `express` package?\n\nEarlier we discussed what happens if two modules (modules A and B) list a dependency on different versions of the same module (C). In such a case,\u00a0the package manager application will install two versions of C, one as `A/node_modules/C` and the other as `B/node_modules/C`. The two copies of C are thus located such that the module search algorithm will cause module A and module B to have the correct version of module C.\n\nThat's the situation we see with `express/node_modules/cookie`. To verify this, we can use an `npm` command to\u00a0query for all references to the module:\n\n```", "```js\\1\n\nAnd at the top-level of a Node.js script, the best we can do is the following:\n\n```", "```js\\1\n\nIn this case, we use the exports as just the name, without referring to the module:\u00a0`simple()`, `hello()`, and `next()`.\n\nIt is possible to import just the default export:\n\n```", "```js\\1\n\nIn this case, each property exported from the module is a property of the named object in the `import` statement.\u00a0\n\nAn ES6 module can also use `import` to load a CommonJS module. Loading the `simple.js` module we used earlier is accomplished as follows:\n\n```", "```js\\1\n\nThis demonstrates that the CommonJS `module.exports` object is surfaced as `default` when imported.\n\nWe've learned a lot about using modules in Node.js. This included the different types of modules, and how to find them in the file system. Our next step is to learn about package management applications and the npm package repository.\n\n# Using npm \u2013 the Node.js package management system\n\nAs described in [Chapter\u00a02](bd2253cb-6a41-4fc5-ae86-cc9632d44da4.xhtml), *Setting\u00a0**up\u00a0**Node.js*, npm is a package management and distribution system for Node.js. It has become the de facto standard for distributing modules (packages) for use with Node.js. Conceptually, it's similar to tools such as `apt-get` (Debian), `rpm`/`yum` (Red Hat/Fedora), MacPorts/Homebrew (macOS), CPAN (Perl), or PEAR (PHP). Its purpose is to publish and distributing Node.js packages over the internet using a simple command-line interface. In recent years, it has also become widely used for distributing front-end libraries like jQuery and Bootstrap that are not Node.js modules. With npm, you can quickly find packages to serve specific purposes, download them, install them, and manage packages you've already installed.\n\nThe `npm` application extends on the package format for Node.js, which in turn is largely based on the CommonJS package specification. It uses the same `package.json` file that's supported natively by Node.js, but with additional fields for additional functionality.\n\n## The npm package format\n\nAn npm package is a directory structure with a `package.json` file describing the package. This is exactly what was referred to earlier as a directory module, except that npm recognizes many more `package.json` tags than Node.js does. The starting point for npm's `package.json`\u00a0file is the CommonJS Packages/1.0 specification. The documentation for the npm\u00a0`package.json` implementation is accessed using the following command:\n\n```", "```js\\1\n\nNpm recognizes many more fields than this, and we'll go over some of them in the coming sections. The file is in JSON format, which, as a JavaScript programmer, you should be familiar with.\n\nThere is a lot to cover concerning the npm `package.json` format, and we'll do so over the following sections.\n\n## Accessing npm helpful documentation\n\nThe main\u00a0`npm`\u00a0command has a\u00a0long\u00a0list of subcommands for specific package management operations. These cover every aspect of the life cycle of publishing packages (as a package author), and downloading, using, or removing packages\u00a0(as an npm consumer).\n\nYou can view the list of these commands just by typing\u00a0`npm`\u00a0(with no arguments). If you see one you want to learn more about, view the help information:\n\n```", "```js\\1\n\nIn a blank directory, run `npm init`, answer the questions, and as quick as that you have the starting point for a Node.js project.\n\nThis is, of course, a starting point, and as you write the code for your project it will often be necessary to use other packages.\n\n## Finding npm packages\n\nBy default,\u00a0`npm`\u00a0packages are retrieved over the\u00a0internet\u00a0from the public package registry maintained on\u00a0[http://npmjs.com](http://npmjs.com). If you know the module name, it can be installed simply by typing the following:\n\n```", "```js\\1\n\nThe npm repository uses a few `package.json` fields to aid in finding packages.\n\n### The package.json fields that help finding packages\n\nFor a package to be easily found in the npm repository requires a good package name, package description, and keywords. The npm search function scans those package attributes and presents them in search results.\n\nThe relevant `package.json` fields are as follows:\n\n```", "```js\\1\n\nThe named module is installed in\u00a0`node_modules`\u00a0in the current directory. During the installation process, the package is set up. This includes installing any packages it depends on and running the\u00a0`preinstall` and `postinstall` scripts. Of course, installing the dependent packages also involves the same installation process of installing dependencies and executing pre-install and post-install scripts.\u00a0\n\nSome packages in the npm repository have a package\u00a0*scope* prepended to the package name. The package name in such cases is presented as `@scope-name/package-name`, or, for example,\u00a0`@akashacms/plugins-footnotes`. In such a package, the `name` field in `package.json` contains the full package name with its `@scope`.\n\nWe'll discuss dependencies and scripts later. In the meantime, we notice that a version number was printed in the output, so let's discuss package version numbers.\n\n## Installing a package by version number\n\nVersion number\u00a0matching\u00a0in npm is powerful and flexible. With it, we can target a specific release of a given package or any version number range. By default, npm installs the latest version of the named package, as we did in the previous section. Whether you take the default or specify a version number, npm will determine what to install.\n\nThe package version is declared in the `package.json` file, so let's look at the relevant fields:\n\n```", "```js\\1\n\nThe last two are what they sound like. You can specify\u00a0`express@4.16.2`\u00a0to target a precise version, or\u00a0`express@\">4.1.0 < 5.0\"`\u00a0to target a range of Express V4 versions. We might use that specific expression because Express 5.0 might include breaking changes.\n\nThe version match specifiers include the following choices:\n\n*   **Exact version match**: 1.2.3\n*   **At least version N**: >1.2.3\n*   **Up to version N**: <1.2.3\n*   **Between two releases**: >=1.2.3 <1.3.0\n\nThe\u00a0`@tag`\u00a0attribute is a symbolic name such as\u00a0`@latest`,\u00a0`@stable`, or\u00a0`@canary`. The package owner assigns these symbolic names to specific version numbers and can reassign them as desired.\u00a0The exception is\u00a0`@latest`, which is updated whenever a new release of the package is published.\n\nFor more documentation, run these commands:\u00a0`npm help json`\u00a0and\u00a0`npm help npm-dist-tag`.\n\nIn selecting the correct package to use, sometimes we want to use packages that are not in the npm repository.\n\n## Installing packages from outside the npm repository\n\nAs awesome as the npm repository is, we don't want to\u00a0push\u00a0everything we do through their service. This is especially true for internal development teams who cannot publish their code for all the world to see. Fortunately, Node.js packages can be installed from other locations. Details about this are in\u00a0`npm help package.json`\u00a0in the\u00a0`dependencies`\u00a0section. Some examples are as follows:\n\n*   **URL**: You can specify\u00a0any URL that downloads a tarball, that is, a\u00a0`.tar.gz`\u00a0file. For example, GitHub or GitLab repositories can easily export a tarball URL. Simply go to the\u00a0Releases\u00a0tab to find them.\n*   **Git URL**: Similarly, any Git repository can be accessed with the right URL, for example:\n\n```", "```js\\1\n\nIf you get an error, and you're on a Unix-like system (Linux/Mac), you may need to run this with\u00a0`sudo`:\n\n```", "```js\\1\n\nThe algorithm used by Node.js for the\u00a0`require`\u00a0function automatically searches the directory for packages if the package is not found elsewhere.\n\nES6 modules do not support global packages.\n\nMany believe it is not a good idea to install packages globally, which we will look at next.\n\n### Avoiding global module installation\n\nSome in the Node.js community now\u00a0frown\u00a0on installing packages globally. One rationale is that a software project is more reliable if all its dependencies are explicitly declared. If a build tool such as Grunt is required but is not explicitly declared in\u00a0`package.json`, the users of the application would have to receive instructions to install Grunt, and they would have to follow those instructions.\u00a0\n\nUsers being users, they might skip over the instructions, fail to install the dependency, and then complain the application doesn't work. Surely, most of us have done that once or twice.\n\nIt's recommended to avoid this\u00a0potential\u00a0problem by installing everything locally via one mechanism\u2014the\u00a0`npm install`\u00a0command.\n\nThere are two strategies we use to avoid using globally installed Node.js packages. For the packages that install commands, we can configure the `PATH` variable, or use `npx` to run the command. In some cases, a package is used only during development and can be declared as such in `package.json`.\n\n## Maintaining package dependencies with npm\n\nThe\u00a0`npm install`\u00a0command by itself, with no package name specified,\u00a0installs\u00a0the packages listed in the\u00a0`dependencies`\u00a0section of\u00a0`package.json`. Likewise, the `npm update` command compares the installed packages against the dependencies and against what's available in the npm repository and updates any package that is out of date in regards to the repository.\u00a0\n\nThese two commands make it easy and convenient to set up a project, and to keep it up to date as dependencies are updated. The package author simply\u00a0lists\u00a0all the dependencies, and npm installs or updates the dependencies required for using the package. What happens is npm looks in\u00a0`package.json`\u00a0for the\u00a0`dependencies`\u00a0or\u00a0`devDependencies`\u00a0fields, and it works out what to do from there.\n\nYou can manage the dependencies manually by editing\u00a0`package.json`. Or you can use npm to assist you with editing the dependencies. You can add a new dependency like so:\n\n```", "```js\\1\n\nWith the added dependency, when your application is installed,\u00a0`npm`\u00a0will now install the package along with any other\u00a0`dependencies`\u00a0listed in\u00a0`package.json`\u00a0file.\n\nThe\u00a0`devDependencies`\u00a0lists modules used during development and testing. The field is initialized the same as the preceding one, but with the\u00a0`--save-dev`\u00a0flag. The `devDependencies` can be used to avoid some cases where one might instead perform a global package install.\n\nBy default, when\u00a0`npm\u00a0install` is run, modules listed in both\u00a0`dependencies`\u00a0and\u00a0`devDependencies`\u00a0are installed. Of course, the purpose of having two dependency lists is to control when each set of dependencies is installed.\n\n```", "```js\\1\n\nThe\u00a0`npm config`\u00a0command supports a long list of settable options for tuning the behavior of npm. See\u00a0`npm help config`\u00a0for the documentation and\u00a0`npm help 7 config`\u00a0for the list of options.\n\nNow let's talk about the one big use for package dependencies: to fix or avoid bugs.\n\n### Fixing bugs by updating package dependencies\n\nBugs exist in every piece of software. An update to the Node.js platform may break an existing package, as might an upgrade to packages used by the application. Your\u00a0application\u00a0may trigger a bug in a package it uses. In these and other cases, fixing the problem might be as simple as updating a package dependency to a later (or earlier) version.\n\nFirst, identify whether the problem exists in the package or in your code. After determining it's a problem in another package, investigate whether the package maintainers have already fixed the bug. Is the package hosted on GitHub or another service with a public issue queue? Look for an open issue on this problem. That investigation will tell you whether to update the package dependency to a later version. Sometimes, it will tell you to revert to an earlier version; for example, if the package maintainer introduced a bug that doesn't exist in an earlier version.\n\nSometimes, you will find that the package maintainers are unprepared to issue a new release. In such a case, you can fork their repository and create a patched version of their package. In such a case, your package might use a Github URL referencing your patched package.\n\nOne approach to fixing this problem is\u00a0**pinning**\u00a0the package version number to one that's known to work. You might know that version 6.1.2 was the last release against which your\u00a0application\u00a0functioned and that starting with version 6.2.0 your application breaks. Hence, in\u00a0`package.json`:\n\n```", "```js\\1\n\nAs a local install, this creates a command as `node_modules/.bin/hexy`. We can attempt to use it as follows:\n\n```", "```js\\1\n\nBut obviously typing the full or partial\u00a0pathname\u00a0is\u00a0not a user-friendly\u00a0way\u00a0to execute the command. We want to use the commands installed by modules, and we want a simple process for doing so. This means, we must add an appropriate value in the\u00a0`PATH`\u00a0variable, but what is it?\n\nFor global package installations, the executable lands in a directory that is probably already in your\u00a0`PATH`\u00a0variable, like\u00a0`/usr/bin`\u00a0or\u00a0`/usr/local/bin`. Local package installations require special handling. The full path for the\u00a0`node_modules/.bin`\u00a0directory varies for each project,\u00a0and obviously it won't work to add the full path for every\u00a0`node_modules/.bin`\u00a0directory to your\u00a0`PATH`.\n\nAdding\u00a0`./node_modules/.bin`\u00a0to the\u00a0`PATH`\u00a0variable (or, on Windows,\u00a0`.\\node_modules\\.bin`) works great. Any time your shell is in the root of a Node.js project, it will automatically find locally installed commands from Node.js packages.\n\nHow we do this depends on the command shell you use and your operating system.\n\nOn a Unix-like system, the command shells are\u00a0`bash`\u00a0and\u00a0`csh`. Your\u00a0`PATH`\u00a0variable would be set up in one of these ways:\n\n```", "```js\\1\n\nUsing\u00a0`npx`\u00a0is this easy.\n\nOf course, once you've installed some packages, they'll go out of date and need to be updated.\n\n## Updating packages you've installed when they're outdated\n\nThe coder codes, updating their package, leaving you in the dust unless you keep up.\n\nTo find out whether your installed\u00a0packages\u00a0are out of date, use the following command:\n\n```", "```js\\1\n\nSpecifying a package name updates just the named package. Otherwise, it updates every package that would be printed by `npm outdated`.\n\nNpm handles more than package management, it has a decent built-in task automation system.\n\n## Automating tasks with scripts in package.json\n\nThe `npm` command handles not just installing packages, it can also be used to automate running tasks related to the project. In\u00a0`package.json`, we can add a field, `scripts`, containing one or more command strings. Originally scripts were meant to handle tasks related to installing an application, such as compiling native code, but they can be used for much more. For example, you might have a deployment task using `rsync` to copy files to a server. In `package.json`, you can add this:\n\n```", "```js\\1\n\nOnce it has been recorded in\u00a0`scripts`, running the command is this easy.\n\nThere is a long list of \"lifecycle events\" for which npm has defined script names. These include the following:\n\n*   `install`, for when the package is installed\n*   `uninstall`, for when it is uninstalled\n*   `test`, for running a test suite\n*   `start` and `stop`, for controlling a server defined by the package\n\nPackage authors are free to define any other script they like.\u00a0\n\nFor the full list of predefined script names, see the documentation:\u00a0[https://docs.npmjs.com/misc/scripts](https://docs.npmjs.com/misc/scripts)\n\nNpm also defines a pattern for scripts that run before or after another script, namely to prepend `pre` or `post` to the script name. Therefore the `pretest` script runs before the `test` script, and the `posttest` script runs afterward.\n\nA practical example is to run a test script in a `prepublish` script to ensure the package is tested before publishing it to the npm repository:\n\n```"]