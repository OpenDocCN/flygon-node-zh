["```js\\1\n\nIf you have followed the directions for setting up MacPorts, the MacPorts directory is already in your PATH environment variable. Running the `node`,\u00a0`npm`, or `npx`\u00a0commands is then simple.\u00a0This proves Node.js has been installed and the installed version matched what you asked for.\n\nMacPorts isn't the only tool for managing open source software packages on macOS.\n\n## Installing Node.js on macOS with Homebrew\n\nHomebrew is another\u00a0open source software package manager for macOS, which some say\u00a0is the perfect replacement for MacPorts. It is available through their home page at [http://brew.sh/](http://brew.sh/). After installing Homebrew using the instructions on their website and ensuring that it\u00a0is correctly set up, use the following code:\n\n```", "```js\\1\n\nLike MacPorts, Homebrew installs commands on a public directory, which defaults to `/usr/local/bin`. If you have followed the Homebrew instructions to add that directory to your `PATH` variable, run the Node.js command as follows:\n\n```", "```js\\1\n\nThis adds the NodeSource APT repository to the system, updates the package data, and prepares the system so that you can install Node.js packages. It also instructs us on how to install Node.js and the required compiler and developer tools.\n\nTo download other Node.js\u00a0versions (this example shows version 14.x), modify the URL to suit you:\n\n```", "```js\\1\n\nGo to\u00a0[https://github.com/nodejs/node/blob/master/BUILDING.md](https://github.com/nodejs/node/blob/master/BUILDING.md)\u00a0for details on the requirements.\n\nThe specific method for installing these depends on your OS.\n\nThe Node.js build tools are in the process of being updated to support Python 3.x. Python 2.x is in an end-of-life process, slated for the end of 2019, so it is therefore recommended that you update to Python 3.x.\n\nBefore we can compile the Node.js source, we must have the correct tools installed and on macOS, there are a couple of special considerations.\n\n## Installing developer tools on macOS\n\nDeveloper tools (such as GCC) are an optional\u00a0installation on macOS. Fortunately, they're easy to acquire.\n\nYou start with Xcode, which is available for free through the Macintosh app store. Simply search for `Xcode` and click on the Get button. Once you have Xcode installed, open a Terminal window and type the following:\n\n```", "```js\\1\n\nNow, we configure the source so that it can be built. This is just like with many other open source packages and there is a long list of options to customize the build:\n\n```", "```js\\1\n\nIf you're going to install multiple Node.js versions side by side, it's useful to put the version number in the path like this. That way, each version will sit in a separate directory. It will then be a simple matter of switching between Node.js versions by changing the `PATH` variable appropriately:\n\n```", "```js\\1\n\nIf you are installing on a system-wide directory, perform the last step this way instead:\n\n```", "```js\\1\n\nAlternatively, for `csh` users, use this syntax to make an exported environment variable:\n\n```", "```js\\1\n\nNow that we've learned how to install Node.js from the source on UNIX-like systems, we get to do the same on Windows.\n\n## Installing from the source on Windows\n\nThe `BUILDING.md` document referenced\u00a0previously has instructions. You can use the build\u00a0tools from Visual Studio or the full Visual Studio 2017 or 2019 product:\u00a0\n\n*   Visual Studio 2019:\u00a0[https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/)\n*   The build tools:\u00a0[https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2019](https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2019)\n\nThree additional\u00a0tools are required:\n\n*   Git for Windows:\u00a0[http://git-scm.com/download/win](http://git-scm.com/download/win)\u00a0\u00a0\n*   Python:\u00a0[https://www.python.org/](https://www.python.org/)\n*   OpenSSL:\u00a0[https://www.openssl.org/source/](https://www.openssl.org/source/)\u00a0and\u00a0[https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries)\n*   The **Netwide Assembler** (**NASM**) for OpenSSL:\u00a0[https://www.nasm.us/](https://www.nasm.us/)\n\nThen, run the included `.\\vcbuild` script to perform the build.\u00a0\n\nWe've learned how to install one Node.js instance, so let's now take it to the next level by installing multiple instances.\n\n# Installing multiple Node.js instances with nvm\n\nNormally, you wouldn't install multiple versions of Node.js\u2014doing so adds complexity to your system. But if you are hacking on Node.js itself or testing your software against different Node.js releases, you may want to have multiple Node.js installations. The method to do so is a simple variation on what we've already discussed.\n\nEarlier, while discussing building\u00a0Node.js from the source, we noted that you\u00a0can install multiple Node.js instances in separate directories. It's only necessary to build from the source if you need a customized Node.js build but most folks would be satisfied with pre-built Node.js binaries. They, too, can be installed on separate directories.\n\nSwitching between Node.js versions is simply a matter of changing the `PATH` variable (on POSIX systems), as in the following code, using the directory where you installed Node.js:\n\n```", "```js\\1\n\nIn this example, we first listed the available versions. Then, we demonstrated how to switch between Node.js versions, verifying the version changed each time. We also installed and used a new version using `nvm`. Finally, we showed the directory where nvm installs Node.js packages versus Node.js versions that are installed using MacPorts or Homebrew.\n\nThis demonstrates that you can have Node.js installed system-wide, keep multiple private Node.js versions managed by `nvm`, and switch between them as needed. When new Node.js versions are released, they are simple to install with `nvm`, even if the official package manager for your OS hasn't yet updated its packages.\n\n## Installing nvm on Windows\n\nUnfortunately, `nvm` doesn't support\u00a0Windows. Fortunately, a couple of Windows-specific clones\u00a0of the `nvm` concept exist:\n\n*   Node.js version management utility for Windows: [https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows)\n*   Natural Node.js and npm version manager for Windows: [https://github.com/marcelklehr/nodist](https://github.com/marcelklehr/nodist)\n\nAnother route is to use WSL. Because in WSL you're interacting with a Linux command line, you can use `nvm` itself. But let's stay focused on what you can do in Windows.\n\nMany of the examples in this book were tested using the `nvm-windows` application. There are slight behavior differences but it acts largely the same as `nvm` for Linux and macOS. The biggest change is the version number specifier in the `nvm use` and `nvm install` commands.\n\nWith\u00a0`nvm`\u00a0for Linux and macOS, you can type a simple version number, such as\u00a0`nvm use 8`, and it will automatically substitute the latest release of the named Node.js version. With `nvm-windows`, the same command acts as if you typed `nvm use 8.0.0`. In other words, with `nvm-windows`, you must use the exact version number. Fortunately, the list of supported versions is easily available using the `nvm list available`\u00a0command.\n\nUsing a tool such as `nvm` simplifies the process of testing a Node.js application against multiple Node.js versions.\n\nNow that we can install Node.js, we need to make sure we are installing any Node.js module that we want to use. This requires having build tools installed on our computer.\n\n# Requirements for installing native code modules\n\nWhile we won't discuss native code module\u00a0development in this book, we do need to make\u00a0sure that they can be built. Some modules in the npm repository are native code and they must be compiled with a C or C++ compiler to build the corresponding\u00a0`.node`\u00a0files (the `.node` extension is used for binary native code modules).\n\nThe module will often describe itself as a wrapper for some other library. For example, the\u00a0`libxslt`\u00a0and\u00a0`libxmljs`\u00a0modules are wrappers around the C/C++ libraries of the same name. The module includes the C/C++ source code and\u00a0when installed, a script is automatically run to do the compilation with\u00a0`node-gyp`.\n\nThe\u00a0`node-gyp`\u00a0tool is a cross-platform command-line tool written in Node.js for compiling native add-on modules for Node.js. We've mentioned native code modules several times and it is this tool that compiles them for use with Node.js.\n\nYou can easily see this in action by running these commands:\n\n```", "```js\\1\n\nThis means exactly what it implies\u2014that the given package is compatible with Node.js version 8.x or later.\n\nOf course, your development environment(s) could have several Node.js versions installed. You'll need the version your software is declared to support, plus any later versions you wish to evaluate.\n\nWe have just learned how the Node.js community manages releases and version numbers. Our next step is to discuss which editor to use.\n\n# Choosing editors and debuggers for Node.js\n\nSince Node.js code is JavaScript, any JavaScript-aware editor will be useful. Unlike some other languages that are so complex that an IDE with code completion\u00a0is a necessity, a simple programming editor is perfectly sufficient for Node.js development.\n\nTwo editors are worth shouting out because they are written in Node.js: Atom and Microsoft Visual Studio Code.\u00a0\n\nAtom ([https://atom.io/](https://atom.io/)) describes itself as a hackable\u00a0editor for the 21st century. It is extendable by writing Node.js modules using the Atom API and the configuration files are easily editable. In other words, it's hackable in the same way plenty of other editors have been\u2014going back to Emacs, meaning you write a software module to add capabilities to the editor. The Electron framework was invented in order to build Atom and it is is a super-easy way of building desktop applications using Node.js.\n\nMicrosoft Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/)) is a hackable\u00a0editor (well, the home page says extensible and customizable, which means the same thing) that is also open source and implemented in Electron. However, it's not a hollow\u00a0me-too editor, copying Atom while adding nothing of its own. Instead, Visual Studio Code is a solid programmer's editor in its own right, bringing interesting functionality to the table.\n\nAs for debuggers, there are several interesting choices. Starting with Node.js 6.3, the `inspector` protocol has made it possible to use the Google\u00a0Chrome\u00a0debugger. Visual Studio Code has a built-in debugger that also uses the `inspector` protocol.\n\nFor a full list of debugging\u00a0options and tools, see\u00a0[https://nodejs.org/en/docs/guides/debugging-getting-started/](https://nodejs.org/en/docs/guides/debugging-getting-started/).\n\nAnother task related to the editor is adding extensions to help with the editing experience. Most programmer-oriented editors allow you to extend the behavior and assist with writing the code. A trivial example is syntax coloring for JavaScript, CSS, HTML, and so on. Code completion extensions are where the editor helps you write the code. Some extensions scan code for common errors; often these extensions use the word *lint*. Some extensions help to run unit test frameworks. Since there are so many editors available, we cannot provide specific suggestions.\u00a0\u00a0\n\nFor some, the choice of programming editor is a serious matter defended with fervor, so we carefully recommend that you use whatever editor you prefer, as long as it helps you edit JavaScript code. Next, we will learn about the Node.js commands and a little about running Node.js scripts.\n\n# Running and testing commands\n\nNow that you've installed Node.js, we want to do two\u00a0things\u2014verify that the installation was successful and familiarize ourselves with the Node.js command-line tools and running simple scripts with Node.js. We'll also touch again on `async` functions and look at a simple example HTTP server. We'll finish off with the `npm` and `npx` command-line tools.\n\n## Using Node.js's command-line tools\n\nThe basic installation of Node.js\u00a0includes two commands:\u00a0`node` and `npm`. We've already seen the `node` command in action. It's used either for running command-line scripts or server processes. The other, `npm`, is a package manager for Node.js.\n\nThe easiest way to verify that your Node.js installation works is also the best way to get help with Node.js. Type the following command:\n\n```", "```js\\1\n\nAny code you can write in a Node.js script can be written here. The command interpreter gives a good terminal-oriented user experience and is useful for interactively playing with your code. You do play with your code, don't you? Good!\n\n## Running a simple script with Node.js\n\nNow, let's look at how to run scripts with Node.js. It's quite simple; let's start by referring\u00a0to the help message shown previously. The command-line pattern is just a script filename and some script arguments, which should be familiar to anyone who has written scripts in other languages.\n\nCreating and editing Node.js scripts can be done with any text editor that deals with plain text files, such as VI/VIM, Emacs, Notepad++, Atom, Visual Studio Code, Jedit, BB Edit, TextMate, or Komodo. It's helpful if it's a programmer-oriented editor, if only for the syntax coloring.\n\nFor this and other examples in this book, it doesn't truly matter where you put the files. However, for the sake of neatness, you can start by making a directory named `node-web-dev` in the `home` directory of your computer and inside that, creating one directory per chapter (for example, `chap02` and `chap03`).\n\nFirst, create a text file named `ls.js` with the following content:\n\n```", "```js\\1\n\nThis is a pale and cheap imitation of the Unix `ls` command (as if you couldn't figure that out from the name!). The `readdir`\u00a0function is a close analog to the Unix `readdir` system call\u00a0used to list the files in a directory. On Unix/Linux systems, we can run the following command\u00a0to learn more:\n\n```", "```js\\1\n\nYou can run it as follows:\n\n```", "```js\\1\n\nIf you give it a non-existent directory pathname, an error will be thrown and printed using the\u00a0`catch`\u00a0clause.\u00a0\n\n### Writing inline async arrow functions\n\nThere is a different way to write these examples that some feel is more concise. These examples were written as a regular function\u2014with the\u00a0`function`\u00a0keyword\u2014but with the\u00a0`async`\u00a0keyword in front. One of the features that came with ES2015 is the arrow function, which lets us streamline the code a little bit.\n\nCombined with the `async` keyword, an async arrow function looks like this:\n\n```", "```js\\1\n\nThe final parenthesis causes the inline function to immediately\u00a0be\u00a0invoked.\n\nThen, because `async` functions return a Promise, it is necessary to add a `.catch` block to catch errors. With all that, the example looks as follows:\n\n```", "```js\\1\n\nRun it as follows:\n\n```", "```js\\1\n\nAdding the `-g` flag makes the module available globally, irrespective of\u00a0the present working directory of your command shell. A global install is most useful when the module provides a command-line interface. When a package provides a command-line script,\u00a0`npm`\u00a0sets that up. For a global install, the command is installed correctly for use by all users of the computer.\n\nDepending on how Node.js is installed for you, it may need to be run with `sudo`:\n\n```", "```js\\1\n\nThe `hexy` command was installed as a global command, making it easy to run.\n\nAgain, we'll be doing a deep dive into npm in the next chapter. The `hexy` utility is both a Node.js library and a script for printing out these old-style hex dumps.\n\nIn the open source world, a perceived need often leads to creating an open source project. The folks who launched the Yarn project saw needs that weren't being addressed by npm and created an alternative package manager tool. They claim a number of advantages over npm, primarily in the area of performance.\u00a0To learn more about Yarn, go to\u00a0[https://yarnpkg.com/](https://yarnpkg.com/).\n\nFor every example in this book that uses npm, there is a close equivalent command that uses Yarn.\n\nFor npm-packaged command-line tools, there is another, simpler way to use the tool.\n\n## Using npx to execute Node.js packaged binaries\n\nSome packages in the npm repository are command-line tools, such as the `hexy` program we looked at earlier. Having to first install such a program before using it is a small hurdle. The sharp-eyed among you will have noticed that `npx` is installed alongside the `node` and `npm` commands when installing Node.js. This tool is meant to simplify running command-line tools from the npm repository by removing the need to first install the package.\n\nThe previous example could have been run this way:\n\n```", "```js\\1\n\nThis is more than the syntactic sugar of replacing the `function` keyword with the fat arrow. Arrow functions are lighter weight as well as being easier to read. The lighter weight comes at the cost of changing the value of `this` inside the arrow function. In regular functions, `this` has a unique value inside the function. In an arrow function, `this` has the same value as the scope containing the arrow function. This means that, when using an arrow function, we don't have to jump through hoops to bring `this` into the callback function because `this` is the same at both levels of the code.\n\nThe next feature is the `Promise` class, which is used for deferred and asynchronous computations. Deferred code execution to implement asynchronous behavior is a key paradigm for Node.js and it requires two idiomatic conventions:\n\n*   The last argument to an asynchronous function is a callback function, which is called when an asynchronous execution is to be performed.\n*   The first argument to the callback function is an error indicator.\n\nWhile convenient, these conventions have resulted in multilayer code pyramids that can be difficult to understand and maintain:\n\n```", "```js\\1\n\nRather than passing in a callback function, the caller receives a `Promise` object. When properly utilized, the preceding pyramid can be coded as follows:\n\n```", "```js\\1\n\nAn `async` arrow function is as follows:\u00a0\n\n```", "```js\\1\n\nAgain, we don't need to understand the code but just look at its shape. Isn't this a breath of fresh air compared to the nested structure we started with?\n\nThe `await` keyword is used with a Promise. It automatically waits for the Promise to resolve. If the Promise resolves successfully, then the value is returned and if it resolves with an error, then that error is thrown. Both handling results and throwing errors are handled in the usual manner.\n\nThis example also shows another ES2015 feature: destructuring. The fields of an object can be extracted using the following code:\n\n```", "```js\\1\n\nThis installs the Babel software, along with a couple of transformation plugins. Babel has a plugin system so that you can enable the transformations required by your project. Our primary goal in this example is converting the `async` functions shown earlier into Generator functions. Generators are a new sort of function introduced with ES2015 that form the foundation for the implementation of `async` functions.\n\nBecause Node.js 6.x does not have either the `fs.promises` function or\u00a0`util.promisify`, we need to make some substitutions to create a file named `ls2-old-school.js`:\n\n```", "```js\\1\n\nThis file instructs Babel to use the named transformation plugins that we installed earlier. As the name implies, it will transform the\u00a0`async` functions to `generator` functions.\n\nBecause we installed `babel-cli`, a `babel` command is installed, such that we can type the following:\n\n```", "```js\\1\n\nThis command transpiles the named file, producing a new file. The new file is as follows:\n\n```"]