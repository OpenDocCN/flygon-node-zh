["```js\\1\n\nWe don't need to worry about the specific functions, but we should\u00a0instead recognize that one callback tends to lead to another. Before you know it, you've landed in the middle of a deeply nested structure like this. Rewriting this as an async function will make it much clearer. To get there, we need to examine how\u00a0Promises are used to manage asynchronous results, as well as get a deeper understanding of async functions.\n\nA Promise is either in an unresolved or resolved state. This means that we create a Promise using `new Promise`, and initially, it is in the unresolved state. The `Promise` object transitions to the resolved state, where either its `resolve` or `reject` functions are called. If the `resolve` function is called, the Promise is in a successful state, and if instead its `reject` function is called, the Promise is in a failed state.\n\nMore precisely, Promise\u00a0objects\u00a0can be in one of three states:\n\n*   **Pending**: This is the\u00a0initial\u00a0state, which is neither fulfilled nor rejected.\n*   **Fulfilled**: This is the final state,\u00a0where\u00a0it executes successfully and\u00a0produces a result.\n*   **Rejected**: This is the final state,\u00a0where\u00a0execution fails.\n\nWe generate a Promise\u00a0in the following way:\n\n```", "```js\\1\n\nThis is the pattern that we use when\u00a0*promisifying* an asynchronous function that uses callbacks. The asynchronous code executes, and in the callback, we invoke either `resolve` or `reject`, as appropriate. We can usually use the\u00a0`util.promisify`\u00a0Node.js function\u00a0to do this for us, but it's very useful to know how to construct this as needed.\n\nYour caller then uses the function, as follows:\n\n```", "```js\\1\n\nExpress catches that exception and does the right thing, meaning it invokes the error handler, but it does not see a thrown exception in asynchronous code. Consider the following error example:\n\n```", "```js\\1\n\nThis is rewritten using a Promise chain, rather than nested callbacks. What had been a deeply nested pyramid of callback functions is now arguably a little cleaner thanks to Promises.\n\nThe `Promise` class automatically captures all the errors and searches down the chain of operations attached to the Promise\u00a0to find and invoke\u00a0the first `.catch` function. So long as no errors occur, each `.then` function in the chain is executed in turn.\u00a0\n\nOne advantage of this is that error reporting and handling is much easier. With the callback paradigm, the nature of the callback pyramid makes error reporting trickier, and it's easy to miss adding the correct error handling to every possible branch of the pyramid. Another advantage is that the structure is flatter and, therefore, easier to read.\n\nTo integrate this style with Express, notice the following:\n\n*   The final step in the Promise chain uses `res.render` or a similar function to return a response to the caller.\n*   The final `catch` function reports any errors to Express using `next(err)`.\n\nIf instead we simply returned the Promise and it was in the `rejected` state, Express would not handle that failed rejection and the error would be lost.\n\nHaving looked at integrating asynchronous callbacks and Promise chains with Express, let's look at integrating async functions.\n\n## Integrating async functions with Express router functions\n\nThere are two problems that need to be\u00a0addressed\u00a0that are related to\u00a0asynchronous coding in JavaScript. The first is the pyramid of doom, an unwieldily nested callback structure. The second is the inconvenience of where results and errors are delivered in an asynchronous callback.\n\nTo explain, let's reiterate the example that Ryan Dahl gives as the primary Node.js idiom:\n\n```", "```js\\1\n\nThis is much cleaner, with results and errors landing where we want them to.\n\nHowever, to discuss integration with Express, let's return to the pyramid of doom example from earlier, rewriting it as an async function:\n\n```", "```js\\1\n\nAs in the previous chapter, we will use `cross-env` to ensure that the scripts\u00a0run cross-platform. Start by changing `package.json` to have the following\u00a0`scripts` section:\n\n```", "```js\\1\n\nWith `cross-env`, the scripts are executable on either Unix-like systems or Windows.\n\nIf you wish, you can run `npm start` and view the blank application in your browser. Instead, let's rewrite this starting-point code using ES6 modules, and also combine the contents of `bin/www` with\u00a0`app.mjs`.\n\n## Rewriting the generated router module as an ES6 module\n\nLet's start with the `routes` directory. Since we won't have a `Users` concept right now, delete `users.js`. We need to convert the JavaScript files into ES6 format, and we can recall that the simplest way for a module to be recognized as an ES6 module is to use the `.mjs` extension. Therefore,\u00a0rename `index.js` to\u00a0`index.mjs`, rewriting it as follows:\n\n```", "```js\\1\n\nThe generated `app.js`\u00a0code had a series of `require` statements. We have rewritten them to use corresponding `import` statements. We also added code to calculate the\u00a0`__filename` and `__dirname` variables, but presented a little differently. To support this, add a new module,\u00a0`approotdir.mjs`, containing the following:\n\n```", "```js\\1\n\nThis should look familiar to the `app.js`\u00a0code we used in the previous chapter. Instead of inline functions, however, they're pushed into `appsupport.mjs`.\n\nThe `app` and `port` objects are exported in case some other code in the application needs those values.\n\nThis section of code creates and configures the Express application instance. To make it a complete running server, we need the following code:\n\n```", "```js\\1\n\nThis function handles safely converting a port number string that we might be given into a numerical value that can be used in the application. The `isNaN` test is used to handle cases where instead of a TCP port number, we want to use a\u00a0**named pipe**. Look carefully at the other functions and you'll see that they all accommodate either a numerical port number or a string described as a pipe:\n\n```", "```js\\1\n\nThe preceding code\u00a0prints a user-friendly message saying where the server is listening for HTTP connections. Because this function needs to reference the server object, we have imported it:\n\n```", "```js\\1\n\nThis defines two classes\u2014`Note`\u00a0and `AbstractNotesStore`\u2014whose purpose is as follows:\n\n*   The `Note` class describes a single note that our application will manage.\n*   The `AbstractNotesStore` class describes methods for managing some note instances.\n\nIn the `Note` class, `key` is how we look for the specific note, and `title` and `body` are the content of the note. It uses an important data hiding technique, which we'll discuss in a minute.\n\nThe `AbstractNotesStore` class documents the methods that we'll use for accessing notes from a data storage system. Since we want the `Notes` application to implement the CRUD paradigm, we have the `create`, `read`, `update`, and `destroy` methods, plus a couple more to assist in searching for notes. What we have here is an empty class that serves to document the API, and we will use this as the base class for several storage modules that we'll implement later.\n\nThe `close` method is meant to be used when we're done with a datastore. Some datastores keep an open connection to a server, such as a database server, and the `close` method should be used to close that connection.\n\nThis is defined with\u00a0`async`\u00a0functions because we'll store data in the filesystem or in databases. In either case, we need an asynchronous API.\n\nBefore implementing our first data storage model, let's talk about data hiding in JavaScript classes.\n\n### Data hiding in ES-2015 class definitions\n\nIn many programming languages, class definitions let us designate some data fields as private and others as public. This is so that programmers can hide implementation details. However, writing code on the Node.js platform is all about JavaScript, and JavaScript, in general, is very lax about everything. So, by default, fields in an instance of a JavaScript class are open to any code to access or modify.\n\nOne concern arises if you have several modules all adding fields or functions to the same object. How do you guarantee that one module won't step on fields added by another module? By default, in JavaScript, there is no such guarantee.\n\nAnother concern is hiding implementation details so that the class can be changed while knowing that internal changes won't break other code. By default, JavaScript fields are open to all other code, and there's no guarantee other code won't access fields that are meant to be private.\n\nThe technique used in the `Note` class gates access to the fields through getter and setter functions. These in turn set or get values stored in the instance of the class. By default, those values are visible to any code, and so these values could be modified in ways that are incompatible with the class. The best practice when designing classes is to localize all manipulation of class instance data to the member functions. However, JavaScript makes the fields visible to the world, making it difficult to follow this best practice. The pattern used in the `Note` class is the closest we can get in JavaScript to data hiding in a class instance.\n\nThe technique we use is to name the fields using instances of the `Symbol` class. `Symbol`, another ES-2015 feature, is an opaque object with some interesting attributes that make it attractive for use as keys for private fields in objects. Consider the following code:\n\n```", "```js\\1\n\nWe've created a little object, then used those `Symbol` instances as field keys to store data in the object. Notice that when we dump the object's contents, the two fields both register as `Symbol(b)`, but they are two separate fields.\n\nWith the `Note` class, we have used the\u00a0`Symbol` instances to provide a small measure of data hiding. The actual values of the `Symbol` instances are hidden inside `Notes.mjs`. This means the only code that can directly access the fields is the code running inside `Notes.mjs`:\n\n```", "```js\\1\n\nThis should be fairly self-explanatory. The notes are stored in a private array, named `notes`. The operations, in this case, are defined in terms of adding or removing items in that array. The `key`\u00a0object for each `Note` instance is used as the index to the `notes` array, which in turn holds the `Note` instance. This is simple, fast, and easy to implement. It does not support any long-term data persistence, and any data stored in this model will disappear when the server is killed.\n\nWe need to initialize an instance of `NotesStore` so that it can be used in the application. Let's add the following to `app.mjs`, somewhere near the top:\n\n```", "```js\\1\n\nIn `app.mjs`, we configured the Handlebars template engine to use the `partials` directory to hold partial files. Therefore, make sure you create that directory.\n\nTo implement the home page, update\u00a0`routes/index.mjs` to the following:\n\n```", "```js\\1\n\nThis has the advantage of being simple to read since it's a simple `for` loop. The problem is that this loop reads the notes one at a time. It's possible that reading the notes in parallel is more efficient since there's an opportunity to interweave the processing.\n\nThe `Promise.all` function executes an array of Promises in parallel, rather than one at a time. The `keyPromises` variable ends up being an array of Promises, each of which is executing `notes.read` to retrieve a single note.\n\nThe `map` function in the arrays converts (or maps) the values of an input array to produce an output array with different values. The output array has the same length as the input array, and the entries are a one-to-one mapping of the input value to an output value. In this case, we map the keys in `keylist`\u00a0to a Promise that's waiting on a function that is reading each note. Then,\u00a0`Promise.all` waits for all the Promises to resolve into either success or failure states.\n\nThe output array,\u00a0`notelist`, will be filled with the notes once all the Promises succeed. If any Promises fail, they are rejected\u2014in other words, an exception will be thrown instead.\u00a0\n\nThe `notelist` array is then passed into the\u00a0`view` template that we're about to write.\n\nBut first, we need a page layout template. Create a file,\u00a0`views/layout.hbs`, containing the following:\n\n```", "```js\\1\n\nThis simply looks for a variable, `title`, which should have the page title. It also outputs a navigation bar containing a pair of links\u2014one to the home page and another to `/notes/add`, where the user will be able to add a new note.\n\nNow, let's rewrite\u00a0`views/index.hbs` to this:\n\n```", "```js\\1\n\nIf we visit `http://localhost:3000`, we will see the following page:\n\n![](img/a8c5968a-4dc8-4cc1-8d62-7139b3d63084.png)\n\nBecause there aren't any notes (yet), there's nothing to show. Clicking on the Home link just refreshes the page. Clicking on the ADD Note link throws an error because we haven't (yet) implemented that code. This shows that the provided error handler in `app.mjs` is performing as expected.\n\nHaving implemented the home page, we need to implement the various pages of the application. We will start with the page for creating new notes, and then we will implement the rest of the CRUD support.\n\n## Adding a new note \u2013 create\n\nIf we click on the ADD Note link, we get an error because the application doesn't have a route configured for the `/notes/add` URL; we need to add one. To do that, we need a controller module for the notes that defines all the pages for managing notes in the application.\n\nIn\u00a0`app.mjs`, uncomment the two lines dealing with\u00a0`notesRouter`:\n\n```", "```js\\1\n\nThis handles the\u00a0`/notes/add` URL corresponding to the link in `partials/header.hbs`. It simply renders a template, `noteedit`, using the provided data.\n\nIn the `views` directory, add the corresponding template, named `noteedit.hbs`, containing the following:\n\n```", "```js\\1\n\nBy normal coding practices, this looks alright, right? It's nicely indented, with the code arranged for easy reading. The problem is that extra whitespace ends up being included in the `body` value when the form is submitted to the server. That extra whitespace is added because of the nicely indented code. To avoid that extra whitespace, we need to use the angle brackets in the HTML elements that are directly adjacent to the Handlebars code to insert the value. Similar care must be taken with the elements with the\u00a0`value=` attributes, ensuring no extra whitespace is within the `value` string.\n\nThis template is a form that will post\u00a0its data to the `/notes/save` URL. If you were to run the application now, it would give you an error message because no route is configured for that URL.\n\nTo support the `/notes/save` URL, add it to `routes/notes.mjs`:\n\n```", "```js\\1\n\nBecause this route is mounted on a router handling,\u00a0`/notes`, this route handles\u00a0`/notes/view`.\n\nThe handler simply calls\u00a0`notes.read`\u00a0to read the note. If successful, the note is rendered with the `noteview` template. If something goes wrong, we'll instead display an error to the user through Express.\n\nAdd the `noteview.hbs` template to the\u00a0`views`\u00a0directory, referenced by the following code:\n\n```", "```js\\1\n\nThis handles the `/notes/edit` URL.\n\nWe're reusing the `noteedit.hbs` template because it can be used for both the\u00a0`create` and `update`/`edit` operations. Notice that we pass\u00a0`false` for `docreate`, informing the template that it is to be used for editing.\n\nIn this case, we first retrieve the `note` object and then pass it through to the template. This way, the template is set up for editing, rather than note creation. When the user clicks on the Submit button, we end up in the same `/notes/save` route handler shown in the preceding screenshot. It already does the right thing\u2014calling the `notes.update` method in the model, rather than `notes.create`.\n\nBecause that's all we need to do, we can go ahead and rerun the application:\n\n![](img/56c80c0d-b6d3-4c54-9a39-9aec3e3b5505.png)\n\nClick on the Submit button here and you will be redirected to the `/notes/view` screen, where you will then be able to read the newly edited note. Back at the `/notes/view` screen, we've just taken care of the Edit link, but the Delete link still produces an error.\n\nTherefore, we next need to implement a page for deleting notes.\n\n## Deleting notes \u2013 destroy\n\nNow, let's look at how to implement the `/notes/destroy` URL to delete notes.\n\n\u00a0Add the following router function to\u00a0`routes/notes.mjs`:\n\n```", "```js\\1\n\nThis is a simple form that asks the user to confirm by clicking on the button. The Cancel link just sends them back to the `/notes/view` page. Clicking on the Submit button generates a `POST` request on the `/notes/destroy/confirm` URL.\n\nThis URL needs a request handler. Add the following code to `routes/notes.mjs`:\n\n```", "```js\\1\n\nThis is due to the following line of code, which we put into\u00a0`layout.hbs`:\n\n```", "```js\\1\n\nTherefore, the CSS stylesheet is at\u00a0`public/stylesheets/style.css`, so let's open it and take a look:\n\n```", "```js\\1\n\nThis changes the padding and also adds a gray box around the header area.\n\nAs a result, we'll have the following:\n\n![](img/364a8470-5ce3-4008-941b-d641cd2e2135.png)\n\nWe're not going to win any design awards with this either, but there's the beginning of some branding and theming possibilities. More importantly, it proves that we can make edits to the theming.\n\nGenerally speaking, through the way that we've structured the page templates, applying a\u00a0site-wide theme is just a matter of adding appropriate code to `layout.hbs`, along with appropriate stylesheets and other assets.\n\nIn\u00a0[Chapter 6](db8b0ab8-181f-4d8d-9088-a9962ec461b8.xhtml),\u00a0*Implementing the Mobile-First Paradigm*, we will look at a simple method to add these frontend libraries to your application.\n\nBefore closing out this chapter, we want to think ahead to scaling the application to handle multiple users.\n\n# Scaling up \u2013 running multiple Notes instances\n\nNow that we've got ourselves a running application, you'll have played around a bit and created, read, updated, and deleted many notes.\n\nSuppose for a moment that this isn't a toy application, but one that is interesting enough to draw millions of users a day. Serving a high load typically means adding servers, load balancers, and many other things. A core part of this is to have multiple instances of the application running at the same time to spread the load.\n\nLet's see what happens when you run multiple instances of the `Notes` application at the same time.\n\nThe first thing is to make sure the instances are on different ports. In `app.mjs`, you'll see that setting the `PORT` environment variable controls the port being used.\u00a0If the `PORT` variable is not set, it defaults to `http://localhost:3000`, or what we've been using all along.\n\nLet's open up `package.json` and add the following lines to the `scripts` section:\n\n```", "```js\\1\n\nIn another command window, run the following:\n\n```"]