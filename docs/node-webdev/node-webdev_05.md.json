["```js\\1\n\nThis should look familiar to anyone who's implemented a class definition in other languages. The class has a name\u2014`Note`. There is also a constructor method and attributes for each instance of the class.\n\nOnce you've defined the class, you can export the class definition to other modules:\n\n```", "```js\\1\n\nNew instances of a class are created with\u00a0`new`. You access a getter or setter function as if it is a simple field on the object. Behind the scenes, the getter/setter function is invoked.\n\nThe preceding implementation is not the best because the `_title` and `_body`\u00a0fields\u00a0are publicly visible and there is no data-hiding or encapsulation. There is a technique to better hide the field data, which we'll go over in [Chapter 5](582d3898-0135-430c-8b6e-8326f287e18b.xhtml),\u00a0*Your First Express Application*.\n\nYou can test whether a given object is of a certain class by using the `instanceof` operator:\n\n```", "```js\\1\n\nIn other words, the `LoveNote` class has all the fields of `Note`, plus a new field named `heart`.\n\nThis was a brief introduction to JavaScript classes. By the end of this book, you'll have had lots of practice with this feature. The `EventEmitter` class gives us a practical use for classes and class inheritance.\n\n## The EventEmitter class\n\nThe `EventEmitter` object is defined in the `events` module of Node.js. Using the `EventEmitter` class directly means performing `require('events')`. In most cases, we don't do this. Instead, our typical use of `EventEmitter` objects is via\u00a0an existing object that uses `EventEmitter` internally.\u00a0However, there are some cases where needs dictate implementing an\u00a0`EventEmitter`\u00a0subclass.\n\nCreate a file named `pulser.mjs`, containing the following code:\n\n```", "```js\\1\n\nWhat's different is the\u00a0assignment of\u00a0`this`\u00a0to\u00a0`self`. The value of `this` inside the function is different\u2014it is related to the `setInterval` function\u2014but the value of `self` remains the same in every enclosed scope. You'll see this trick used widely, so remember this in case you come across this pattern in code that you're maintaining.\n\nIf you want to use a simple `EventEmitter` object but with your own class name, the body of the extended class can be empty:\n\n```", "```js\\1\n\nHere, we create a `Pulser` object and consume its `pulse` events. Calling `pulser.on('pulse')` sets up an event listener for the `pulse` events to invoke the callback function. It then calls the `start` method to get the process going.\n\nWhen it is run, you should\u00a0see the following output:\n\n```", "```js\\1\n\nWhen the program receives the event, the data appears as arguments to the callback function. Your program listens to this event, as follows:\n\n```", "```js\\1\n\nHere, we created an HTTP `server` object, then attached a listener to the `request` event, and then told the server to listen to connections from `localhost` (`127.0.0.1`) on port `8124`.\u00a0The\u00a0`listen`\u00a0function causes the server to start listening and arranges to dispatch an event for every request arriving from a web browser.\n\nThe `request` event is fired any time an HTTP request arrives on the server. It takes a function that receives the\u00a0`request` and `response` objects. The `request` object has data from the web browser, while the `response` object is used to gather data to be sent in the response.\u00a0\n\nNow, let's look at a server application that performs different actions based on the URL.\n\nCreate a new file named `server.mjs`, containing the following code:\n\n```", "```js\\1\n\nThen, if we paste the URL into a web browser, we see something like this:\n\n![](img/1a594a70-7504-4f7b-81ce-e8bd939911e2.png)\n\nThis application is meant to be similar to PHP's\u00a0`sysinfo`\u00a0function. Node.js's\u00a0`os`\u00a0module is consulted to provide information about the computer. This example can easily be extended to gather other pieces of data.\n\nA central part of any web application is the method of routing requests to request handlers. The `request` object has several pieces of data attached to it, two of which are useful for routing requests: the `request.url` and `request.method` fields.\n\nIn `server.mjs`, we consult the `request.url` data to determine which page to show after parsing using the URL object. Our needs are modest in this server, and a simple comparison of the `pathname` field is enough.\u00a0Larger applications will use pattern matching to use part of the request URL to select the request handler function and other parts to extract request data out of the URL. We'll see this in action when we look at Express later in the\u00a0*Getting started with Express*\u00a0section.\n\nSome web applications care about the HTTP verb that is used\u00a0(`GET`,\u00a0`DELETE`,\u00a0`POST`, and so on)\u00a0and so we must consult the `request.method` field of the `request` object. For example, `POST` is frequently used for any\u00a0`FORM` submissions.\n\nThat gives us a taste of developing servers with Node.js. Along the way, we breezed past one big ES2015 feature\u2014template strings. The template strings feature simplifies substituting values into strings. Let's see how that works.\n\n## ES2015 multiline and template strings\n\nThe previous example showed two of the new features introduced with ES2015: multiline and template strings. These features are meant to simplify our lives when creating text strings.\n\nThe existing JavaScript string representations use single quotes and double quotes. Template strings are delimited with the backtick character, which is also known as the **grave accent**:\n\n```", "```js\\1\n\nThis is an array of strings that uses the `join` function to smash them together into one string. Yes, this is the code used in the same example in previous versions of this book. This is what we can do with ES2015:\n\n```", "```js\\1\n\nSimilar to the previous snippet, this relied on the `replace` function to insert values into the string. Again, this is extracted from the same example that was used in previous versions of this book. With template strings, this can be written as follows:\n\n```", "```js\\1\n\nThe key here is the `sniffOn` function. When given an `HTTPServer` object, it attaches listener functions to each `HTTPServer` event to print relevant data. This gives us a fairly detailed trace of the HTTP traffic on an application.\n\nIn order to use it, make two simple modifications to\u00a0`server.mjs`. To the top, add the following `import` statement:\n\n```", "```js\\1\n\nHere, we're importing the `sniffOn` function and then using it to attach listener methods to the `server` object.\n\nWith this in place, run the server as we did earlier. You can visit `http://localhost:8124/` in your browser and see the following console output:\n\n```", "```js\\1\n\nThis is different from the suggested installation method on the Express website, which says to use the `-g` tag for a global installation. We're also using an explicit version number to ensure compatibility. As of the time of writing,\u00a0`express-generator@5.x` does not exist, but it should exist sometime in the future. The instructions here are written for Express 4.x, and by explicitly naming the version, we're ensuring that we're all on the same page.\n\nEarlier, we discussed how many people now recommend against installing modules globally. Maybe they would consider\u00a0`express-generator` as an exception to that rule, or maybe not. In any case, we're not following the recommendation on the Express website, and toward the end of this section, we'll have to uninstall `express-generator`.\n\nThe result of this is that an `express` command is installed in the `./node_modules/.bin` directory:\n\n```", "```js\\1\n\nWe probably don't want to type `./node_modules/.bin/express` every time we run the `express-generator` application, or, for that matter, any of the other applications that provide command-line utilities. Refer back to the discussion we had in\u00a0[Chapter 3](516a5cd0-bdae-4e8c-bb0a-d508f85d483a.xhtml), *Exploring Node.js Modules*, about adding this directory to the `PATH`\u00a0variable. Alternatively, the `npx` command, also\u00a0described\u00a0in [Chapter 3](516a5cd0-bdae-4e8c-bb0a-d508f85d483a.xhtml), *Exploring Node.js Modules*, is useful for this.\n\nFor example, try using the following instead of installing `express-generator`:\n\n```", "```js\\1\n\nThis creates a bunch of files for us, which we'll walk through in a minute. We asked it to initialize the use of the Handlebars template engine and to initialize a `git` repository.\u00a0\n\nThe `node_modules` directory still has the `express-generator` module, which is no longer useful. We can just leave it there and ignore it, or we can add it to `devDependencies` of\u00a0the `package.json`\u00a0file that it generated. Most likely, we will want to uninstall it:\n\n```", "```js\\1\n\nIt's cool that the Express team showed us how to run the server by initializing the `scripts`\u00a0section in `package.json`. The `start` script is one of the scripts that correspond to the `npm` sub-commands. The instructions we were given, therefore, say to run `npm start`.\n\nThe steps\u00a0are as follows:\n\n1.  Install the dependencies with\u00a0`npm install`.\n2.  Start the application by using\u00a0`npm start`.\n3.  Optionally, modify\u00a0`package.json` to always run with debugging.\n\nTo install the dependencies and run the application, type the following commands:\n\n```", "```js\\1\n\nSince the output says it is listening on port `3000`, we direct our browser to\n`http://localhost:3000/` and see the following output:\n\n![](img/2a2b1a0f-a6e2-43da-9945-8a49e19b8dbf.png)\n\nCool, we have some running code. Before we start changing the code, we need to discuss how to set environment variables in Windows.\n\n## Setting environment variables in the Windows cmd.exe command line\n\nIf you're using Windows, the previous example may have failed, displaying an error that says `DEBUG` is not a known command. The problem is that the Windows shell, the `cmd.exe` program, does not support the Bash command-line structure.\n\nAdding `VARIABLE=value` to the beginning of a command line is specific to some shells, such as Bash, on Linux and macOS. It sets that environment variable only for the command line that is being executed and is a very convenient way to temporarily override environment variables for a specific command.\n\nClearly, a solution is required if you want to be able to use your `package.json`\u00a0file across different operating systems.\n\nThe best solution appears to be using the `cross-env` package in the `npm` repository; refer to\u00a0[https://www.npmjs.com/package/cross-env](https://www.npmjs.com/package/cross-env)\u00a0for more information.\n\nWith this package installed, commands in the\u00a0`scripts` section in `package.json`\u00a0can set environment variables just as in Bash on Linux/macOS. The use of this package looks as follows:\n\n```", "```js\\1\n\nWe now have a simple way to ensure the scripts in `package.json` are cross-platform. Our next step is a quick walkthrough of the generated application.\n\n## Walking through the default Express application\n\nWe now have a working, blank Express application; let's look at what was generated for us. We do this to familiarize ourselves with Express before diving in to start coding our **Fibonacci** application.\n\nBecause we used the `--view=hbs`\u00a0option, this application is set up to use the Handlebars.js template engine.\u00a0\n\nFor more information about Handlebars.js, refer to its home page at\u00a0[http://handlebarsjs.com/](http://handlebarsjs.com/). The version shown here has been packaged for use with Express and is documented at\u00a0[https://github.com/pillarjs/hbs](https://github.com/pillarjs/hbs).\u00a0\n\nGenerally speaking, a template engine makes it possible to insert data into generated web pages. The Express.js wiki has a list of template engines for Express ([https://github.com/expressjs/express/wiki#template-engines](https://github.com/expressjs/express/wiki#template-engines)).\n\nNotice that the JavaScript files are generated as CommonJS modules. The `views` directory contains two files\u2014`error.hbs`\u00a0and `index.hbs`. The `hbs` extension is used for Handlebars files. Another file, `layout.hbs`, is the default page layout. Handlebars has several ways to configure layout templates and even partials (snippets of code that can be included anywhere).\n\nThe `routes` directory contains the initial routing setup\u2014that is, code to handle specific URLs. We'll modify this later.\n\nThe `public` directory contains assets that the application doesn't generate but are simply sent to the browser. What's initially installed is a CSS file, `public/stylesheets/style.css`. The `package.json` file contains our dependencies and other metadata.\n\nThe `bin` directory contains the `www` script that we saw earlier. This is a Node.js script that initializes the `HTTPServer` objects, starts listening on a TCP port, and calls the last file that we'll discuss, `app.js`. These scripts initialize Express and hook up the routing modules, as well as other things.\n\nThere's a lot going on in the `www` and `app.js` scripts, so let's start with the application initialization. Let's first take a look at a couple of lines in `app.js`:\n\n```", "```js\\1\n\nThis is a Unix/Linux technique to make a command script. It says to run the following as a script using the `node` command. In other words, we have Node.js code and we're instructing the operating system to execute that code using the Node.js runtime:\n\n```", "```js\\1\n\nNamely, it loads the module in `app.js`, gives it a port number to use, creates the `HTTPServer` object, and starts it up.\n\nWe can see where port `3000` comes from; it's a parameter to the `normalizePort` function. We can also see that setting the `PORT` environment variable will override the default port `3000`. Finally, we can see that the `HTTPServer` object is created here and is told to use the application instance created in `app.js`. Try running the following command:\n\n```", "```js\\1\n\nThis tells Express to look for templates in the `views` directory and to use the Handlebars templating engine.\n\nThe `app.set` function is used to set the application properties. It'll be useful to browse the API documentation as we go through ([http://expressjs.com/en/4x/api.html](http://expressjs.com/en/4x/api.html)).\n\nNext is a series of `app.use` calls:\n\n```", "```js\\1\n\nThe comment says `catch 404 and forward it to the error handler`. As you probably know, an HTTP `404` status means the requested resource was not found. We need to tell the user that their request wasn't satisfied, and maybe show them something such as a picture of a flock of birds pulling a whale out of the ocean. This is the first step in doing this. Before getting to the last step of reporting this error, you need to learn how middleware works.\n\nThe name\u00a0*middleware*\u00a0implies software that executes in the middle of a chain of processing steps.\n\nRefer to the documentation about middleware at [http://expressjs.com/en/guide/writing-middleware.html](http://expressjs.com/en/guide/writing-middleware.html).\n\nMiddleware functions take three arguments. The first two\u2014`request` and `response`\u2014are equivalent to the `request` and `response`\u00a0objects of the Node.js HTTP request object. Express expands these objects with additional data and capabilities. The last argument, `next`, is a callback function that controls when the request-response cycle ends, and it can be used to send errors down the middleware pipeline.\n\nAs an aside, one critique of Express is that it was written prior to the existence of Promises and async functions. Therefore, its design is fully enmeshed with the callback function pattern. We can still use async functions, but integrating with Express requires using the callback functions it provides.\n\nThe overall architecture is set up so that incoming requests are handled by zero or more middleware functions, followed by a router function, which sends the response. The middleware functions call `next`, and in a normal case, provide no arguments by calling `next()`. If there is an error, the middleware function indicates the error by calling `next(err)`, as shown here.\n\nFor each middleware function that executes, there is, in theory, several other middleware functions that have already been executed, and potentially several other functions still to be run. It is required to call `next` to pass control to the next middleware function.\n\nWhat happens if `next` is not called? There is one case where we must not call `next`. In all other cases, if `next` is not called, the HTTP request will hang because no response will be given.\u00a0\n\nWhat is the one case where we must not call `next`? Consider the following hypothetical router\u00a0function:\n\n```", "```js\\1\n\nThis path specification has a pattern,\u00a0`id`, and the value will land in `req.params.id`. In an Express route, this `:id` pattern marks a\u00a0**route parameter**. The pattern will match a URL segment, and the matching URL content will land and be available through the `req.params` object. In this example, we're suggesting a user profile service and that for this URL, we want to display information about the named user.\n\nAs Express scans the available functions to execute, it will try to match this pattern against the request URL. If they match, then the router function is invoked.\n\nIt is also possible to match based on the HTTP request method, such as `GET` or `PUT`. Instead of `app.use`, we would write `app.METHOD`\u2014for example,\u00a0`app.get` or `app.put`. The preceding example would, therefore, be more likely to appear as follows:\n\n```", "```js\\1\n\nWe have a module that\u00a0creates a `router` object, then adds one or more `router` functions.\u00a0It makes the `Router` object available through\u00a0`module.exports` so that `app.js` can use it. This router has only one route, but `router` objects can have any number of routes that you think is appropriate.\n\nThis one route matches a `GET` request on the `/`\u00a0URL. That's fine until you notice that in `routes/index.js`, there is a similar `router` function that also matches `GET` requests on the `/`\u00a0URL.\n\nBack in `app.js`, `usersRouter` is added, as follows:\n\n```", "```js\\1\n\nError handler functions take four parameters, with `err` added to the familiar `req`, `res`, and `next`\u00a0functions.\n\nRemember that `res` is the response object, and we use it to set up the HTTP response sent to the browser; even though there is an error, we still send a response.\n\nUsing\u00a0`res.status`\u00a0sets the HTTP response status code. In the simple application that we examined earlier, we used `res.writeHead` to set\u00a0not only\u00a0the status code but also the\u00a0**Multipurpose Internet Mail Extensions**\u00a0(**MIME**)\u00a0type of the response.\n\nThe `res.render` function takes data and renders it through a template. In this case, we're using the template named `error`. This corresponds to the `views/error.hbs`\u00a0file,\u00a0which looks as follows:\n\n```", "```js\\1\n\nThis is a route handler, and going by what we've said, it simply generates an error indication. In a real route handler, the code would make some kind of query, gathering up data to show to the user, and it would indicate an error only if something happened along the way. However, we want to see the error handler in action.\n\nBy calling `next(err)`, as mentioned, Express will call the error handler function, causing an error response to pop up in the browser:\n\n![](img/f918cdd1-1894-448d-afbb-f385f8d2bb2a.png)\n\nIndeed, at the `/error` URL, we get the\u00a0Fake error message, which matches the error data sent by the route handler function.\n\nIn this section, we've created for ourselves a foundation for how Express works. Let's now turn to an Express application that actually performs a function.\n\n# Creating an Express application to compute Fibonacci numbers\n\nAs we discussed in [Chapter 1](3cd3b221-f9a7-47f2-9159-203c0130088e.xhtml), *About Node.js* we'll be using an inefficient algorithm to calculate Fibonacci numbers to explore how to mitigate performance problems, and along the way, we'll learn how to build a simple REST service to offload computation to the backend server.\n\nThe Fibonacci numbers are the following integer sequence:\n\n*0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\u00a0*\n\nEach Fibonacci number is the sum of the previous two numbers in the sequence. This sequence was discovered in 1202 by Leonardo of Pisa, who was also known as Fibonacci. One method to calculate entries in the Fibonacci sequence is using the recursive algorithm, which we discussed in [Chapter 1](3cd3b221-f9a7-47f2-9159-203c0130088e.xhtml),\u00a0*About Node.js*. We will create an Express application that uses the Fibonacci implementation and along the way, we will get a better understanding of Express applications, as well as explore several methods to mitigate performance problems in computationally intensive algorithms.\n\nLet's start with the blank application we created in the previous step. We named that application `Fibonacci` for a reason\u2014we were thinking ahead!\n\nIn `app.js`, make the following changes to the top portion of the file:\n\n```", "```js\\1\n\nIn the `views` directory, look at the file named `layout.hbs`, which was created by\u00a0`express-generator`:\n\n```", "```js\\1\n\nThis serves as the front page of our application. It will be inserted in place of\u00a0`{{{body}}}` in `views/layout.hbs`. The marker, `{{> navbar}}`, refers to a partially named `navbar`\u00a0object. Earlier, we configured a directory named `partials`\u00a0to hold partials. Now, let's create a file, `partials/navbar.html`, containing the following:\n\n```", "```js\\1\n\nIf `fiboval` is set, this renders a message that for a given number (`fibonum`), we have calculated the corresponding Fibonacci number.\u00a0There is also an HTML form that we can use to enter a `fibonum`\u00a0value.\n\nBecause it is a\u00a0`GET`\u00a0form, when the user clicks on the\u00a0Submit\u00a0button, the browser will issue an HTTP\u00a0`GET`\u00a0method to the\u00a0`/fibonacci`\u00a0URL. What distinguishes one\u00a0`GET`\u00a0method on\u00a0`/fibonacci`\u00a0from another is whether the\u00a0URL\u00a0contains a query parameter named\u00a0`fibonum`. When the user first enters the page, there is no\u00a0`fibonum`\u00a0number and so there is nothing to calculate. After the user has entered a number and clicked on\u00a0Submit, there is a\u00a0`fibonum`\u00a0number and so\u00a0something\u00a0to calculate.\n\nRemember that the files in\u00a0`views`\u00a0are templates into which data is rendered. They serve the **v****iew**aspect of the\u00a0**Model-View-Controller** (**MVC**)\u00a0paradigm, hence the directory name.\n\nIn `routes/index.js`, change the `router` function to the following:\n\n```", "```js\\1\n\nThis route handler says it matches the `/`\u00a0route. However, there is a route handler in `index.js` that matches the same route. We haven't made a mistake, however. The `router` object created by this module becomes\u00a0`fibonacciRouter`\u00a0when it lands in `app.js`. Refer back to `app.js` and you will see that\u00a0`fibonacciRouter` is mounted on `/fibonacci`. The rule is that the actual URL path matched by a router function is the path that the router is mounted on plus the path given for the router function. In this case, that is `/fibonacci`\u00a0plus `/`, and\u00a0for a URL, that equates to `/fibonacci`.\u00a0\n\nThe handler checks for the existence of `req.query.fibonum`. Express automatically parses the HTTP request URL and any query parameters will land in `req.query`. Therefore, this will trigger a URL such as\u00a0`/fibonacci?fibonum=5`.\n\nIf this value is present, then we call `res.render('fibonacci')` with data including `fibonum`, the number for which we want its Fibonacci number, and `fiboval`, the corresponding Fibonacci number. Otherwise, we pass `undefined` for `fiboval`. If you refer back to the template, if `fiboval` is not set, then the user only sees the form to enter a `fibonum`\u00a0number. Otherwise, if `fiboval` is set, both `fibonum` and `fiboval` are displayed.\n\nThe `package.json`\u00a0file is already set up, so we can use `npm start` to run the script and always have debugging messages enabled. Now, we're ready to do this:\n\n```", "```js\\1\n\nNow, run it. You will get the following output:\n\n```", "```js\\1\n\nIf we substitute a call to `math.fibonacciLoop` in place of `math.fibonacci`, the `fibotimes` program runs much faster. Even this isn't the most efficient implementation; for example, a simple, prewired lookup table is much faster at the cost of some memory.\n\nEdit `fibotimes.js` as follows and rerun the script. The numbers will fly by so fast that your head will spin:\n\n```", "```js\\1\n\nThis converts the `fibonacci` function from a synchronous function into a traditional callback-oriented asynchronous function. We're using `setImmediate`\u00a0at each stage of the calculation to ensure that the event loop executes regularly and that the server can easily handle other requests while churning away on a calculation. It does nothing to reduce the computation required; this is still the inefficient Fibonacci algorithm. All we've done is spread the computation through the event loop.\n\nIn `fibotimes.js`, we can use the following:\n\n```", "```js\\1\n\nThis is the same code as earlier, just rewritten for an asynchronous Fibonacci calculation. The Fibonacci number is returned via a callback function, and even though we have the beginnings of a callback pyramid, it is still manageable.\n\nIn `app.js`, make the following change to the application wiring:\n\n```", "```js\\1\n\nWe invoke an HTTP request by using `http.request`, passing in an `options` object describing the request. In this case, we're making a `GET` request to the server described in a URL we provide on the command line. When the response arrives, the `response` event is fired and we can print out the response. Likewise, an `error` event is fired on errors, and we can print out the error.\n\nThis corresponds to the HTTP protocol, where the client sends a request and receives a response.\n\nYou can run the script as follows:\n\n```", "```js\\1\n\nThe `response` object is itself an `EventEmitter`\u00a0object that emits the `data` and `error` events. The `data` event is called as data arrives and the `error` event is, of course, called on errors.\n\nThe `request` object is a `WritableStream`\u00a0object, which is useful for HTTP requests containing data, such as `PUT` or `POST`. This means the `request` object has a `write` function, which writes data to the requester. The data format in an HTTP request is specified by the standard MIME type, which was originally created to give us a better email service. Around 1992, the **World Wide Web** (**WWW**) community worked with the MIME standard committee, who were developing a format for multi-part, multi-media-rich electronic mail. Receiving fancy-looking email is so commonplace today that you might not be aware that email used to come in plaintext. MIME types were developed to describe the format of each piece of data, and the WWW community adopted this for use on the web. HTML forms will post with a content type of `multipart/form-data`, for example.\n\nThe next step in offloading some computation to a backend service is to implement the REST service and to make HTTP client requests to that service.\n\n# Calling a REST backend service from an Express application\n\nNow that we've seen how to make HTTP client requests, we can look at how to make a REST query within an Express web application. What that effectively means is making an HTTP\u00a0`GET`\u00a0request to a backend server, which responds to the Fibonacci number represented by the URL. To do so, we'll refactor the Fibonacci application to make a Fibonacci server that is called from the application. While this is overkill for calculating Fibonacci numbers, it lets us see the basics of implementing a multi-tier application stack in Express.\n\nInherently, calling a REST service is an asynchronous operation. That means calling the REST service will involve a function call to initiate the request and a callback function to receive the response. REST services are accessed over HTTP, so we'll\u00a0use the `HTTPClien`t object to do so. We'll start this little experiment by writing a REST server and exercising it by making calls to the service. Then, we'll refactor the Fibonacci service to call that server.\n\n## Implementing a simple REST server\u00a0with Express\n\nWhile Express can also be used to implement a simple REST service, the parameterized URLs we showed earlier (`/user/profile/:id`) can act like parameters to a REST call. Express makes it easy to return data encoded\u00a0in JSON format.\n\nNow, create a file named `fiboserver.js`, containing the following code:\n\n```", "```js\\1\n\nThis automates launching our Fibonacci service.\n\nNote that we're specifying the TCP/IP port via an environment variable and using that variable in the application. Some suggest that putting configuration data in the environment variable is the best practice.\n\nNow, let's run it:\n\n```", "```js\\1\n\nOver in the window where the service is running, we'll see a log of `GET` requests and how long each request took to process:\n\n```", "```js\\1\n\nThis is our good friend `http.request` with a suitable `options` object. We're executing it in a loop, so pay attention to the order that the requests are made versus the order the responses arrive.\n\nThen, in `package.json`, add the following to the `scripts` section:\n\n```", "```js\\1\n\nWe're building our way toward adding the REST service to the web application. At this point, we've proved several things, one of which is the ability to call a\u00a0REST service in our program.\n\nWe also inadvertently demonstrated an issue with long-running calculations. You'll notice that the requests were made from the largest to the smallest, but the results appeared in a very different order. Why? This is because of the processing time required for each request, and the inefficient algorithm we're using. The computation time increases enough to ensure that larger request values have enough processing time\u00a0to reverse the order.\n\nWhat happens is that `fiboclient.js` sends all of its requests right away, and then each one waits for the response to arrive. Because the server is using `fibonacciAsync`, it will work on calculating all the responses simultaneously. The values that are quickest to calculate are the ones that will be ready first. As the responses arrive in the client, the matching response handler fires, and in this case, the result prints to the console. The results will arrive when they're ready, and\u00a0not a millisecond sooner.\n\nWe now have enough on our hands to offload Fibonacci calculation to a backend service.\n\n## Refactoring the Fibonacci application to call the REST service\n\nNow that we've implemented a REST-based server, we can return to the Fibonacci application, applying what we've learned to improve it. We will lift some of the code from `fiboclient.js` and transplant it into the application to do this. Create a new file,\u00a0`routes/fibonacci-rest.js`, with the following code:\n\n```", "```js\\1\n\nThis, of course, reconfigures it to use the new route handler. Then, in `package.json`, change the `scripts` entry to the following:\n\n```", "```js\\1\n\nThe output looks like this for the application:\n\n```"]