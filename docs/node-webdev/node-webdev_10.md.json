["```js\\1\n\nThis gets us ready to start coding. We'll use the `debug` module for logging messages, `js-yaml` to read the Sequelize configuration file, `restify` for its REST framework, and `sequelize/sqlite3` for database access.\n\nIn the sections to come, we will develop a database model to store user information, and then create a REST service to manage that data. To test the service, we'll create a command-line tool that uses the REST API.\n\n## Developing the user information model\n\nWe'll be storing the user information using a Sequelize-based model in a SQL database. We went through that process in the previous chapter, but we'll do it a little differently this time. Rather than go for the ultimate flexibility of using any kind of database, we'll stick with Sequelize since the user information model is very simple and a SQL database is perfectly adequate.\n\nThe project will contain two modules. In this section, we'll create `users-sequelize.mjs`, which will define the SQUser schema and a couple of utility functions. In the next section, we'll start on `user-server.mjs`, which contains the REST server implementation.\u00a0\n\nFirst, let's ponder an architectural preference. Just how much should we separate between the data model code interfacing with the database from the REST server code? In the previous chapter, we went for a clean abstraction with several implementations of the database storage layer. For a simple server such as this, the REST request handler functions could contain all database calls, with no abstraction layer. Which is the best approach? We don't have a hard rule to follow. For this server, we will have database code more tightly integrated to the router functions, with a few shared functions.\n\nCreate a new file named `users-sequelize.mjs` in `users`\u00a0containing the following code:\n\n```", "```js\\1\n\nIn Restify, the route handler functions supply the same sort of `request` and `response` objects we've already seen. We'll go over the configuration of the REST server in the next section. Suffice to say that REST parameters arrive in the request handlers as the `req.params` object, as shown in the preceding code block. This function simplifies the gathering of those parameters into a simple object that happens to match the SQUser schema, as shown in the following code block:\n\n```", "```js\\1\n\nThe pair of functions shown in the preceding code block\u00a0provides some database operations that are used several times in the `user-server.mjs` module.\u00a0\n\nIn `findOneUser`, we are looking up a single SQUser, and then returning a sanitized copy. In `createUser`, we gather the user parameters from the request object, create the SQUser object in the database, and then retrieve that newly created object to return it to the caller.\n\nIf you refer back to the `connectDB` function, there is a `SEQUELIZE_CONNECT` environment variable for the configuration file. Let's create one for SQLite3 that we can name `sequelize-sqlite.yaml`, as follows:\n\n```", "```js\\1\n\nThis declares that the module we're about to create,\u00a0`user-server.mjs`, is the main package of this project.\n\nMake sure the scripts section contains the following script:\n\n```", "```js\\1\n\nWe're using Restify, rather than Express, to develop this server. Obviously, the Restify API has similarities with Express, since both point to the Ruby framework Sinatra for inspiration. We'll see even more similarities when we talk about the route handler functions.\n\nWhat we have here is the core setup of the REST server. We created the server object\u00a0and added a few things that, in Express, were called\u00a0*middleware*, but what Restify simply refers to as\u00a0*handlers*.\u00a0A Restify handler function serves the same purpose as an Express middleware function. Both frameworks let you define a function chain to implement the features of your service. One calls it a\u00a0*middleware*\u00a0function and the other calls it a\u00a0*handler* function, but they're almost identical in form and function.\n\nWe also have a collection of listener functions that print a startup message and handle uncaught errors. You do remember that it's important to catch the uncaught errors?\n\nAn interesting thing is that, since REST services are often versioned, Restify has built-in support for handling version numbers. Restify supports **semantic versioning** (**SemVer**) version matching in the `Accept-Version` HTTP header.\u00a0\n\nIn the\u00a0*handlers* that were installed, they obviously have to do with authorization and parsing parameters from the **Uniform Resource Locator** (**URL**) query string and from the HTTP body. The handlers with names starting with `restify.plugins` are maintained by the Restify team, and documented on their website.\n\nThat leaves the handler simply named\u00a0*check*. This handler is in `user-server.mjs`\u00a0and provides a simple mechanism of token-based authentication for REST clients.\n\nAdd the following code to the bottom of `user-server.mjs`:\n\n```", "```js\\1\n\nThis shows the following three cases:\u00a0\n\n1.  Errors are indicated with\u00a0`next(new Error('Error description'))`.\n2.  Completion is indicated with\u00a0`next(false)`.\u00a0\n3.  The continuation of processing is indicated with\u00a0`next()`.\u00a0\n\nWe have created the starting point for a user information data model and the matching REST service. The next thing we need is a tool to test and administer the server.\n\nWhat we want to do in the following sections is two things. First, we'll create the REST handler functions to implement the REST API. At the same time, we'll create a command-line tool that will use the REST API and let us both test the server and add or delete users.\n\n### Creating a command-line tool to test and administer the user authentication server\n\nTo give ourselves assurance that the user authentication server works, let's write a tool with which to exercise the server that can also be used for administration. In a typical project, we'd create not only a customer-facing web user interface, but also an administrator-facing web application to administer the service. Instead of doing that here, we'll create a command-line tool.\n\nThe tool will be built with Commander, a popular framework for developing command-line tools in Node.js.\u00a0With Commander, we can easily build a **command-line interface** (**CLI**) tool supporting the `program verb --option optionValue parameter`\u00a0pattern.\n\nFor documentation on Commander, see\u00a0[https://www.npmjs.com/package/commander](https://www.npmjs.com/package/commander).\n\nAny command-line tool looks at the\u00a0`process.argv`\u00a0array to know what to do. This array contains strings parsed from what was given on the command line. The concept for all this goes way back to the earliest history of Unix and the C programming language.\u00a0\n\nFor documentation on the `process.argv` array, refer to\u00a0[https://nodejs.org/api/process.html#process_process_argv](https://nodejs.org/api/process.html#process_process_argv).\n\nBy using Commander, we have a simpler path of dealing with the command line. It uses a declarative approach to handling command-line parameters. This means we use Commander functions to declare the options and sub-commands to be used by this program, and then we ask Commander to parse the command line the user supplies. Commander then calls the functions we declare based on the content of the command line.\n\nCreate a file named `cli.mjs` containing the following code:\n\n```", "```js\\1\n\nThe\u00a0`process.argv`\u00a0variable is, of course, the command-line arguments split out into an array. Commander, then, is processing those arguments based on the options' declarations.\n\nFor the REST client, we use the `restify-clients` package. As the name implies, this is a companion package to Restify and is maintained by the Restify team.\n\nAt the top of this script, we declare a few variables to hold connection parameters. The goal is to create a connection URL to access the REST service. The `connect_url` variable is initialized with the default value, which is port `5858` on the localhost.\u00a0\n\nThe function named `client` looks at the information Commander parses from the command line, as well as a number of environment variables. From that data, it deduces any modification to the `connect_url` variable. The result is that we can connect to this service on any server from our laptop to a faraway cloud-hosted server.\n\nWe've also hardcoded the access token and the use of Basic Auth. Put on the backlog a high-priority task to change to a stricter form of authentication.\n\nWhere do the values of `program.port`, `program.host`, and `program.url` come from? We declared those variables\u2014that's where they came from.\n\nConsider the following line of code:\n\n```", "```js\\1\n\nThe text comes directly from the descriptive text we put in the declarations. Likewise, each of the sub-commands also takes a `--help` option to print out corresponding help text.\n\nWith all that out of the way, let's start creating these commands and REST functions.\n\n### Creating a user in the user information database\n\nWe have the starting point for the REST server, and the starting point for a command-line tool to administer the server. Let's start creating the functions\u2014and, of course, the best place to start is to create an SQUser object.\n\nIn `user-server.mjs`, add the following route handler:\n\n```", "```js\\1\n\nThis is a variation on creating an SQUser. While implementing login support in the Notes application, there was a scenario in which we had an authenticated user that may or may not already have an SQUser object in the database. In this case, we look to see whether the user already exists and, if not, then we create that user.\n\nLet's turn now to `cli.mjs` and implement the sub-commands to handle these two REST functions, as follows:\n\n```", "```js\\1\n\nThis is very similar, except for calling `/find-or-create`.\n\nWe have enough here to run the server and try the following two commands:\n\n```", "```js\\1\n\nOver in the server window, it will print a trace of the actions taken in response to this. But it's what we expect: the values we gave on the command line are in the database, as shown in the following code block:\n\n```", "```js\\1\n\nAnd, as expected, that was easy enough. For the `/find` URL, we need to supply the username in the URL. The code simply looks up the SQUser object using the existing utility function.\n\nA related function retrieves the SQUser objects for all users. Add the following code to `user-server.mjs`:\n\n```", "```js\\1\n\nThis is similarly easy. We pass the username provided on our command line in the `/find` URL and then print out the result. Likewise, for the `list-users` sub-command, we simply call `/list` on the server and print out the result.\n\nAfter restarting the server, we can test the commands,\u00a0as follows:\n\n```", "```js\\1\n\nThe caller is to provide the same set of user information parameters, which will be picked up by the `userParams` function. We then use the `update` function, as expected, and then retrieve the modified SQUser object, sanitize it, and send it as the result.\n\nTo match that function, add the following code to `cli.mjs`:\n\n```", "```js\\1\n\nAnd, indeed, we managed to change Snuffy's email address.\n\nThe next operation is to delete an SQUser object.\n\n### Deleting a user record from the user information service\n\nOur next operation will complete the **create, read, update, and delete** (**CRUD**) operations by letting us delete a user.\n\nAdd the following code to `user-server.mjs`:\n\n```", "```js\\1\n\nThis is simply to send a `DELETE` request to the server on the `/destroy` URL.\u00a0\n\nAnd then, to test it, run the following command:\n\n```", "```js\\1\n\nThis lets us support the checking of user passwords. There are three conditions to check, as follows:\n\n*   Whether there is no such user\n*   Whether the passwords matched\n*   Whether the passwords did not match\n\nThe code neatly determines all three conditions and returns an object indicating, via the `check` field, whether the user is authenticated. The caller is to send\u00a0`username` and\u00a0`password` parameters that will be checked.\n\nTo check it out, let's add the following code to `cli.mjs`:\n\n```", "```js\\1\n\nIndeed, the correct password gives us a\u00a0`true` indicator, while the wrong password gives us\u00a0`false`.\n\nWe've done a lot in this section by implementing a user information service. We successfully created a REST service while thinking about architectural choices around correctly handling sensitive user data. We were also able to verify that the REST service is functioning using an ad hoc testing tool. With this command-line tool, we can easily try any combination of parameters, and we can easily extend it if the need arises to add more REST operations.\n\nNow, we need to start on the real goal of the chapter: changing the Notes user interface to support login/logout. We will see how to do this in the following sections.\n\n# Providing login support for the Notes application\n\nNow that we have proved that the user authentication service is working, we can set up the Notes application to support user logins. We'll be using Passport to support login/logout, and the authentication server to store the required data.\n\nAmong the available packages, Passport stands out for simplicity and flexibility. It integrates directly with the Express middleware chain, and the Passport community has developed hundreds of so-called strategy modules to handle authentication against a long list of third-party services.\n\nRefer to\u00a0[http://www.passportjs.org/](http://www.passportjs.org/) for information and documentation.\n\nLet's start this by adding a module for accessing the user information REST server we just created.\n\n## Accessing the user authentication REST API\n\nThe first step is to create a user data model for the Notes application. Rather than retrieving data from data files or a database, it will use REST to query the server we just created. Recall that we created this REST service in the theory of walling off the service since it contains sensitive user information.\n\nEarlier, we suggested duplicating [Chapter 7](ae8529e5-3a08-45cc-89e9-82895eb45641.xhtml),\u00a0*Data Storage and Retrieval*, code for Notes in the\u00a0`chap08/notes`\u00a0directory and creating the user information server as `chap08/users`.\n\nEarlier in this chapter, we used the `restify-clients` module to access the REST service. That package is a companion to the Restify library; the\u00a0`restify`\u00a0package supports the server side of the REST protocol and\u00a0`restify-clients` supports the client side.\u00a0\n\nHowever nice the `restify-clients` library is, it doesn't support a Promise-oriented API, as is required to play well with `async` functions. Another library, SuperAgent, does support a Promise-oriented API and plays well in `async` functions, and there is a companion to that package, SuperTest, that's useful in unit testing. We'll use SuperTest in [Chapter 13](1c1eb7f2-8b1a-4f70-9f0a-94d865c739ef.xhtml), *Unit Testing and Functional Testing*\u00a0when we talk about unit testing.\n\nFor documentation, refer to\u00a0[https://www.npmjs.com/package/superagent](https://www.npmjs.com/package/superagent)\u00a0and\u00a0[http://visionmedia.github.io/superagent/](http://visionmedia.github.io/superagent/).\n\nTo install the package (again, in the Notes application directory), run the following command:\n\n```", "```js\\1\n\nThe `reqURL` function is similar in purpose to the `connectDB`\u00a0functions that we wrote in earlier modules. Remember that we used `connectDB` in earlier modules to open a database connection that will be kept open for a long time. With SuperAgent, we don't leave a connection open to the service. Instead, we open a new server connection on each request. For every request, we will formulate the request URL. The base URL, such as\u00a0`http://localhost:3333/`, is to be provided in the `USER_SERVICE_URL` environment variable. The `reqURL` function modifies that URL, using the new **Web Hypertext Application Technology Working Group** (**WHATWG**) URL support in Node.js, to use a given URL path.\n\nWe also added the authentication ID and code required for the server. Obviously, when the backlog task comes up to use a better token authentication system, this will have to change.\n\nTo handle creating and updating user records, run the following code:\n\n```", "```js\\1\n\nThis is following the same pattern as before. The `set` methods are, of course, used for setting HTTP headers in the REST call. This means having at least a passing knowledge of the HTTP protocol.\n\nThe `Content-Type` header says the data sent to the server is in **JavaScript Object Notation** (**JSON**) format. The `Accept` header says that this REST client can handle JSON data. JSON is, of course, easiest for a JavaScript program\u2014such as what we're writing\u2014to utilize.\n\nLet's now create the function for checking passwords, as follows:\n\n```", "```js\\1\n\nThe `/find-or-create` function either discovers the user in the database or creates a new user. The `profile` object will come from Passport, but take careful note of what we do with `profile.id`. The Passport documentation says it will provide the username in the `profile.id` field, but we want to store it as `username`\u00a0instead.\n\nLet's now create a function to retrieve the list of users, as follows:\n\n```", "```js\\1\n\nThe `passport` module gives us the authentication algorithms. To support different authentication mechanisms, the passport authors have developed several *strategy* implementations\u2014the authentication mechanisms, or strategies, corresponding to the various third-party services that support authentication, such as using OAuth to authenticate against services such as Facebook, Twitter, or GitHub.\n\nPassport also requires that we install Express Session support. Use the following command to install the modules:\n\n```", "```js\\1\n\nThis brings in the modules we need for the `/users` router. This includes the two `passport` modules and the REST-based user authentication model.\u00a0\n\nIn `app.mjs`, we will be adding\u00a0*session* support so our users can log in and log out. That relies on storing a cookie in the browser, and the cookie name is found in this variable exported from `app.mjs`. We'll be using that cookie in a moment.\n\nAdd the following functions to the end of `routes/users.mjs`:\n\n```", "```js\\1\n\nBecause this router is mounted on `/users`, all these routes will have `/user` prepended. The `/users/login` route simply shows a form requesting a username and password. When this form is submitted, we land in the second route declaration, with a `POST` on\u00a0`/users/login`. If `passport` deems this a successful login attempt using `LocalStrategy`, then the browser is redirected to the home page. Otherwise, it is redirected back to the\u00a0`/users/login` page.\n\nAdd the following route for handling logout:\n\n```", "```js\\1\n\nHere is where we define our implementation of `LocalStrategy`. In the callback function, we call `usersModel.userPasswordCheck`, which makes a REST call to the user authentication service. Remember that this performs the password check and then returns an object indicating whether the user is logged in.\n\nA successful login is indicated when `check.check` is `true`. In\u00a0this case, we tell Passport to use an object containing `username` in the session object. Otherwise,\u00a0we have two ways to tell Passport that the login attempt was unsuccessful. In one case, we use `done(null, false)` to indicate an error logging in, and pass along the error message we were given. In the other case, we'll have captured an exception, and pass along that exception.\n\nYou'll notice that Passport uses a callback-style API. Passport provides a `done` function, and we are to call that function when we know what's what. While we use an `async` function to make a clean asynchronous call to the backend service, Passport doesn't know how to grok the Promise that would be returned. Therefore, we have to throw a `try/catch` around the function body to catch any thrown exception.\n\nAdd the following functions to manipulate data stored in the session cookie:\n\n```", "```js\\1\n\nThe User router supports the `/login` and `/logout` URLs, as well as using Passport for authentication. We need to call `initPassport` for a little bit of initialization.\n\nAnd now, let's import modules for\u00a0session\u00a0handling, as follows:\n\n```", "```js\\1\n\nHere, we initialize the session support. The field named `secret` is used to sign the session ID cookie. The session cookie is an encoded string that is encrypted in part using this secret. In the Express Session documentation, they suggest the\u00a0`keyboard cat`\u00a0string for the secret. But, in theory, what if Express has a vulnerability, such that knowing this secret can make it easier to break the session logic on your site? Hence, we chose a different string for the secret, just to be a little different and\u2014perhaps\u2014a little more secure.\n\nSimilarly, the default cookie name used by `express-session` is `connect.sid`. Here's where we change the cookie name to a non-default name.\n\n`FileStore` will store its session data records in a directory named `sessions`. This directory will be auto-created as needed.\n\nIn case you see errors on Windows that are related to the files used by\u00a0`session-file-store`, there are several alternate session store packages that can be used.\u00a0 The attraction of\u00a0the `session-file-store`\u00a0is that it has no dependency on a service like a database server.\u00a0 Two other session stores have a similar advantage, `LokiStore`, and `MemoryStore`. Both are configured similarly to the\u00a0`session-file-store\u00a0package`. For example, to use `MemoryStore`, first use\u00a0npm\u00a0to install the\u00a0`memorystore`\u00a0package, then use these\u00a0 lines of code in\u00a0`app.mjs`:\n\n```", "```js\\1\n\nThese are the three routers that are used in the Notes application.\u00a0\n\n### Login/logout changes in routes/index.mjs\n\nThis router module handles the home page. It does not require the user to be logged in, but we want to change the display a little if they are logged in. To do so, run the following code:\n\n```", "```js\\1\n\nWe need to use the `ensureAuthenticated` function to protect certain routes from being used by users who are not logged in. Notice how ES6 modules let us import just the function(s) we require. Since that function is in the User router module, we need to import\u00a0it from there.\n\nModify the `/add` route handler,\u00a0as shown in the following code block:\n\n```", "```js\\1\n\nThe `/save` route only requires this change to call `ensureAuthenticated`\u00a0in order to ensure that the user is logged in.\n\nModify the `/view` route handler, as follows:\n\n```", "```js\\1\n\nRemember that throughout this module, we have made the following two changes to router functions:\n\n1.  We protected some routes using\u00a0`ensureAuthenticated`\u00a0to ensure that the route is available only to logged-in users.\n2.  We passed the\u00a0`user` object to the template.\n\nFor the routes using `ensureAuthenticated`, it is guaranteed that `req.user` will contain the `user` object.\u00a0 In other cases, such as with the `/view` router function, `req.user` may or may not have a value, and in case it does not, we make sure to pass `undefined`. In all such cases, the templates need to change in order to use the `user` object to detect whether the user is logged in, and whether to show HTML appropriate for a logged-in user.\n\n### Viewing template changes supporting login/logout\n\nSo far, we've created a backend user authentication service, a REST module to access that service, a router module to handle routes related to logging in and out of the website, and changes in\u00a0`app.mjs`\u00a0to use those modules. We're almost ready, but we've got a number of changes left that need to be made to the templates. We're passing the `req.user` object to every template because each one must be changed to accommodate whether the user is logged in.\u00a0\n\nThis means that we can test whether the user is logged in simply by testing for the presence of a `user` variable.\n\nIn `partials/header.hbs`, make the following additions:\n\n```", "```js\\1\n\nThis is a simple form decorated with Bootstrap goodness to ask for the username and password. When submitted, it creates a `POST` request to `/users/login`, which invokes the desired handler to verify the login request. The handler for that URL will start the Passport process to decide\u00a0whether the user is authenticated.\n\nIn `views/notedestroy.hbs`, we want to display a message if the user is not logged in. Normally, the form to cause the note to be deleted is displayed, but if the user is not logged in, we want to explain the situation, as illustrated in the following code block:\n\n```", "```js\\1\n\nAs the text says, this will probably never be shown to users. However, it is useful to put something such as this in place since it may show up during development, depending on the bugs you create.\n\nIn `views/noteedit.hbs`, we require a similar change, as follows:\n\n```", "```js\\1\n\nIn the previous chapters, we built up quite a few combinations of models and databases for running the Notes application. Since we don't need those, we can strip most of them out from `package.json`. This leaves us with one, configured to use the Sequelize model for Notes, using the SQLite3 database, and to use the new user authentication service that we wrote earlier. All the other Notes data models are still available, just by setting the environment variables appropriately.\n\n`USER_SERVICE_URL` needs to match the port number that we designated for that service.\n\nIn one window, start the user authentication service, as follows:\n\n```", "```js\\1\n\nYou'll be greeted with the following message:\n\n![](img/ceb549b2-cf18-4dd8-9830-b8ef51822b0e.png)\n\nNotice the new button, Log in, and the lack of an ADD Note button. We're not logged in, and so\u00a0`partials/header.hbs` is rigged to show only the Log in button.\n\nClick on the Log in button, and you will see the login screen, as shown in the following screenshot:\n\n![](img/15c349d7-2754-4ef5-8749-7842178385cc.png)\n\nThis is our login form from `views/login.hbs`. You can now log in, create a note or three, and you might end up with the following messages on the home page:\n\n![](img/8dd14aa5-9173-4621-a7fa-9aa53572f658.png)\n\nYou now have both Log Out and ADD Note buttons. You'll notice that the Log Out button has the username (me) shown. After some thought and consideration, this seemed the most compact way to show whether the user is logged in, and which user is logged in. This might drive the user experience team nuts, and you won't know whether this user interface design works until it's tested with users, but it's good enough for our purpose at the moment.\n\nIn this section, we've learned how to set up a basic login/logout functionality using locally stored user information. This is fairly good, but many web applications find it useful to allow folks to log in using their Twitter or other social media accounts for authentication. In the next section, we'll learn about that by setting up Twitter authentication.\n\n# Providing Twitter login support for the Notes application\n\nIf you want your application to hit the big time, it's a great idea to ease the registration process by using third-party authentication. Websites all over the internet allow you to log in using\u00a0accounts from other services such as\u00a0Facebook or Twitter. Doing so removes hurdles to prospective users signing up for your service. Passport makes it extremely easy to do this.\n\nAuthenticating users with Twitter requires installation of `TwitterStrategy`\u00a0from the `passport-twitter` package, registering a new application with Twitter, adding a couple of routes to `routes/user.mjs`, and making a small change in `partials/header.hbs`. Integrating other third-party services requires similar steps.\n\n## Registering an application with Twitter\n\nTwitter, as with every other third-party service, uses OAuth\u00a0to handle authentication. OAuth is a standard protocol through which an application or a person can authenticate with one website by using credentials they have on another website. We use this all the time on the internet. For example, we might use an online graphics application such as\u00a0[draw.io](http://draw.io) or Canva by logging in with a Google account, and then the service can save files to our Google Drive.\u00a0\n\nAny application author must register with any sites you seek to use for authentication. Since we wish to allow Twitter users to log in to Notes using Twitter credentials, we have to register our Notes application with Twitter. Twitter then gives us a pair of authentication keys that will validate the Notes application with Twitter. Any application, whether it is a popular site such as Canva, or a new site such as Joe's Ascendant Horoscopes, must be registered with any desired OAuth authentication providers. The application author must then be diligent about keeping the registration active and properly storing the authentication keys.\n\nThe authentication keys are like a username/password pair. Anyone who gets a hold of those keys could use the service as if they were you, and potentially wreak havoc on your reputation or business.\n\nOur task in this section is to register a new application with Twitter, fulfilling whatever requirements Twitter has.\n\nTo register a new application with Twitter, go to [https://developer.twitter.com/en/apps](https://developer.twitter.com/en/apps).\u00a0\n\nAs you go through this process, you may be shown the following message:\n\n![](img/a2a51eab-1678-4207-b7fb-847230ed20fe.png)\n\nRecall that in recent years, concerns began to arise regarding the misuse of third-party authentication, the potential to steal user information, and the negative results that have occurred thanks to user data being stolen from social networks. As a result, social networks have increased scrutiny over developers using their APIs. It is necessary to sign up for a Twitter developer account, which is an easy process that does not cost anything.\n\nAs we go through this, realize that the Notes application needs a minimal amount of data. The ethical approach to this is to request only the level of access required for your application, and nothing more.\n\nOnce you're registered, you can log in to\u00a0`developer.twitter.com/apps` and see a dashboard listing the active applications you've registered. At this point, you probably do not have any registered applications. At the top is a button marked\u00a0*Create an App*. Click on that button to start the process of submitting a request to register a new application.\n\nEvery service offering OAuth authentication has an administrative backend similar to `developer.twitter.com/apps`. The purpose is so that certified application developers can administer the registered applications and authorization tokens. Each such service has its own policies for validating that those requesting authorization tokens have a legitimate purpose and will not abuse the service. The authorization token is one of the mechanisms to verify that API requests come from approved applications. Another mechanism is the URL from which API requests are made.\u00a0\n\nIn the normal case, an application will be deployed to a regular server, and is accessed through a domain name such as\u00a0`MyNotes.xyz`. In our case, we are developing a test application on our laptop, and do not have a public IP address, nor is there a domain name associated with our laptop. Not all social networks allow interactions from an application on an untrusted computer\u2014such as a developer's laptop\u2014to make API requests; however, Twitter does.\n\nAt the time of writing, there are several pieces of information requested by the Twitter sign-up process, listed as follows:\n\n*   **Name**: This is the application name, and it can be anything you like. It would be a good form to use \"`Test`\" in the name, in case Twitter's staff decide to do some checking.\n*   **Description**: Descriptive phrase\u2014and again, it can be anything you like. The description is shown to users during the login process. It's\u00a0good form to describe this as a test application.\n\n*   **Website**: This would be your desired domain name. Here, the help text helpfully suggests *If you don't have a URL yet, just put a placeholder here but remember to change it later*.\n*   **Allow this application to be used to sign in with Twitter**: Check this, as it is what we want.\n*   **Callback URL**: This is the URL to return to following successful authentication. Since we don't have a public URL to supply, this is where we specify a value referring to your laptop. It's been found that\u00a0`http://localhost:3000`\u00a0works just fine. macOS users have another option because of the\u00a0`.local`\u00a0domain name that is automatically assigned to their laptop.\u00a0\n*   **Tell us how this app will be used**: This statement will be used by Twitter to evaluate your request. For the purpose of this project, explain that it is a sample app from a book. It is best to be clear and honest about your intention.\n\nThe sign-up process is painless. However, at several points, Twitter reiterated the sensitivity of the information provided through the Twitter API. The last step before granting approval warned that Twitter prohibits the use of its API for various unethical purposes.\n\nThe last thing to notice is the extremely sensitive nature of the authentication keys. It's bad form to check these into a source code repository or otherwise put them in a place where anybody can access the key. We'll tackle this issue in [Chapter 14](4cccad1e-fe7e-495a-9e90-8818820b890a.xhtml),\u00a0*Security in Node.js Applications*.\n\nThe Twitter developers' site has documentation describing best practices for storing authentication tokens. Visit\u00a0[https://developer.twitter.com/en/docs/basics/authentication/guides/authentication-best-practices](https://developer.twitter.com/en/docs/basics/authentication/guides/authentication-best-practices).\n\n### Storing authentication tokens\n\nThe Twitter recommendation is to store configuration values in a `.env` file. The contents of this file are to somehow become environment variables, which we can then access using `process.env`, as we've done before. Fortunately, there is a third-party Node.js package to do just this, called `dotenv`.\n\nLearn about the `dotenv` package at\u00a0[https://www.npmjs.com/package/dotenv.](https://www.npmjs.com/package/dotenv)\n\nFirst, install the package, as follows:\n\n```", "```js\\1\n\nWith this approach, we do not have to explicitly call the `dotenv.config` function. The primary advantage is avoiding issues with referencing environment variables from multiple modules.\n\nThe next step is to create a file, `.env`, in the `notes` directory. The syntax of this file is very simple, as shown in the following code block:\n\n```", "```js\\1\n\nThese values mostly refer to database files we generated in the previous chapter. In the end, we've added the `.env` file, and because of this, Git will not commit this file to the repository.\n\nThis means that when deploying the application to a server, you'll have to arrange to add this file to the deployment without it being committed to a source repository.\u00a0\n\nWith an approved Twitter application, and with our authentication tokens recorded in a configuration file, we can move on to adding the required code to Notes.\n\n## Implementing TwitterStrategy\n\nAs with many web applications, we have decided to allow our users to log in\u00a0using Twitter credentials. The OAuth protocol is widely used for this purpose\u00a0and is the basis for authentication on one website using credentials maintained\u00a0by another website.\n\nThe application registration process you just followed at `developer.twitter.com` generated for you a pair of API keys: a consumer key, and a consumer secret. These keys are part of the OAuth protocol and will be supplied by any OAuth service you register with, and the keys should be treated with the utmost care. Think of them as the username and password your service uses to access the OAuth-based service (Twitter et al.). The more people who can see these keys, the more likely it becomes that a miscreant can see them and then cause trouble. Anybody with those secrets can access the service API as if they are you.\n\nLet's install the package required to use `TwitterStrategy`, as follows:\n\n```", "```js\\1\n\nThis imports the package, and then makes its `Strategy` variable available as `TwitterStrategy`.\n\nLet's now install the\u00a0`TwitterStrategy`, as follows:\n\n```", "```js\\1\n\nTo start the user logging in with Twitter, we'll send them to this URL. Remember that this URL is really `/users/auth/twitter`\u00a0and, in the templates, we'll have to use that URL. When this is called, the passport middleware starts the user authentication and registration process using `TwitterStrategy`.\n\nOnce the user's browser visits this URL, the OAuth dance begins. It's called a dance because the OAuth protocol involves carefully designed redirects between several websites. Passport sends the browser over to the correct URL at Twitter, where Twitter asks the user whether they agree to authenticate using Twitter, and then Twitter redirects the user back to your callback URL. Along the way, specific tokens are passed back and forth in a very carefully designed dance between websites.\n\nOnce the OAuth dance concludes, the browser lands at the URL designated in the following router declaration:\n\n```", "```js\\1\n\nThis adds a new button that, when clicked, takes the user to `/users/auth/twitter`, which\u2014of course\u2014kicks off the Twitter authentication process. The button is enabled only if Twitter support is enabled, as determined by the `twitterLogin` variable. This means that the router functions must be modified to pass in this variable.\n\nThis button includes a little image we downloaded from the official Twitter brand assets page at [https://about.twitter.com/company/brand-assets](https://about.twitter.com/company/brand-assets). Twitter recommends using these branding assets for a consistent look across all services using Twitter. Download the whole set, and then pick the one you like.\n\nFor the URL shown here, the corresponding project directory is named\u00a0`public/assets/vendor/twitter`. Notice that we force the size to be small enough for the navigation bar.\n\nIn `routes/index.mjs`, make the following change:\n\n```", "```js\\1\n\nThis is the same change, importing the variable and passing it to `res.render`.\n\nWith these changes, we're ready to try logging in with Twitter.\n\nStart the user information server as shown previously, and then start the Notes application server,\u00a0as shown in the following code block:\n\n```", "```js\\1\n\nThen, in one command window, run the following command:\n\n```", "```js\\1\n\nAs previously, this starts two instances of the Notes server, each with a different value in the `PORT` environment variable. In this case, each instance will use the same user authentication service. As shown here, you'll be able to visit the two instances at `http://localhost:3000` and `http://localhost:3002`. As before, you'll be able to start and stop the servers as you wish, see the same notes in each, and see that the notes are retained after restarting the server.\n\nAnother thing to try is to fiddle with the **session store**. Our session data is being stored in the `sessions` directory. These are just files in the filesystem, and we can take a look with normal tools such as\u00a0`ls`, as shown in the following code block:\n\n```", "```js\\1\n\nThe `bcrypt` documentation says that the correct version of this package must be used precisely for the Node.js version in use. Therefore, you should adjust the version number appropriately to the Node.js version you are using.\n\nThe strategy of storing an encrypted password dates back to the earliest days of Unix. The creators of the Unix operating system devised a means for storing an encrypted value in `/etc/passwd`, which was thought sufficiently safe\u00a0that the password file could be left readable to the entire world.\n\nLet's start with the user information service.\n\n## Adding password encryption to the user information service\n\nBecause of our command-line tool, we can easily test end-to-end password encryption. After verifying that it works, we can implement encryption in the Notes application.\n\nIn `cli.mjs`, add the following code near the top:\n\n```", "```js\\1\n\nThis takes a plain text password and runs it through the encryption algorithm. What's returned is the hash for the password.\n\nNext, in the commands for\u00a0`add`,\u00a0`find-or-create`*,* and\u00a0`update`, we make this same change, as follows:\n\n```", "```js\\1\n\nOf course, we need to bring in the module here to use its decryption function. This module will no longer store a plain text password, but instead, it will now store encrypted passwords. Therefore, it does not need to generate encrypted passwords, but the `bcrypt` package also has a function to compare a plain text password against the encrypted one in the database, which we will use.\n\nNext, scroll down to the `password-check` handler and modify it, like so:\n\n```", "```js\\1\n\nIn another window, we can create a new user, as follows:\n\n```", "```js\\1\n\nIndeed, the password field no longer has a plain text password, but what is\u2014surely\u2014encrypted text.\n\nNext, we should check that the `password-check` command behaves as expected:\u00a0\n\n```", "```js\\1\n\nAs before, this imports the `bcrypt` package and configures the complexity that will be used, and we have the same encryption function because we will use it from multiple places.\n\nNext, we must change the functions that interface with the backend server, as follows:\n\n```"]