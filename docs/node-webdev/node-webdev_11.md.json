["```js\\1\n\nThe paradigm couldn't be more explicit than this. The\u00a0`request` and the\u00a0`response` are right there.\n\nIt wasn't until JavaScript improved that we had a quite different paradigm. The new paradigm is interactive communication driven by browser-side JavaScript. This change in the web application model is called, by some, the real-time web. In some cases, websites keep an open connection to the web browser, send notifications, or update the page as it changes.\n\nFor some deep background on this, read about the Comet application architecture\u00a0introduced by Alex Russell in his blog in 2006 ([http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/](http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/)). That blog post called for a platform very similar to Node.js, years before Node.js existed.\n\nIn this chapter, we'll explore interactive dynamically updated content, as well as inter-user messaging, in the Notes application.\u00a0To do this, we'll lean on the Socket.IO library ([http://socket.io/](http://socket.io/)). This library simplifies two-way communication between the browser and server and can support a variety of protocols with fallback to old-school web browsers. It keeps a connection open continuously between browser and server, and it follows the `EventEmitter` model, allowing us to send events back and forth.\n\nWe'll be covering the following topics:\n\n*   An introduction to the Socket.IO library\n*   Integrating Socket.IO with an Express application, and with Passport\n*   Real-time communications in modern web browsers\n*   Using Socket.IO events:\n    *   To update application content as it changes\n    *   To send messages between users\n*   User experience for real-time communication\n*   Using Modal windows to support a user experience that eliminates page reloads\n\nThese sorts of techniques are widely used in many kinds of websites. This includes online chat with support personnel, dynamically updated pricing on auction sites, and dynamically updated social network sites.\n\nTo get started, let's talk about what Socket.IO is and what it does.\n\n# Introducing Socket.IO\n\nThe aim of Socket.IO is\u00a0to make real-time apps possible in every browser and mobile device*.\u00a0*It supports several transport protocols, choosing the best one for the specific browser.\n\nLook up the technical definition for the phrase\u00a0*real-time*\u00a0and you'll see the real-time web is not truly real-time. The actual meaning of\u00a0*real-time*\u00a0involves software with strict time boundaries that must respond to events within a specified time constraint. It is typically used in embedded systems to respond to button presses, for applications as diverse as junk food dispensers and medical devices in intensive care units. Eat too much junk food and you could end up in intensive care, and you'll be served by real-time software in both cases. Try and remember the distinction between different meanings for this phrase.\n\nThe proponents of the so-called real-time web should be calling it the pseudo-real-time-web, but that's not as catchy a phrase.\n\nWhat does it mean that Socket.IO uses the best protocol for the specific browser? If you were to implement your application with WebSockets, it would be limited to the modern browsers supporting that protocol. Because Socket.IO falls back on so many alternative protocols (WebSockets, Flash, XHR, and JSONP), it supports a wider range of web browsers.\n\nAs the application author, you don't have to worry about the specific protocol Socket.IO uses with a given browser. Instead, you can implement the business logic and the library takes care of the details for you.\n\nThe Socket.IO package includes both a server-side package and a client library. After an easy configuration, the two will communicate back and forth over a socket. The API between the server side and client side is very similar. Because a Socket.IO application runs code in both browser and server, in this chapter we will be writing code for both.\n\nThe model that Socket.IO provides is similar to the `EventEmitter` object. The programmer uses the `.on` method to listen for events and the `.emit` method to\u00a0send them. But with Socket.IO, an event is sent not just using its event name, but is targeted to a combination of two spaces maintained by Socket.IO \u2013 the\u00a0*namespace* and the\u00a0*room*. Further, the events are sent between the browser and the server rather than being limited to the Node.js process.\n\nInformation about Socket.IO is available at\u00a0[https://socket.io/](https://socket.io/).\n\nOn the server side, we wrap the HTTP Server object using the\u00a0Socket.IO library, giving us the Socket.IO Server object. The Server object lets us create two kinds of communication spaces,\u00a0*namespaces,* and\u00a0*rooms*. With it we can send messages, using the `emit` method, either globally or into one of those spaces. We can also listen for messages, using the `on` method, either globally or from a namespace or room.\n\nOn the client side, we load the library from the Socket.IO server. Then, client code running in the browser opens one or more communication channels to the server, and the client can connect to namespaces or rooms.\n\nThis high-level overview should help to understand the following work. Our next step is to integrate Socket.IO into the initialization of the Notes application.\n\n# Initializing Socket.IO with Express\n\nSocket.IO works by wrapping itself around an HTTP Server object. Think back to [Chapter 4](a883aeee-aa28-44c6-a02e-8238829cea90.xhtml), *HTTP Servers and Clients*, where we wrote a module that hooked into HTTP Server methods so that we could spy on HTTP transactions. The HTTP Sniffer attaches a listener to every HTTP event to print out the events. But what if you used that idea to do real work? Socket.IO uses a similar concept, listening to HTTP requests and responding to specific ones by using the Socket.IO protocol to communicate with client code in the browser.\n\nTo get started, let's first make a duplicate of the code from the previous chapter.\u00a0If you created a directory named `chap08` for that code, create a new directory\u00a0named `chap09` and copy the source tree there.\n\nWe won't make changes to the user authentication microservice, but we will use it for user authentication, of course.\n\nIn the Notes source directory, install these new modules:\n\n```", "```js\\1\n\nThis code brings in the required modules. The `socket.io` package supplies the core event-passing service. The `passport.socketio` module integrates Socket.IO with PassportJS-based user authentication. We will be reorganizing\u00a0`app.mjs` so that\u00a0session management will be shared between Socket.IO, Express, and Passport.\u00a0\n\nThe first change is to move the declaration of some session-related values to the top of the module, as we've done here:\n\n```", "```js\\1\n\nIn addition to moving some code from the bottom of `app.mjs`, we've added the initialization for Socket.IO. This is where the Socket.IO library wraps itself around the HTTP server object. Additionally, we're integrating it with the Passport library so that Socket.IO knows which sessions are authenticated.\n\nThe creation of the `app` and `server` objects is the same as before. All that's changed is the location in `app.mjs` where that occurred. What's new is the `io` object, which\u00a0is our entry point into the Socket.IO API, and it is used for all Socket.IO operations. This precise object must be made available to other modules wishing to use Socket.IO operations since this object was created by wrapping the HTTP server object. Hence, the `io` object is exported so that other modules can import it.\n\nBy invoking `socketio(server)`, we have given Socket.IO access to the HTTP server. It listens for incoming requests on the URLs through which Socket.IO does its work. That's invisible to us, and we don't have to think about what's happening under the covers.\n\nAccording to the Socket.IO internals, it looks like Socket.IO uses the `/socket.io` URL. That means our applications must avoid using this URL. See\u00a0[https://socket.io/docs/internals/](https://socket.io/docs/internals/).\n\nThe `io.use` function installs\u00a0functions\u00a0in Socket.IO that are similar to Express middleware, which the Socket.IO documentation even calls middleware. In this case, the middleware function is returned by calling `passportSocketIO.authorize`, and is how we integrate Passport authentication into Socket.IO.\n\nBecause we are sharing session management between Express and Socket.IO, we must make the following change:\n\n```", "```js\\1\n\nWe imported the `EventEmitter` class, made `AbstractNotesStore` a subclass of `EventEmitter`, and then added some methods to emit events. As a result, every `NotesStore` implementation now has an `on` and `emit` method, plus these three helper methods.\n\nThis is only the first step since nothing is emitting any events. We have to rewrite the create, update, and destroy methods in `NotesStore` implementations to call these methods so the events are emitted.\u00a0\n\nIn the interest of space, we'll show the modifications to one of the `NotesStore` implementations, and leave the rest as an exercise for you.\n\nModify these functions in `models/notes-sequelize.mjs`\u00a0as\u00a0shown in the following code:\n\n```", "```js\\1\n\nThis function is meant to be in place of such initialization.\n\nThen, in `app.mjs`, make this change:\n\n```", "```js\\1\n\nRemember that this is the initialized Socket.IO object we use to send messages to and from connected browsers. We will use it to send messages to the Notes home page.\n\nThen refactor the `router` function:\n\n```", "```js\\1\n\nThe primary purpose of this section is to listen to the create/update/destroy events, so we can update the browser. For each, the current list of Notes is gathered, then sent to the browser.\n\nAs we said, the Socket.IO package uses a model similar to the `EventEmitter` class. The `emit` method sends an event, and the policy of event names and event data is the same as with `EventEmitter`.\n\nCalling `io.of('/namespace')` creates a `Namespace` object for the named namespace. Namespaces are named in a pattern that looks like a pathname in Unix-like filesystems.\n\nCalling `io.of('/namespace').on('connect'...)` has the effect of letting server-side code know when a browser connects to the named namespace. In this case, we are using the `/home` namespace for the Notes home page. This has the side-effect of keeping the namespace active after it is created. Remember that `init` is called during the initialization of the server. Therefore, we will have created the `/home` namespace long before any web browser tries to access that namespace by visiting the Notes application home page.\n\nCalling `io.emit(...)` sends a broadcast message. Broadcast messages are sent to every browser connected to the application server. That can be useful in some situations, but in most situations, we want to avoid sending too many messages. To limit network data consumption, it's best to target each event to the browsers that need the event.\n\nCalling `io.of('/namespace').emit(...)` targets the event to browsers connected to the named namespace. When the client-side code connects to the server, it connects with one or more namespaces. Hence, in this case, we target the `notetitles` event to browsers attached to the `/home` namespace, which we'll see later is the Notes home page.\n\nCalling `io.of('/namespace').to('room')` accesses what Socket.IO calls a\u00a0`room`. Before a browser receives events in a room, it must\u00a0*join* the room. Rooms and namespaces are similar, but different, things. We'll use rooms later.\n\nThe next task accomplished in the\u00a0`init` function is to create the event listeners for the\u00a0`notecreated`,\u00a0`noteupdate`, and\u00a0`notedestroy`\u00a0events. The handler function for each emits a Socket.IO event,\u00a0`notetitles`, containing the list of note keys and titles.\n\nAs Notes are created, updated, and destroyed, we are now sending an event to the home page that is intended to refresh the page to match the change. The home page template, `views/index.hbs`, must be refactored to receive that event and rewrite the page to match.\n\n### Changing the home page and layout templates\n\nSocket.IO runs on both\u00a0the client and the server, with the two communicating back and\u00a0forth over the HTTP connection. So far, we've seen the server side of using Socket.IO to send events. The next step is to install a Socket.IO client on the Notes home page.\n\nGenerally speaking, every application page is likely to need a different Socket.IO client, since each page has different requirements. This means we must change how JavaScript code is loaded in Notes pages.\u00a0\n\nInitially, we simply put JavaScript code required by Bootstrap and FeatherJS at the bottom of `layout.hbs`. That worked because every page required the same set of JavaScript modules, but now we've identified the need for different JavaScript code on each page. Because the custom Socket.IO clients for each page\u00a0use jQuery for DOM manipulation, they must be loaded after jQuery is loaded. Therefore, we need to change\u00a0`layout.hbs`\u00a0to not load the JavaScript. Instead, every template will now be required to load the JavaScript code it needs. We'll supply a shared code snippet for loading the Bootstrap, Popper, jQuery, and FeatherJS libraries but beyond that, each template is responsible for loading any additional required JavaScript.\n\nCreate a file, `partials/footerjs.hbs`, containing the following code:\n\n```", "```js\\1\n\nThat is, we'll leave `layout.hbs` pretty much as it was, except for removing the JavaScript tags from the bottom. Those tags are now in `footerjs.hbs`.\u00a0\n\nWe'll now need to modify\u00a0every\u00a0template\u00a0(`error.hbs`,\u00a0`index.hbs`,\u00a0`login.hbs`,\u00a0`notedestroy.hbs`,\u00a0`noteedit.hbs`, and\u00a0`noteview.hbs`)\u00a0to, at the minimum, load\u00a0the `footerjs` partial.\n\n```", "```js\\1\n\nThis is what we meant when we said that each page will have its own Socket.IO client implementation. This is the client for the home page, but the client for the Notes view page will be different. This Socket.IO client connects to the `/home` namespace, then for `notetitles` events, it redraws the list of Notes on the home page.\n\nThe first `<script>` tag is where we load the Socket.IO client library, from `/socket.io/socket.io.js`.\u00a0You'll\u00a0notice\u00a0that we never set up any Express route to handle the\u00a0`/socket.io`\u00a0URL. Instead, the Socket.IO library did that for us.\u00a0Remember that the Socket.IO library handles every request starting with `/socket.io`, and this is one of such request it handles. The second `<script>` tag is where the page-specific client code lives.\n\nHaving client code within a\u00a0`$(document).ready(function() { .. })` block is typical when using jQuery. This, as the code implies, waits until the web page is fully loaded, and then calls the supplied function. That way, our client code is not only held within a private namespace; it executes only when the page is fully set up.\n\nOn the client side, calling `io()` or `io('/namespace')` creates a `socket` object. This object is what's used to send messages to the server or to receive messages from the server.\n\nIn this case, the client connects a `socket` object to the `/home` namespace, which is the only namespace defined so far. We then listen for the `notetitles` events, which is what's being sent from the server. Upon receiving that event, some jQuery DOM manipulation erases the current list of Notes and renders a new list on the screen. The same markup is used in both places.\n\nAdditionally, for this script to function, this change is required elsewhere in the template:\n\n```", "```js\\1\n\nThen, in another window, start the Notes application:\n\n```", "```js\\1\n\nThis enables debug tracing for the Notes application and the Socket.IO package.\n\nEnabling this in a browser is a little different since there are no environment variables. Simply open up the JavaScript console in your browser and enter this command:\n\n```", "```js\\1\n\nThis, of course, makes the `io` object available to code in this module. We're also importing a function from `index.mjs`\u00a0that is not currently exported. We will need to cause the home page to be updated, and therefore in `index.mjs`, make this change:\n\n```", "```js\\1\n\nFirst, we handle `connect` events on the `/notes` namespace. In the handler, we're looking for a `query` object containing the `key` for a Note. Therefore, in the client code, when calling `io('/notes')`\u00a0to connect with the server, we'll have to arrange to send that `key` value. It's easy to do, and we'll learn how in a little while.\n\nCalling `socket.join(roomName)` does what is suggested\u2014it causes this connection to join the named room. Therefore, this connection will be addressed as being in the `/notes` namespace, and in a room whose name is the `key` for a given Note.\n\nThe next thing is to add listeners for\u00a0the\u00a0`noteupdated`\u00a0and\u00a0`notedestroyed`\u00a0messages. In both, we are using this pattern:\n\n```", "```js\\1\n\nIn this section of the template, we add a pair of IDs to two elements. This enables the JavaScript code to target the correct elements.\n\nAdd this client code to `noteview.hbs`:\n\n```", "```js\\1\n\nWhile we could set up the URL query string this way, it's cleaner to do it the other way.\n\nWe need to call out a technique being used. These code snippets are written in a Handlebars template, and therefore the syntax `{{ expression }}`\u00a0is executed on the server, with the result of that expression to be substituted into the template. Therefore, the\u00a0`{{ expression }}` construct accesses server-side data. Specifically, `query: { key: '{{ notekey }}' }` is a data structure on the client side, but the `{{ notekey }}` portion is evaluated on the server. The client side does not see\u00a0`{{ notekey }}`, it sees the value\u00a0`notekey`\u00a0had on the server.\n\nFor the `noteupdated` event, we take the new note content and display it on the screen. For this to work, we had to add `id=` attributes to certain HTML elements so we could use jQuery selectors to manipulate the correct elements.\n\nAdditionally in `partials/header.hbs`, we needed to make this change as well:\n\n```", "```js\\1\n\nThis sets up the modules being used and also initializes the `EventEmitter` interface. We're also exporting the `EventEmitter` as `emitter` so other modules can be notified about messages as they're created or deleted.\n\nNow add this code for handling the database connection:\n\n```", "```js\\1\n\nThe\u00a0`sanitizedMessage`\u00a0function performs the same function as\u00a0`sanitizedUser`. In both cases, we are receiving a Sequelize object from the database, and we want to return a simple object to the caller. These functions produce that simplified object.\n\nNext, we have several functions to store new messages, retrieve messages, and delete messages.\u00a0\n\nThe first is this function:\n\n```", "```js\\1\n\nThis is to be called when a user requests that a message should be deleted. With Sequelize, we must first find the message and then delete it by calling its `destroy` method.\n\nAdd this function:\n\n```", "```js\\1\n\nThis imports the functions we just created so we can use them. And we also set up `debug` and `error` functions for tracing.\n\nAdd these event handlers to the `init` function in `routes/notes.mjs`:\n\n```", "```js\\1\n\nThis is the existing function to listen for connections from `/notes/view` pages, but with two new Socket.IO event handler functions. Remember that in the existing client code in `notesview.hbs`, it connects to the `/notes` namespace and supplies the note `key` as the room to join. In this section, we build on that by also setting up listeners for `create-message` and `delete-message` events when a note `key` has been supplied.\n\nAs the event names imply, the `create-message` event is sent by the client side when there is a new message, and the `delete-message` event is sent to delete a given message. The corresponding data model functions are called to perform those functions.\n\nFor the `create-message` event, there is an additional feature being used. This uses what Socket.IO calls an acknowledgment function.\n\nSo far, we've used the Socket.IO `emit` method with an event name and a data object. We can also include a `callback` function as an optional third parameter. The receiver of the message will receive the function and can call the function, and any data passed to the function is sent to the `callback` function. The interesting thing is this works across the browser-server boundary.\n\nThis means our client code will do this:\n\n```", "```js\\1\n\nThis is directly out of the\u00a0documentation for the\u00a0Bootstrap Modal component. The `btn-outline-dark` style matches the other buttons in this row, and between the `data-toggle` and the `data-target` attributes, Bootstrap knows which Modal window to pop up.\n\nLet's insert the definition for the matching Modal window in `views/noteview.hbs`:\n\n```", "```js\\1\n\nThat is, we want a section of jQuery code that's active only when there is a\u00a0`user`\u00a0object, meaning that this Note is being shown to a logged-in user.\n\nWithin that section, add this event handler:\n\n```", "```js\\1\n\nThat's simple enough: we retrieve the recent messages, then supply them to the `noteview.hbs` template. When we retrieve the messages, we supply the `/notes` namespace and a room name of the note `key`. It is now up to the template to render the messages.\n\nIn the `noteview.hbs` template, just below the\u00a0*delete*,\u00a0edit, and *comment*\u00a0buttons, add this code:\n\n```", "```js\\1\n\nThis is a handler for the Socket.IO `newmessage` event. What we have done is taken the same markup as is in the template, substituted values into it, and used jQuery to prepend the text to the top of the `noteMessages` area.\n\nRemember that we decided against using any ES6 goodness because a template string would sure be handy in this case. Therefore, we have fallen back on an older technique, the JavaScript `String.replace` method.\n\nThere is a common question, how do we replace multiple occurrences of a target string in JavaScript? You'll notice that the target `%id%` appears twice.\u00a0The best answer is to use `replace(/pattern/g, newText)`; in other words, you pass a regular expression and specify the `g` modifier to make it a global action. To those of us who grew up using `/bin/ed` and for whom `/usr/bin/vi` was a major advance,\u00a0we're nodding in recognition that this is the JavaScript equivalent to `s/pattern/newText/g`.\n\nWith this event handler, the message will now appear automatically when it is added by the user. Further, for another window simply viewing the Note the new message will appear automatically.\n\nBecause we use the jQuery `prepend` method, the message appears at the top. If you want it to appear at the bottom, then use `append`. And in `models/messages-sequelize.mjs`, you can remove the `DESC` attribute in `recentMessages` to change the ordering.\n\nThe last thing to notice is the markup includes a button with the `id=\"message-del-button\"`. This button is meant to be used to delete a message, and in the next section, we'll implement that feature.\n\n### Deleting messages on the Notes view page\n\nTo make the\u00a0`message-del-button` button active, we need to listen to click events on the button.\u00a0\n\nBelow the `newmessage` event handler, add this button click handler:\n\n```"]