["```js\\1\n\nThis module is what prints messages about HTTP requests on the terminal window. We'll look at how to configure this in the next section.\n\nVisit\u00a0[https://github.com/expressjs/morgan](https://github.com/expressjs/morgan)\u00a0for more information about `morgan`.\n\nAnother useful type of logging is debugging messages about an application. Debugging traces should be silent in most cases; they should only print information when debugging is turned on, and the level of detail should be configurable.\u00a0\n\nThe Express team uses the `debug`\u00a0package for debugging logs. These are turned on using the `DEBUG` environment variable, which we've already seen in use. We will see how to configure this shortly and put it to use in the `Notes` application. For more information, refer to\u00a0[https://www.npmjs.com/package/debug](https://www.npmjs.com/package/debug).\n\nFinally, the application might generate uncaught exceptions or unhandled Promises. The `uncaughtException`\u00a0and `unhandledRejection` errors must be captured, logged, and dealt with appropriately. We do not use the word\u00a0*must* lightly; these errors *must* be handled.\n\nLet's get started.\n\n## Request logging with morgan\n\nThe `morgan` package generates log files from the HTTP traffic arriving on an Express application. It has two general areas for configuration:\n\n*   Log format\n*   Log location\n\nAs it stands, `Notes` uses the `dev` format, which is described as a concise status output for developers. This can be used to log web requests as a way to measure website activity and popularity. The Apache log format already has a large ecosystem of reporting tools and, sure enough, `morgan` can produce log files in this format.\u00a0\n\nTo enable changing the logging format, simply change the following line in `app.mjs`:\n\n```", "```js\\1\n\nTo revert to the previous logging output, simply do not set this environment variable. If you've looked at Apache access logs, this logging format will look familiar. The `::1` notation at the beginning of the line is IPV6 notation for `localhost`, which you may be more familiar with as `127.0.0.1`.\n\nLooking at the documentation for `morgan`, we learn that it has several predefined logging formats available. We've seen two of them\u2014the `dev` format is meant to provide developer-friendly information, while the `common` format is compatible with the Apache log format. In addition to these predefined formats, we can create a custom log format by using various tokens.\n\nWe could declare victory on request logging and move on to debugging messages. However, let's look at logging directly to a file. While it's possible to capture `stdout` through a separate process, `morgan` is already installed on `Notes` and it provides the capability to direct its output to a file.\n\nThe `morgan` documentation suggests the following:\n\n```", "```js\\1\n\nThen, add the following code to `app.mjs`:\n\n```", "```js\\1\n\nIf the `REQUEST_LOG_FILE` variable is set, the other logger will direct logging to the file. Then, because the variable is set, this logger will be created and will direct logging to the console. Otherwise, if the variable is not set, the other logger will send logging to the console and this logger will not be created.\n\nWe use these variables as before, specifying them on the command line, as follows:\n\n```", "```js\\1\n\nAs expected, our log file has entries in Apache format. Feel free to add one or both of these environment variables to the script in `package.json` as well.\n\nWe've seen how to make a log of the HTTP requests and how to robustly record it in a file. Let's now discuss how to handle debugging messages.\n\n## Debugging messages\n\nHow many of us debug our programs by inserting `console.log` statements? Most of us do. Yes, we're supposed to use a debugger, and yes, it is a pain to manage the `console.log` statements and make sure they're all turned off before committing our changes. The `debug` package provides a better way to handle debug tracing, which is quite powerful.\n\nFor the documentation on the `debug` package, refer to\u00a0[https://www.npmjs.com/package/debug](https://www.npmjs.com/package/debug).\n\nThe Express team uses `DEBUG` internally, and we can\u00a0generate quite a detailed trace of what Express does by running `Notes`\u00a0this way:\n\n```", "```js\\1\n\nThis creates two functions\u2014`debug` and `dbgerror`\u2014which will generate debugging traces if enabled. The Debug package calls functions *debuggers*. The debugger named `debug` has a\u00a0`notes:debug`\u00a0specifier, while `dbgerror` has a\u00a0`notes:error`\u00a0specifier. We'll talk in more detail about specifiers shortly.\n\nUsing these functions is as simple as this:\n\n```", "```js\\1\n\nThis is adapted from the `httpsniffer.mjs` example from\u00a0[Chapter 4](a883aeee-aa28-44c6-a02e-8238829cea90.xhtml), *HTTP Servers and Clients*, and for every HTTP request, a little bit of information will be printed.\n\nThen, in `appsupport.mjs`, let's make two changes. Add the following to\u00a0the top of the\u00a0`onError`\u00a0function:\n\n```", "```js\\1\n\nThis changes the `console.log` call to a `debug` call so that a\u00a0`Listening on` message is printed only if debugging is enabled.\n\nIf we run the application with the `DEBUG` variable set appropriately, we get the following output:\n\n```", "```js\\1\n\nBecause these are events that are emitted from the `process` object, the way to handle them is to attach an event listener to these events. That's what we've done here.\n\nThe names of these events describe their meaning well. An `uncaughtException` event means an error was thrown but was not caught by a `try/catch` construct. Similarly, an\u00a0`unhandledRejection` event means a Promise ended in a rejected state, but there was no `.catch` handler.\n\nOur DevOps team will be happier now that we've handled these administrative chores. We've seen how to generate useful log files for HTTP requests, how to implement debug tracing, and even how to capture it to a file. We wrapped up this section by learning how to capture otherwise-uncaught errors.\n\nWe're now ready to move on to the real purpose of this chapter\u2014storing notes in persistent storage, such as in a database. We'll implement support for several database systems, starting with a simple system using files on a disk.\n\n# Storing notes in a filesystem\n\nFilesystems are an often-overlooked database engine. While filesystems don't have the sort of query features supported by database engines, they are still a reliable place to store files. The Notes schema is simple enough,\u00a0so the filesystem can easily serve as its data storage layer.\n\nLet's start by adding two functions to the `Note` class in\u00a0`models/Notes.mjs`:\n\n```", "```js\\1\n\nThis example code snippet produces a simple `Note` instance and then generates the JSON version of the note. Then, a new note is instantiated from that JSON string using `from JSON()`.\n\nNow, let's create a new module, `models/notes-fs.mjs`, to implement the filesystem datastore:\n\n```", "```js\\1\n\nThe `FSNotesStore` class is an implementation of\u00a0`AbstractNotesStore`, with a focus on storing the `Note` instances as JSON in a directory. These methods implement the API that we defined in [Chapter 5](582d3898-0135-430c-8b6e-8326f287e18b.xhtml), *Your First Express Application*. This implementation is incomplete since a couple of helper functions still need to be written, but you can see that it relies on files in the filesystem. For example, the `destroy` method simply uses `fs.unlink` to delete the note from the disk. In `keylist`, we use `fs.readdir` to read each\u00a0`Note` object and construct an array of keys for the notes.\n\nLet's add the helper functions:\n\n```", "```js\\1\n\nWe're now almost ready to run the `Notes` application, but there's an issue that first needs to be resolved with the `import()` function.\n\n## Dynamically importing ES6 modules\n\nBefore we start modifying the router functions, we have to consider how to account for multiple `AbstractNotesStore` implementations. By the end of this chapter, we will have several of them, and we want an easy way to configure `Notes` to use any of them. For example, an environment variable, `NOTES_MODEL`, could be used to specify the `Notes` data model to use, and the `Notes` application would dynamically load the correct module.\n\nIn `Notes`, we refer to the `Notes` datastore module from several places. To change from one datastore to another requires changing the source in each of these places. It would be better to locate that selection in one place, and further, to make it dynamically configurable at runtime.\n\nThere are several possible ways to do this. For example, in a CommonJS module, it's possible to\u00a0compute the pathname to the module for a `require` statement. It would consult the\u00a0environment variable, `NOTES_MODEL`, to calculate the pathname for the datastore module, as follows:\n\n```", "```js\\1\n\nThis is what we might call a factory function. It uses `import()` to load a module whose filename is calculated from the `model` parameter. We saw in `notes-fs.mjs` that the `FSNotesStore` class is the default export. Therefore, the `NotesStoreClass` variable gets that class, then\u00a0we\u00a0call the constructor to create an instance, and then we stash that instance in a global scope variable. That global scope variable is then exported as `NotesStore`.\n\nWe need to make one small change in `models/notes-memory.mjs`:\n\n```", "```js\\1\n\nWe need to remove\u00a0these two lines of code from `app.mjs`\u00a0and then add the following:\n\n```", "```js\\1\n\nThis added error handler will also cause the application to exit.\n\nThese changes also require us to make another change. The `NotesStore` variable is no longer in `app.mjs`, but is instead in `models/notes-store.mjs`. This means we need to go to\u00a0`routes/index.mjs`\u00a0and `routes/notes.mjs`, where we make the following change to the imports:\n\n```", "```js\\1\n\nWhen you add these entries to\u00a0`package.json`, make sure you use the correct JSON syntax. In particular, if you leave a comma at the end of the\u00a0`scripts`\u00a0section, it will fail to parse and\u00a0`npm`\u00a0will throw an error message.\n\nWith this code in place, we can now run the `Notes`\u00a0application, as follows:\n\n```", "```js\\1\n\nThis installs the version of `level` that the following code was written against.\n\nThen, create the\u00a0`models/notes-level.mjs` module, which will contain the `AbstractNotesStore` implementation:\n\n```", "```js\\1\n\nAs expected, we're creating a `LevelNotesStore`\u00a0class\u00a0to hold the functions.\u00a0\u00a0\n\nIn this case, we have code in the `close` function that calls `db.close` to close down the connection. The `level` documentation suggests that it is important to close the connection, so we'll have to add something to\u00a0`app.mjs` to ensure that the database closes when the server shuts down. The documentation also says that `level` does not support concurrent connections to the same database from multiple clients, meaning if we want multiple `Notes` instances to use the database, we should only have the connection open when necessary.\n\nOnce again, there is no difference between the\u00a0`create` and `update` operations, and so we use a `crupdate` function again. Notice that the pattern in all the functions is to first call `connectDB`\u00a0to get `db`, and then to call a function on the `db` object. In this case, we use `db.put` to store the `Note` object in the database.\n\nIn the `read` function, `db.get` is used to read the note. Since the `Note` data was stored as JSON, we use `Note.fromJSON` to decode and instantiate the `Note` instance.\n\nThe `destroy` function deletes a record from the database using the `db.del` function.\n\nBoth `keylist` and `count` use the `createKeyStream` function. This function uses an event-oriented interface to stream through every database entry, emitting events as it goes. A `data` event is emitted for each key in the database, while the `end` event is emitted at the end of the database, and the `error` event is emitted on errors. Since there is no simple way to present this as a simple `async` function, we have wrapped it with a Promise so that we can use `await`. We then invoke `createKeyStream`, letting it run its course and collect data as it goes. For `keylist`, in the `data` events, we add the data (in this case, the key to a database entry) to an array.\u00a0\n\nFor `count`, we use a similar process, and in this case, we simply increment a counter. Since we have this wrapped in a Promise, in an `error` event, we call `reject`, and in an `end` event, we call `resolve`.\n\nThen, we add the following to `package.json` in the `scripts` section:\n\n```", "```js\\1\n\nThe printout in the console will be the same, and the application will also look the same. You can put it through its paces to check whether everything works correctly.\n\nSince `level` does not support simultaneous access to a database from multiple instances, you won't be able to use the multiple `Notes`\u00a0application scenario. You will, however, be able to stop and restart the application whenever you want to without losing any notes.\n\nBefore we move on to looking at the next database, let's deal with a issue mentioned earlier\u2014closing the database connection when the process exits.\n\n## Closing database connections when closing the process\n\nThe `level` documentation says that we should close the database connection with `db.close`. Other database servers may well have the same requirement. Therefore, we should make sure we close the database connection before the process exits, and perhaps also on other conditions.\n\nNode.js provides a mechanism to catch signals sent by the operating system. What we'll do is configure listeners for these events, then close `NotesStore` in response.\n\n\u00a0Add the following code to\u00a0`appsupport.mjs`:\n\n```", "```js\\1\n\nSure enough, upon pressing\u00a0*Ctrl* + *C*, the `exit`\u00a0and `catchProcessDeath` listeners are called.\n\nThat covers the `level` database, and we also have the beginning of a handler to gracefully shut down the application. The next database to cover is an embedded SQL database that requires no server processes.\n\n# Storing notes in SQL with SQLite3\n\nTo get started with more normal databases, let's see how we can use SQL from Node.js. First, we'll use SQLite3, which is a lightweight, simple-to-set-up database engine eminently suitable for many applications.\n\nTo learn more\u00a0about this database engine, visit [http://www.sqlite.org/](http://www.sqlite.org/).\n\nTo learn more about the Node.js module, visit [https://github.com/mapbox/node-sqlite3/wiki/API](https://github.com/mapbox/node-sqlite3/wiki/API) or [https://www.npmjs.com/package/sqlite3](https://www.npmjs.com/package/sqlite3).\n\nThe primary advantage of SQLite3 is that it doesn't require a server; it is a self-contained, no-set-up-required SQL database. The SQLite3 team also claims that it is very fast and that large, high-throughput applications have been built with it. The downside to the SQLite3 package is that its API requires callbacks, so we'll have to use the Promise wrapper pattern.\n\nThe first step is to install the module:\n\n```", "```js\\1\n\nTo initialize the database table, we run the following command:\n\n```", "```js\\1\n\nRun the setup script:\n\n```", "```js\\1\n\nThis imports the required packages and makes the required declarations. The\u00a0`connectDB` function has a similar purpose to the one in `notes-level.mjs`: to manage the database connection. If the database is not open, it'll go ahead and open it, and it will even make sure that the database file is created (if it doesn't exist). If the database is already open, it'll simply be returned.\n\nSince the API used in the `sqlite3` package requires callbacks, we will have to wrap every function call in a Promise wrapper, as shown here.\n\nNow, add the following\u00a0to `models/notes-sqlite3.mjs`:\n\n```", "```js\\1\n\nIn\u00a0`close`, the task is to close the database. There's a little dance done here to make sure the global `db` variable is unset while making sure we can close the database by saving `db` as `_db`. The\u00a0`sqlite3`\u00a0package will report errors from\u00a0`db.close`, so we're making sure we report any errors:\n\n```", "```js\\1\n\nTo retrieve data using the `sqlite3` module, you use the `db.get`, `db.all`, or `db.each` functions. Since\u00a0our\u00a0`read`\u00a0method\u00a0only\u00a0returns one item, we use the\u00a0`db.get`\u00a0function to retrieve just the first row of the result set. By contrast, the `db.all` function returns all of the rows of the result set at once, and the `db.each` function retrieves one row at a time, while still allowing the entire result set to be processed.\n\nBy the way, this `read` function has a bug in it\u2014see whether you can spot the error. We'll read more about this in [Chapter 13](1c1eb7f2-8b1a-4f70-9f0a-94d865c739ef.xhtml),\u00a0*Unit Testing and Functional Testing*, when our testing efforts uncover the bug:\n\n```", "```js\\1\n\nIn `keylist`, the task is to collect the keys for all of the `Note` instances. As we said, `db.get`\u00a0returns only the first entry of the result set, while the `db.all`\u00a0function retrieves all the rows of the result set. Therefore, we use `db.all`, although\u00a0`db.each` would have been a good alternative.\n\nThe contract for this function is to return an array of note keys. The `rows` object from `db.all` is an array of results from the database that contains the data we are to return, but we use the `map` function to convert the array into the format required by this function:\n\n```", "```js\\1\n\nThis sets up the commands that we'll use to test `Notes`\u00a0on SQLite3.\n\nWe can run the server as follows:\n\n```", "```js\\1\n\nThe advantage of installing the SQLite3 command-line tools is that we can perform any database administration tasks without having to write any code.\u00a0\u00a0\n\nWe have seen how to use SQLite3 with Node.js. It is a worthy database for many sorts of applications, plus it lets us use a SQL database without having to set up a server.\n\nThe next package that we will cover is an **Object Relations Management** (**ORM**)\u00a0system that can run on top of several SQL databases.\n\n# Storing notes the ORM way with Sequelize\n\nThere are several popular SQL database engines, such as PostgreSQL, MySQL, and MariaDB. Corresponding to each are Node.js client modules that are similar in nature to the `sqlite3` module that we just used. The programmer is close to SQL, which can be good in the same way that driving a stick shift car is fun. But what if we want a higher-level view of the database so that we can think in terms of objects, rather than rows of a database table? **ORM**\u00a0systems provide a suitable higher-level interface, and even offer the ability to use the same data model with several databases. Just as driving an electric car provides lots of benefits at the expense of losing out on the fun of stick-shift driving, ORM produces lots of benefits, while also distancing ourselves from the SQL.\n\nThe **Sequelize** package ([http://www.sequelizejs.com/](http://www.sequelizejs.com/)) is Promise-based, offers strong, well-developed ORM features, and can connect to\u00a0SQLite3, MySQL, PostgreSQL, MariaDB, and MSSQL databases. Because Sequelize is Promise-based, it will fit naturally with the Promise-based application code we're writing.\n\nA prerequisite to most SQL database engines is having access to a database server. In the previous section, we skirted around this issue by using SQLite3, which requires no database server setup. While it's possible to install a database server on your laptop, right now, we want to avoid the complexity of doing so, and so we will use Sequelize to manage a SQLite3 database. We'll also see that it's simply a matter of using a configuration file to run the same Sequelize code against a hosted database such as MySQL. In\u00a0[Chapter 11](b3de2a00-b4df-4552-9cf6-b3f356ef05b9.xhtml), *Deploying Node.js Microservices with Docker*, we'll learn how to use Docker to easily set up a service, including database servers, on our laptop and deploy the exact same configuration to a live server.\u00a0Most web-hosting providers offer MySQL or PostgreSQL as part of their service.\n\nBefore we start on the code, let's install two modules:\n\n```", "```js\\1\n\nAs with the\u00a0SQLite3 module, the `connectDB` function manages the connection through Sequelize to a database server. Since the configuration of the Sequelize connection is fairly complex and flexible, we're not using environment variables for the whole configuration, but instead we use a YAML-formatted configuration file that will be specified in an environment variable. Sequelize uses four items of data\u2014the database name, the username, the password, and a parameters object.\n\nWhen we read in a YAML file, its structure directly corresponds to the object structure that's created. Therefore, with a YAML configuration file, we don't need to use up any brain cells developing a configuration file format. The YAML structure is dictated by the Sequelize `params` object, and our configuration file simply has to use the same structure.\n\nWe also allow overriding any of the fields in this file using environment variables. This will be useful when we deploy `Notes` using Docker so that we can configure database connections without having to rebuild the Docker container.\n\nFor a simple SQLite3-based database, we can use the following YAML file for configuration and name it `models/sequelize-sqlite.yaml`:\n\n```", "```js\\1\n\nThis is straightforward. The\u00a0`username`\u00a0and\u00a0`password`\u00a0fields\u00a0must correspond to the database credentials, while\u00a0`host`\u00a0and\u00a0`port`\u00a0will specify where the database is hosted. Set the\u00a0database's\u00a0`dialect`\u00a0parameter\u00a0and other connection information and you're good to go.\n\nTo use MySQL, you will need to install the base MySQL driver so that Sequelize can use MySQL:\n\n```", "```js\\1\n\nThe database connection is stored in the `sequelize` object, which is established by the\u00a0`connectDB` function that we just looked at (which we renamed `connectSequlz`) to instantiate a Sequelize instance.\u00a0We immediately return if the database is already connected.\n\nIn Sequelize, the `Model` class is where we define the data model for a given object. Each `Model` class corresponds to a database table. The `Model` class is a normal ES6 class, and we start by subclassing it to define the `SQNote` class. Why do we call it `SQNote`? That's because we already defined a `Note` class, so we had to use a different name in order to use both classes.\n\nBy calling `SQNote.init`, we initialize the `SQNote` model with the fields\u2014that is, the schema\u2014that we want it to store. The first argument to this function is the schema description and the second argument is the administrative data required by Sequelize.\n\nAs you would expect, the schema has three fields: `notekey`, `title`, and `body`. Sequelize supports a long list of data types, so consult the documentation for more on that. We are using `STRING` as the type for `notekey` and `title` since both handle a short text string up to 255 bytes long. The `body` field is defined as `TEXT` since it does not need a length limit. In the `notekey` field, you see it is an object with other parameters; in this case, it is described as the primary key and the\u00a0`notekey` values must be unique.\n\nOnline documentation can be found at the following locations:\nSequelize class:\u00a0[http://docs.sequelizejs.com/en/latest/api/sequelize/](http://docs.sequelizejs.com/en/latest/api/sequelize/) [](http://docs.sequelizejs.com/en/latest/api/sequelize/) Defining models:\u00a0[http://docs.sequelizejs.com/en/latest/api/model/](http://docs.sequelizejs.com/en/latest/api/model/)\n\nThat manages the database connection and sets up the schema. Now, let's add the `SequelizeNotesStore` class to\u00a0`models/notes-sequelize.mjs`:\n\n```", "```js\\1\n\nThat's what Sequelize and other ORM libraries do\u2014convert the high-level API into database operations such as SQL queries.\n\nTo read a note, we use the `findOne` operation again. There is the possibility of it returning an empty result, and so we have to throw an error to match. The contract for this function is to return a `Note` object, so we take the fields retrieved using Sequelize to create a clean `Note` instance.\n\nTo destroy a note, we use the `destroy` operation with the same `where` clause to specify which entry to delete. This means that, as in the equivalent SQL statement (`DELETE FROM SQNotes WHERE notekey = ?`), if there is no matching note, no error will be thrown.\n\nBecause the `keylist` function acts on all `Note` objects, we use the `findAll` operation. The difference between `findOne` and `findAll` is obvious from the names. While\u00a0`findOne` returns the first matching database entry,\u00a0`findAll` returns all of them. The `attributes` specifier limits the result set to include the named field\u2014namely, the `notekey` field. This gives us an array of objects with a field named `notekey`. We then use a\u00a0`.map` function to convert this into an array of note keys.\n\nFor the `count` function, we can just use the `count()` method to calculate the\u00a0required result.\n\nThis allows us to use Sequelize by setting `NOTES_MODEL` to `sequelize`.\n\nHaving set up the functions to manage the database connection and defined the `SequelizeNotesStore` class, we're now ready to test the `Notes` application.\n\n## Running the Notes application with Sequelize\n\nNow, we can get ready to run the `Notes`\u00a0application using Sequelize. We can run it against any database server, but let's start with SQLite3\\. Add the following declarations to the `scripts` entry in `package.json`:\n\n```", "```js\\1\n\nAs before, the application looks exactly the same because we haven't changed the `View` templates or CSS files. Put it through its paces and everything should work.\n\nYou will be able to start two instances; use separate browser windows to visit both instances and see whether they show the same set of notes.\n\nTo reiterate, to use the Sequelize-based model on a given database server, do the following:\n\n1.  Install and provision the database server instance; otherwise, get the connection parameters for an already-provisioned database server.\n2.  Install the corresponding Node.js driver.\n3.  Write a YAML configuration file corresponding to the connection parameters.\n4.  Create new `scripts` entries in `package.json` to automate starting `Notes` against the database.\n\nBy using Sequelize, we have dipped our toes into a powerful library for managing data in a database. Sequelize is one of several ORM libraries available for Node.js. We've already used the word\u00a0*comprehensive* several times in this section as it's definitely the best word to describe Sequelize.\u00a0\n\nAn alternative that is worthy of exploration is not an ORM library but is what's called a query builder. `knex` supports several SQL databases, and its role is to simplify creating SQL queries by using a high-level API.\n\nIn the meantime, we have one last database to cover before wrapping up this chapter: MongoDB, the leading NoSQL database.\n\n# Storing notes in MongoDB\n\nMongoDB is widely used with Node.js applications, a sign of which is the popular **MEAN** acronym: **MongoDB (or MySQL), Express, Angular, and Node.js**. MongoDB is one of the leading NoSQL databases, meaning it is a database engine that does not use SQL queries. It is described as a *scalable, high-performance, open source, document-oriented database*. It uses JSON-style documents with no predefined, rigid schema and a large number of advanced features. You can visit their website for more information and documentation at\u00a0[http://www.mongodb.org](http://www.mongodb.org).\n\nDocumentation on the Node.js driver for MongoDB can be found at [https://www.npmjs.com/package/mongodb](https://www.npmjs.com/package/mongodb) and [http://mongodb.github.io/node-mongodb-native/](http://mongodb.github.io/node-mongodb-native/).\n\nMongoose is a popular ORM for MongoDB ([http://mongoosejs.com/](http://mongoosejs.com/)). In this section, we'll use the native MongoDB driver instead, but Mongoose is a worthy alternative.\n\nFirst, you will need a running MongoDB instance. The Compose- ([https://www.compose.io/](https://www.compose.io/)) and ScaleGrid- ([https://scalegrid.io/](https://scalegrid.io/)) hosted service providers offer hosted MongoDB services. Nowadays, it is straightforward to host MongoDB as a Docker container as part of a system built of other Docker containers. We'll do this in\u00a0[Chapter 13](1c1eb7f2-8b1a-4f70-9f0a-94d865c739ef.xhtml), *Unit Testing and Functional Testing*.\n\nIt's possible to set up a temporary MongoDB instance for testing on, say, your laptop. It is available in all the operating system package management systems, or you can download a compiled package from [mongodb.com](https://www.mongodb.com). The MongoDB website also has instructions ([https://docs.mongodb.org/manual/installation/](https://docs.mongodb.org/manual/installation/)).\n\nFor Windows, it may be most expedient to use a cloud-hosted MongoDB instance.\n\nOnce installed, it's not necessary to set up MongoDB as a background service. Instead, you can run a couple of simple commands to get a MongoDB instance running in the foreground of a command window, which you can kill and restart any time you like.\n\nIn a command window, run the following:\n\n```", "```js\\1\n\nThis runs the Mongo client program with which you can run commands. The command language used here is JavaScript, which is comfortable for us.\n\nThis saves a *document* in the collection named `foo`. The second command finds all documents in `foo`, printing them out for you. There is only one document, the one we just inserted, so that's what gets printed. The `_id` field is added by MongoDB and serves as a document identifier.\n\nThis setup is useful for testing and debugging. For a real deployment, your MongoDB server must be properly installed on a server. See the MongoDB documentation for these instructions.\n\nWith a working MongoDB installation in our hands, let's get started with implementing the `MongoNotesStore` class.\n\n## A MongoDB model for the Notes application\n\nThe official Node.js MongoDB driver ([https://www.npmjs.com/package/mongodb](https://www.npmjs.com/package/mongodb)) is created by the MongoDB team. It is very easy to use, as we will see, and its installation is as simple as running the following command:\n\n```", "```js\\1\n\nThis sets up the required imports, as well as the functions to manage a connection with the MongoDB database.\n\nThe `MongoClient` class is used to connect with a MongoDB instance. The required URL, which will be specified through an environment variable, uses a straightforward format: `mongodb://localhost/`. The database name is specified via another environment variable.\n\nThe documentation for the MongoDB Node.js driver can be found at\u00a0[http://mongodb.github.io/node-mongodb-native/](http://mongodb.github.io/node-mongodb-native/).\n\nThere are both reference and API documentation available. In the *API* section, the\u00a0`MongoClient` and\u00a0`Db` classes are the ones that most relate to the code we are writing ([http://mongodb.github.io/node-mongodb-native/](http://mongodb.github.io/node-mongodb-native/)).\n\nThe `connectDB` function creates the database client object. This object is only created as needed. The connection URL is provided through the `MONGO_URL` environment variable.\n\nThe `db` function is a simple wrapper around the client object to access the database that is used for the `Notes` application, which we specify via the `MONGO_DBNAME` environment variable. Therefore, to access the database, the code will have to call `db().mongoDbFunction()`.\n\nNow, we can implement the `MongoDBNotesStore` class:\n\n```", "```js\\1\n\nThe `MONGO_URL` environment variable is the URL to connect with your MongoDB database. This URL is the one that you need to use to run MongoDB on your laptop, as outlined at the top of this section. If you have a MongoDB server somewhere else, you'll be provided with the relevant URL to use.\n\nYou can start the `Notes` application as follows:\n\n```"]