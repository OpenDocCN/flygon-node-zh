["```js\ncd Desktop\n```", "```js\nmkdir notes-node\n```", "```js\ncd notes-node\n```", "```js\nconsole.log('Starting app');\n```", "```js\nconst fs = require()\n```", "```js\nconst fs = require('fs');\n```", "```js\nfs.appendFile('greetings.txt', 'Hello world!');\n```", "```js\n// Orignal line \nfs.appendFile('greetings.txt', 'Hello world!');\n\n// Option one\nfs.appendFile('greetings.txt', 'Hello world!', function (err){\n  if (err) { \n    console.log('Unable to write to file');\n  }\n});\n\n// Option two\nfs.appendFileSync('greetings.txt', 'Hello world!');\n```", "```js\nconsole.log('Starting app.');\n\nconst fs = require('fs');\n\nfs.appendFile('greetings.txt', 'Hello world!');\n```", "```js\nconsole.log('Starting app.');\n\nconst fs = require('fs');\nconst os = require('os');\n\nfs.appendFile('greetings.txt', 'Hello world!');\n```", "```js\nconsole.log('Starting app.');\n\nconst fs = require('fs');\nconst os = require('os');\n\nvar user = os.userInfo();\n\nfs.appendFile('greetings.txt', 'Hello world!');\n```", "```js\nconsole.log('Starting app.');\n\nconst fs = require('fs');\nconst os = require('os');\n\nvar user = os.userInfo();\nconsole.log(user);\n// fs.appendFile('greetings.txt', 'Hello world!');\n```", "```js\nconsole.log('Starting app.');\n\nconst fs = require('fs');\nconst os = require('os');\n\nvar user = os.userInfo();\n\nfs.appendFile('greetings.txt', 'Hello world!');\n```", "```js\nconsole.log('Starting app.');\n\nconst fs = require('fs');\nconst os = require('os');\n\nvar user = os.userInfo();\n\nfs.appendFile('greetings.txt', 'Hello' + user.username + '!');\n```", "```js (tick) operator, which is available to the left of the *1* key on your keyboard. Then you type things as you normally would.\n\nThis means that we'll first type `hello`, then we'll add a space with the `!` (exclamation) mark, and just before `!`, we will put the name:\n\n```", "```js\n\nTo insert a JavaScript variable inside your template string, you use the `$` (dollar) sign followed by opening and closing curly braces. Then we will just reference a variable such as `user.username`:\n\n```", "```js\n\nNotice that the Atom editor actually picks up on the syntax of curly braces.\n\nThis is all it takes to use template strings; it's an ES6 feature available because you're using Node v6\\. This syntax is much easier to understand and update than the string/concatenation version we saw earlier.\n\nIf you run the code, it will produce the exact same output. We can run it, view the text file, and this time around, we have `Hello Gary!` twice, which is what we want here:\n\n![](img/3f725d56-9605-46bb-84cb-dd044a1308d7.png)\n\nWith this in place, we are now done with our very basic example and we're ready to start creating our own files for our notes application and requiring them inside `app.js` in the next section.\n\nFirst up, you learned that we can use `require` to load in modules. This lets us take existing functionality written by either the Node developers, a third-party library, or ourselves, and load it into a file so that it can be reusable. Creating reusable code is essential for building large apps. If you have to build everything in an app every time, no one would ever get anything done because they would get stuck at building the basics, things such as HTTP servers and web servers. There are already modules for such stuff, and we'll be taking advantage of the great npm community. In this case, we used two built-in modules, `fs` and `os`. We loaded them in using require and we stored the module results inside two variables. These variables store everything available to us from the module; in the case of `fs`, we use the `appendFile` method, and in the case of OS, we use the `userInfo` method. Together, we were able to grab the username and save it into a file, which is fantastic.\n\n# Require own files\n\nIn this section, you will learn how to use `require()` to load in other files that you created inside your project. This will let you move functions outside `app.js` into more specific files; this will make your application easier to scale, test, and update. To get started, the first thing we'll do is to make a new file.\n\n# Making a new file to load other files\n\nIn the context of our notes app, the new file will store various functions for writing and reading notes. As of now, you don't need to worry about that functionality, as we'll get into the detail later in the section, but we will create the file where it will eventually live. This file will be `notes.js`, and we'll save it inside the root of our application, right alongside `app.js` and `greetings.txt`, as shown here:\n\n![](img/37116f0e-f983-4ff1-a0b8-54ff1f419b0a.png)\n\nFor the moment, all we'll do inside `notes` is to use `console.log` to print a little log showing the file has been executed using the following code:\n\n```", "```js\n\nNow, we have `console.log` on the top of `notes` and one on the top of `app.js`. I'll change `console.log` in the `app.js` from `Starting app.` to `Starting app.js`. With this in place, we can now require the notes file. It doesn't export any functionality, but that's fine.\n\nBy the way, when I say export, I mean the notes file doesn't have any functions or properties that another file can take advantage of.\n\nWe'll look at how to export stuff later in the section. For now though, we'll load our module in much the same way we loaded in the built-in Node modules.\n\nLet's make `const`; I'll call this one notes and set it equal to the return result from `require()`:\n\n```", "```js\n\nInside the parentheses, we will pass in one argument that will be a string, but it will be a little different. In the previous section, we typed in the module name, but what we have in this case is not a module, but a file, `notes.js`. What we need to do is to tell Node where that file lives using a relative path.\n\nNow, relative paths start with `./` (a dot forward slash), which points to the current directory that the file is in. In this case, this points us to the `app.js` directory, which is the root of our project `notes-node`. From here, we don't have to go into any other folders to access `notes.js`, it's in the root of our project, so we can type its name, as shown in the following code:\n\n```", "```js\n\nWith this in place, we can now save `app.js` and see what happens when we run our application. I'll run the app using the `node app.js` command:\n\n![](img/037c3e53-2739-4a42-ae40-953bee14a3ca.png)\n\nAs shown in the preceding code output, we get our two logs. First, we get `Starting app.js` and then we get `Starting notes.js`. Now, `Starting notes.js` comes from the `note.js` file, and it only runs because we required the file inside of `app.js`.\n\nComment out this command line from the `app.js` file, as shown here:\n\n```", "```js\n\nSave the file, and rerun it from Terminal; you can see the `notes.js` file never executes because we never explicitly touch it.\n\nWe never call it inside Terminal as we do in the preceding example, and we never require.\n\nFor now though, we will be requiring it, so I'll uncomment that line.\n\nBy the way, I'm using command / (forward slash) to comment and uncomment lines quickly. This is a keyboard shortcut available in most text editors; if you're on Windows or Linux, it might not be *command*, it might be *Ctrl* or something else.\n\n# Exporting files from note.js to use in app.js\n\nFor now though, the focus will be to export something from `notes.js` which we can use in `app.js`. Inside `notes.js` (actually, inside all of our Node files), we have access to a variable called `module`. I'll use `console.log` to print `module` to the screen so that we can explore it over in Terminal, as shown here:\n\n```", "```js\n\nLet's rerun the file to explore it. As shown in the following screenshot, we get a pretty big object, that is, different properties related to the `notes.js` file:\n\n![](img/a98531ef-4b8b-4456-99b1-5c2e44de387a.png)\n\nNow, to tell the truth, we'll not be using most of these properties. We have things such as `id`, `exports`, `parent`, and `filename`. The only one property we'll ever use in this book is `exports`.\n\nThe `exports` object on the `module` property and everything on this object gets exported. This object gets set as the `const` variable, `notes`. This means that we can set properties on it, they will get set on notes, and we can use them inside `app.js`.\n\n# A simple example of the working of the exports object\n\nLet's take a quick look at how that works. What we'll do is to define an `age` property using `module.exports`, the object we just explored over in Terminal. Also, we know that it's an object because we can see it in the preceding screenshot (`exports: {}`); this means that I can add a property, `age`, and set it equal to my age, which is `25`, as shown here:\n\n```", "```js\n\nThen I can save this file and move into `app.js` to take advantage of this new `age` property. The `const` variable notes will be storing all of my exports, in the present case, just age.\n\nIn `fs.appendFile`, after the `greeting.txt` file, I'll add `You are` followed by the age. Inside template strings, we will use `$` with curly braces, `notes.age`, and a period at the end, as shown here:\n\n```", "```js\n\nNow our greeting should say `Hello Gary! You are 25`. It's getting the `25` value from our separate file (that is, `note.js`), which is fantastic.\n\nLet's take a quick moment to rerun the program over in Terminal using the up arrow key and e*nter* keys:\n\n![](img/093236f1-6c23-40e7-8649-618d90932157.png)\n\nBack inside the app, we can open `greetings.txt`, and as shown in the following screenshot, we have `Hello Gary! You are 25`:\n\n![](img/087ca523-8167-4c0d-8ae4-0617bed2c9a0.png)\n\nUsing `require()`, we were able to require a file that we created, and this file stored some properties that were advantageous to the rest of the project.\n\n# Exporting the functions\n\nNow, obviously, the preceding example is pretty contrived. We'll not be exporting static numbers; the real goal of exports is to be able to export functions that get used inside `app.js`. Let's take a quick moment to export two functions. In the `notes.js` file, I'll set `module.exports.addnote` equal to a function; the `function` keyword followed by opening and closing parentheses, which is followed by the curly braces:\n\n```", "```js\n\nNow, throughout the course, I'll be using arrow functions where I can, as shown in the preceding code. To convert a regular ES5 function into an arrow function, all you do is remove the `function` keyword and replace it with an `=>` sign right between the parentheses and the opening curly braces, as shown here:\n\n```", "```js\n\nNow, there are some more subtleties to arrow functions that we'll be talking about throughout the book, but if you have an anonymous function, you can swap it with an arrow function without any problems. The big difference is that the arrow function is not going to bind the `() => {}` keyword or the arguments array, which we'll be exploring throughout the book. So if you do get some errors, it's good to know that the arrow function could be the cause.\n\nFor now though, we'll keep things really simple, using `console.log` to print `addNote`. This will let us know that the `addNote` function was called. We'll return a string, `'New note'`, as shown here:\n\n```", "```js\n\nNow, the `addNote` function is being defined in `notes.js`, but we can take advantage of it over in `app.js`.\n\nLet's take a quick second to comment out both the `appendFile` and user line in `app.js`:\n\n```", "```js\n\nI'll add a variable, call the result, (`res` for short), and set it equal to the return result from `notes.addNote`:\n\n```", "```js\n\nNow, the `addNote` function is a dummy function for the moment. It doesn't take any arguments and it doesn't actually do anything, so we can call it without any arguments.\n\nThen we'll print the result variable, as shown in the following code, and we would expect the result variable to be equal to the `New note` string:\n\n```", "```js\n\nIf I save both of my files (`app.js` and `notes.js`) and rerun things from Terminal, you can see that `New note` prints to the screen at the very end and just before `addNote` prints:\n\n![](img/effc1e66-5430-4eda-a5b0-9c0496ffcaa5.png)\n\nThis means that we successfully required the notes file we called `addNote`, and its return result was successfully returned to `app.js`.\n\nUsing this exact pattern, we'll be able to define our functions for adding and removing notes over in our `notes.js` file, but we'll be able to call them anywhere inside of our app, including in `app.js`.\n\n# Exercise \u2013 adding a new function to the export object\n\nNow it's time for a quick challenge. What I'd like you to do is make a new function in `notes.js` called `add`. This `add` function will get set on the `exports` object.\n\nRemember, `exports` is an object, so you can set multiple properties.\n\nThis `add` function will take two arguments, `a` and `b`; it'll add them together and return the result. Then over in `app.js`, I'd like you to call that `add` function, passing in two numbers, whatever you like, such as `9` and `-2`, then print the result to the screen and make sure it works correctly.\n\nYou can get started by removing the call to `addNote` since this will not be needed for the challenge.\n\nSo, take a moment, create that `add` function inside `notes.js`, call it inside `app.js`, and make sure the proper result prints to the screen. How'd it go? Hopefully, you were able to make that function and call it from `app.js`.\n\n# Solution to the exercise\n\nThe first step in the process will be to define the new function. In `notes.js`, I'll set `module.exports.add` equal to that function, as shown here:\n\n```", "```js\n\nLet's set it equal to an arrow function. If you used a regular function, that is perfectly fine, I just prefer using the arrow function when I can. Also, inside parentheses, we will be getting two arguments, we'll be getting `a` and `b`, as shown here:\n\n```", "```js\n\nAll we need to do is return the result, which is really simple. So we'll enter `return a + b`:\n\n```", "```js\n\nNow, this was the first part of your challenge, defining a utility function in `notes.js`; the second part was to actually use it over in `app.js`.\n\nIn `app.js`, we can use our function by printing the `console.log` result with a colon `:` (this is just for formatting). As the second argument, we'll print the actual results, `notes.add`. Then, we'll add up two numbers; we'll add `9` and `-2`, as shown in this code:\n\n```", "```js\n\nThe result in this case should be `7`. If we run the program you can see that we get just that, `7` prints to the screen:\n\n![](img/2d99dcfd-a8d3-4bee-9ed0-3cb9376d14e6.png)\n\nIf you were able to get this, congratulations, you successfully completed one of your first challenges. These challenges will be sprinkled throughout the book and they'll get progressively more complex. But don't worry, we'll keep the challenges pretty explicit; I'll tell you exactly what I want and exactly how I want it done. Now, you can play around with different ways to do it, the real goal is to just get you writing code independent of following someone else's lead. That is where the real learning happens.\n\nIn the next section, we will explore how to use third-party modules. From there, we'll start building the notes application.\n\n# Third-party modules\n\nYou now know two out of the three ways to use `require()`, and in this section, we'll explore the last way, which is to require a package you've installed from npm. As I mentioned in the first chapter, npm is a big part of what makes Node so fantastic. There is a huge community of developers that have created thousands of packages that already solve some of the most common problems in Node applications. We will be taking advantage of quite a few packages throughout the book.\n\n# Creating projects using npm modules\n\nNow, in the npm packages, there's nothing magical, it's regular Node code that aims to solve a specific problem. The reason you'd want to use it is so you don't have to spend all your time writing these utility functions that already exist; not only do they exist, they've been tested, they've been proven to work, and others have used them and documented them.\n\nNow, with all that said, how do we get started? Well, to get started, we actually have to run a command from the Terminal to tell our application we want to use npm modules. This command will be run over in the Terminal. Make sure you've navigated inside your project folder and inside the `notes-node` directory. Now, when you installed Node, you also installed something called npm.\n\nAt one point, npm stood for **Node package manager**, but that's now a running joke because there are plenty of things on npm that are not specific to Node. A lot of frontend frameworks, such as jQuery and react, now live on npm as well, so they've pretty much ditched the Node package manager explanation and now on their site, they cycle through a bunch of hilarious things that happen to match up with npm.\n\nWe will be running some npm commands and you can test that you have it installed by running `npm`, a space, and `-v` (we're running npm with the `v` flag). This should print the version, as shown in the following code:\n\n![](img/2fbd827c-06bf-47f8-b0cd-c92078d62e5d.png)\n\nIt's okay if your version is slightly different, that's not important; what is important is that you have npm installed.\n\nNow, we'll run a command called `npm init` in Terminal. This command will prompt us to fill out a few questions about our npm project. We can run the command and we can cycle through the questions, as shown in the following screenshot:\n\n![](img/fa3bdede-390d-4877-b36f-fab82a4d2bbb.png)\n\nIn the preceding screenshot, at the top is a quick description of what's happening, and down below it'll start asking you a few questions, as shown in the following screenshot:\n\n![](img/8d36696c-4caf-408a-b352-db86a16cf7e7.png)\n\nThe questions include the following:\n\n*   name: Your name can't have uppercase characters or spaces; you can use `notes-node`, for example. You can hit *enter* to use the default value, which is in parentheses.\n*   version: 1.0.0 works fine too; we will leave most of these at their default value.\n*   description: We can leave this empty at the moment.\n*   entry point: This will be `app.js`, make sure that shows up properly.\n*   test command: We'll explore testing later in the book, so for now, we can leave this empty.\n*   git repository: We'll leave that empty for now as well.\n*   keywords: These are used for searching for modules. We'll not be publishing this module so we can leave those empty.\n*   author: You might as well type your name.\n*   license: For the license, we'll stick with ISC at the moment; since we're not publishing it, it doesn't really matter.\n\nAfter answering these questions, if we hit e*nter*, we'll get the following on our screen and a final question:\n\n![](img/e71f1d89-0400-4a57-8405-8cbfceead0f6.png)\n\nNow, I want to dispel the myth that this command is doing anything magical. All this command is doing is creating a single file inside your project. It'll be in the root of the project and it's called `package.json`, and the file will look exactly like the preceding screenshot.\n\nTo the final question, as shown down below in the preceding image, you can hit e*nter* or type `yes` to confirm that this is what you want to do:\n\n![](img/9be2c9e8-b3f9-4a8b-a116-058652e2f3e7.jpg)\n\nNow that we have created the file, we can actually view it inside our project. As shown in the following code, we have the `package.json` file:\n\n```", "```js\n\nAnd this is all it is, it's a simple description of your application. Now, as I mentioned, we'll not be publishing our app to npm, so a lot of this information really isn't important to us. What is important, though, is that `package.json` is where we define the third-party modules we want to install in our application.\n\n# Installing the lodash module in our app\n\nTo install a module in the app, we will run a command over in the Terminal. In this chapter, we'll be installing a module called `lodash`. The `lodash` module comes with a ton of utility methods and functions that make developing inside Node or JavaScript a heck of a lot easier. To take a look at what exactly we're getting into, let's move into the browser.\n\nWe'll to go to [https://www.npmjs.com](https://www.npmjs.com). Then we'll search for the package, `lodash`, and you can see it comes up, as shown in the following screenshot:\n\n![](img/76628499-5b5d-48cd-af2b-adbb78842b1a.png)\n\nWhen you click on it, you should be taken to the package page, and the package page will show you a lot of statistics about the module and the documentation, as shown here:\n\n![](img/3d77137e-bdad-4eb0-a259-d73aedbdbe5f.png)\n\nNow, I use the `lodash` package page when I'm looking for new modules; I like to see how many downloads it has and when it was last updated. On the package page, you can see it was updated recently, which is great it means the package is most likely compatible with the latest versions of Node, and if you go further down the page, you can see this is actually one of the most popular npm packages, with over a million downloads a day. We will be using this module to explore how to install npm modules and how to actually use them in a project.\n\n# Installation of lodash\n\nTo install `lodash`, the first thing you need to grab is just a module name, which is `lodash`. Once you have that information, you're ready to install it.\n\nComing to Terminal, we'll run the `npm install` command. After installing, we'll specify the module, `lodash`. Now, this command alone would work; what we'll also do, though, is provide the `save` flag.\n\nThe `npm install lodash` command will install the module, and the `save` flag, `--` (two) hyphens followed by the word `save`, will update the contents of the `package.json` file. Let's run this command:\n\n```", "```js\n\nThe preceding command will go off to the npm servers and fetch the code and install it inside your project, and any time you install an npm module, it'll live in your project in a `node_modules` folder.\n\nNow, if you open that `node_modules` folder, you'll see the `lodash` folder as shown in the following code. This is the module that we just installed:\n\n```", "```js\n\nAs you can see over in `package.json` in the preceding figure, we've also had some updates automatically take place. There's a new `dependencies` attribute that has an object with key value pairs, where the key is the module we want to use in our project and the value is the version number, in this case, the most recent version, version `4.17.4`. With this in place, we can now require our module inside the project.\n\nOver inside `app.js`, we can take advantage of everything that comes in `lodash` by going through the same process of requiring it. We'll make a `const`, we'll name that `const _`, (which is a common name for the `lodash` utility library), and we'll set it equal to `require()`. Inside the require parentheses, we'll pass in the module name exactly as it appears in the `package.json` file. This is the same module name you used when you ran `npm install`. Then, we'll type `lodash`, as shown here:\n\n```", "```js\n\nNow, the order of operations is pretty important here. Node will first look for a core module with the name `lodash`. It'll not find one because there is no core module, so the next place it will look is the `node_modules` folder. As shown in the following code, it will find `lodash` and load that module, returning any of the exports it provides:\n\n```", "```js\n\n# Using the utilities of lodash\n\nWith the exports in place, we can now take advantage of some of the utilities that come with Lodash. We'll quickly explore two in this section, and we'll be exploring more throughout the book since Lodash is basically just a set of really handy utilities. Before we do, we should take a look at the documentation so we know exactly what we're getting into.\n\nThis is a really common step when you're using an npm module: first, you install it; second, you've got to look at those docs and make sure that you can get done what you want to get done.\n\nOn the npm page, click the lodash link given there, or go to [lodash.com](https://lodash.com) and click the API Documentation page, as shown here:\n\n![](img/7e1fe429-f974-4343-b6d8-c522192df5d9.png)\n\nYou can view all of the various methods you have available to you, as shown in the following screenshot:\n\n![](img/1396d946-2797-48fe-ba6a-877176597a7f.png)\n\nIn our case, we'll be using *command* + *F* (*Ctrl* + *F* for Windows users) to search for `_.isString`. Then in the docs, we can click on it, opening it up in the main page, as shown in the following screenshot:\n\n![](img/cb9b613b-b3cf-438e-94c1-2e3cef5ad7af.png)\n\nThe `_.isString` is a utility that comes with `lodash`, and it returns `true` if the variable you pass in is a string, and it returns `false` if the value you pass in is not a string. And we can prove that by using it over in Atom. Let's use this.\n\n# Using the _.isString utility\n\nTo use the `_.isString` utility, we'll add `console.log` in `app.js` to show the result to the screen and we'll use `_.isString`, passing in a couple of values. Let's pass in `true` first, then we can duplicate this line and we'll pass in a string such as `Gary`, as shown here:\n\n```", "```js\n\nWe can run our project over in the Terminal using the same command we've used previously, `node app.js`, to run our file:\n\n![](img/9561c991-5646-4e82-a72e-3ccbb9a76eb6.png)\n\nWhen we run the file, we get our two prompts that we've started both files, and we get `false` and then `true`. `false` comes because the Boolean is not a string, and `true` comes up because `Gary` is indeed a string, so it passes the test of `_.isString`. This is one of the many utility functions that comes bundled with `lodash`.\n\nNow, `lodash` can do a lot more than simple type checking. It comes with a bunch of other utility methods we can take advantage of. Let's explore one more utility.\n\n# Using _.uniq\n\nBack inside the browser, we can use c*ommand + F* again to search for a new utility, which is `_.uniq`:\n\n![](img/d4ce4612-1d7d-40cb-8d7e-67113d61f06b.png)\n\nThis unique method, simply takes an array and it returns that array with all duplicates removed. That means if I have the same number a few times or the same string, it'll remove any duplicates. Let's run this.\n\nBack inside Atom, we can add this utility into our project, we'll comment out our `_.isString` calls and we will make a variable called `filteredArray`. This will be the array without the duplicates, and what we'll do is call, after the equal sign, `_.uniq`.\n\nNow, as we know, this takes an array. And since we're trying to use the unique function, we'll pass in an array with some duplicates. Use your name twice as a string; I'll use my name once, followed by the number `1`, followed by my name again. Then I can use `1`, `2`, `3`, and `4` as shown here:\n\n```", "```js\n\nNow, if things go as planned, we should get an array with all the duplicates removed, which means we'll have one instance of `Gary`, one instance of `1`, and then `2`, `3`, and `4`, which don't have duplicates.\n\nThe last thing to do is to print that using `console.log` so we can view it inside the Terminal. I'll pass in this `filteredArray` variable to our `console.log` statement as shown in the following code:\n\n```", "```js\n\nFrom here, we can run our project inside Node. I'll use the last command, then I can press the e*nter* key, and you can see we get our array with all duplicates removed, as shown in the following code output:\n\n![](img/36269bde-30dd-40e0-83e2-54aeaaba939a.png)\n\nWe have one instance of the string `Gary`, one instance of the number `1`, and then we have `2`, `3`, `4`, exactly what we expected.\n\nThe `lodash` utility really is endless. There are so many functions that it can be kind of overwhelming to explore at first, but as you start creating more JavaScript and Node projects, you'll find yourself solving a lot of the same problems over and over again when it comes to sorting, filtering, or type checking, and in that case, it's best to use a utility such as `lodash` to get that lifting done. The `lodash` utility is great for the following reasons:\n\n*   You don't have to keep rewriting your methods\n*   It is well tested and it has been tried in production\n\nIf there were any issues, they've been sorted out by now.\n\n# The node_modules folder\n\nNow that you know how to use a third-party module, there is one more thing I want to discuss. That is the `node_modules` folder in general. When you take your Node project and you put it on GitHub, or you're copying it around or sending it to a friend, the `node_modules` folder really shouldn't be taken with you.\n\nThe `node_modules` folder contains generated code. This is not code you've written and you should never make any updates to the files inside Node modules because there's a pretty good chance they'll get overwritten next time you install some modules.\n\nIn our case, we've already defined the modules and the versions inside `package.json` as shown in the following code because we used that handy `save` flag:\n\n```", "```js\n\nThis actually means we can delete the `node_modules` folder completely. Now, we can copy the folder and give it to a friend, we can put it on GitHub, or whatever we want to do. When we want to get that `node_modules` folder back, all we have to do inside the Terminal is run the `npm install` command without any module names or any flags.\n\nThis command, when run without any names or flags, is going to load in your `package.json` file, grab all of the dependencies and install them. After running this command, the `node_modules` folder is going to look exactly as it looked before we deleted it. Now, when you are using Git and GitHub, instead of deleting the `node_modules` folder, you'll just ignore it from your repository.\n\nNow, what we have explored so far is a process we'll be going through a lot more throughout the book. So if npm still seems foreign or you're not quite sure why it's even useful, it will become clear as we do more with our third-party modules, rather than just type checking or looking for unique items in an array. There's a ton of power behind the npm community and we'll be harnessing that to our fullest as we make real-world apps.\n\n# Global modules\n\nOne of the major complaints I get is the fact that students have to restart the app from the Terminal every time they want to see the changes they just made inside their text editor. So, in this section, we'll take a look at how we can automatically restart our app as we make changes to the file. That means if I change from `Gary` to `Mike` and save it, it will automatically restart over in the Terminal.\n\n# Installing the nodemon module\n\nNow, to automatically restart our app as we make changes to a file, we have to install a command-line utility, and we'll do this using npm. To get started, we'll go to Google Chrome (or the browser you are using) and head over to [https://www.npmjs.com](https://www.npmjs.com), as we did previously in the I*nstalling the* *lodash* *module in our app* section, and the module we're looking for is called **nodemon**.\n\nThe nodemon will be responsible for watching our app for changes and restarting the app when those changes occur. Right here, as we see in the following screenshot, we can view the docs for nodemon as well as various other things such as current version numbers and so on:\n\n![](img/a70450e3-59e6-400c-9696-682c4daebf72.png)\n\nYou will also notice that it's a really popular module, with over 30,000 downloads a day. Now, this module is a little different from the one we used in the last section, that is, `lodash`. The `lodash` got installed and added into our project's `package.json` file as shown in the following code block:\n\n```", "```js\n\nThat means it went into our `node_modules` folder and we were able to require it in our `app.js` file (refer to the previous section for more detail). Nodemon, however, works a little differently. It's a command-line utility that gets executed from the Terminal. It will be a completely new way of starting our application, and to install modules to be run from the command line, we have to tweak the `install` command that we used in the last section.\n\nFor now, we can start off much the same way, though. We'll use `npm install` and type the name just like we did in the *Installing the* *lodash* *module in our app* section, but instead of using the `save` flag, we'll use the `g` flag, which is short for global, as shown here:\n\n```", "```js\n\nThis command installs `nodemon` as a global utility on your machine, which means it'll not get added to your specific project and you'll never require `nodemon`. Instead, you'll be running the `nodemon` command from Terminal, as shown here:\n\n![](img/55de7da7-2315-4ef3-90fa-9d1258a72b46.png)\n\nWhen we install `nodemon` using the preceding command, it'll go off to npm and fetch all of the code that comes with `nodemon`.\n\nAnd it'll add it into the installation where Node and npm live on your machine, outside the project you're working on.\n\nThe `npm install nodemon -g` command could be executed from anywhere in your machine; it does not need to be executed from the project folder since it doesn't actually update the project at all. With this in place, though, we now have a brand new command on our machine, `nodemon`.\n\n# Executing nodemon\n\nNodemon will get executed as Node did, where we type the command and then we type the file we want to start. In our case, `app.js` is the root of our project. When you run it, you'll see a few things, as shown here:\n\n![](img/3b8e4ff2-fdf4-40f5-9937-ef2c3f108cc8.png)\n\nWe'll see a combination of our app's output, along with `nodemon` logs that show you what's happening. As shown in the preceding code, you can see the version `nodemon` is using, the files it's watching, and the command it actually ran. Now, at this point, it's waiting for more changes; it already ran through the entire app and it'll keep running until another change happens or until you shut it down.\n\nInside Atom, we'll make a few changes to our app. Let's get started by changing `Gary` to `Mike` in `app.js`, and then we'll change the `filteredArray` variable to `var filteredArray = _.uniq(['Mike'])`, as shown in the following code:\n\n```", "```js\n\nNow, I'll be saving the file. In the Terminal window, you can see the app automatically restarted, and within a split second, the new output is shown on the screen:\n\n![](img/278c0e02-c056-47a8-9076-9c52309dd3fb.png)\n\nAs shown in the preceding screenshot, we now have our array with one item of string, `Mike`. And this is the real power of `nodemon`.\n\nYou can create your applications and they will automatically restart over in the Terminal, which is super useful. It'll save you a ton of time and a ton of headaches. You won't have to switch back and forth every time you make a small tweak. This also prevents a ton of errors where you are running a web server, you make a change, and you forget to restart the web server. You might think your change didn't work as expected because the app is not working as expected, but in reality, you just never restarted the app.\n\nFor the most part, we will be using `nodemon` throughout the book since it's super useful. It's only used for development purposes, which is exactly what we're doing on our local machine. Now, we'll move forward and start exploring how we can get input from the user to create our notes application. That will the topic of the next few sections.\n\nBefore we get started, we should clean up a lot of the code we've already written in this section. I'll remove all of the commented-out code in `app.js`. Then, I'll simply remove `os`, where we have `fs`, `os` and `lodash`, since we'll not be using it throughout the project. I'll also be adding a space between the third-party and Node modules and the files I've written, which are as follows:\n\n```", "```js\n\nI find this to be a good syntax that makes it a lot easier to quickly scan for either third-party or Node modules, or the modules that I've created and required.\n\nNext up, over in `notes.js`, we'll remove the `add` function; this was only added for demonstration purposes, as shown in the following figure. Then we can save both the `notes.js` and `app.js` files, and `nodemon` will automatically restart:\n\n```", "```js\n\nNow we can remove the `greetings.txt` file. That was used to demonstrate how the `fs` module works, and since we already know how it works, we can wipe that file. And last but not least, we can always shut down `nodemon` using C*trl* + *C*. Now we're back at the regular Terminal.\n\nAnd with this in place, now we should move on, figuring out how we can get input from the user, because that's how users can create notes, remove notes, and fetch their notes.\n\n# Getting input\n\nIf a user wants to add a note, we need to know the note's title as well as the body of the note. If they want to fetch a note, we need to know the title of the note they want to fetch, and all this information needs to come into our app. And note apps, don't really do anything cool until they get this dynamic user input. This is what makes your scripts useful and awesome.\n\nNow, throughout the book, we'll be creating note apps that get input from the user in a lot of different ways. We'll be using socket I/O to get real-time info from a web app, we'll be creating our own API so other websites and servers can make Ajax requests to our app, but in this section, we'll start things off with a very basic example of how to get user input.\n\nWe'll be getting input from the user inside the command line. That means when you run the app in the command line, you'll be able to pass in some arguments. These arguments will be available inside Node, and then we can do other things with them, such as create a note, delete a note, or return a note.\n\n# Getting input from the user inside the command line\n\nTo start things off, let's run our app from the Terminal. We'll run it pretty similarly to how we ran it in the earlier sections: we'll start with `node` (I'm not using `nodemon` since we'll be changing the input), then we'll use `app.js`, which is the file we want to run, but then we can still type other variables.\n\nWe can pass all sorts of command-line arguments in. We could have a command, and this would tell the app what to do, whether you want to add a note, remove a note, or list a note.\n\nIf we want to add a note, that might look as a command shown in the following code:\n\n```", "```js\n\nThis command will add a note; we can remove a note using the `remove` command, as shown here:\n\n```", "```js\n\nAnd we could list all of our notes using the `list` command:\n\n```", "```js\n\nNow, when we run this command, the app is still going to work as expected. Just because we passed in a new argument doesn't mean our app is going to crash:\n\n![](img/de190e41-6194-4b7e-ae63-0b7adc259456.png)\n\nAnd we actually have access to the `list` argument already, we're just not using it inside the application.\n\nTo access the command-line arguments your app was initialized with, you'll want to use that `process` object that we explored in the first chapter.\n\nWe can log out all of the arguments using `console.log` to print them to the screen; it's on the process object, and the property we're looking for is `argv`.\n\nThe `argv` object is short for arguments vector, or in the case of JavaScript, it's more like an arguments array. This will be an array of all the command-line arguments passed in, and we can use them to start creating our application.\n\nNow save `app.js` and it'll look like the following:\n\n```", "```js\n\nThen we'll rerun this file:\n\n![](img/d3077eb1-454a-4b2e-ab74-c7c0c8324ce5.png)\n\nNow, as shown in the preceding command output, we have three items which are as follows:\n\n*   The first one points to the executable for Node that was used.\n*   The second one points to the app file that was started; in this case, it was `app.js`.\n*   The third one is where our command-line arguments start to come into play. In it, we have our `list` showing up as a string.\n\nThat means we can access that third item in the array, and that will be the command for our notes application.\n\n# Accessing the command-line argument for the notes application\n\nLet's access the command-line argument in the array now. We'll make a variable called `command`, and set it equal to `process.argv`, and we'll grab the item in the third position (which is `list`, as shown in the preceding command output), which is the index of two as shown here:\n\n```", "```js\n\nThen we can log that out to the screen by logging out `command` the string. Then, as the second argument, I'll pass in the actual command that was used:\n\n```", "```js\n\nAnd this is just a simple log to keep track of how the app is getting executed. The cool stuff is going to come when we add if statements that do different things depending on that command.\n\n# Adding if/else statements\n\nLet's create an `if/else` block below the `console.log('Command: ', command);`. We'll add `if (command === 'add')`, as shown here:\n\n```", "```js\n\nIn this case, we'll go through the process of adding a `new note`. Now, we're not specifying the other arguments here, such as the title or the body (we'll discuss that in later sections). For now, `if` the `command` does equal `add`, we'll use `console.log` to print `Adding new note`, as shown in the following code:\n\n```", "```js\n\nAnd we can do the exact same thing with a command such as `list`. We'll add `else if (command === 'list')`, as shown here:\n\n```", "```js\n\nIf the command does equal the string `list`, we'll run the following block of code using `console.log` to print `Listing all notes`. We can also add an `else` clause if there is no command, which is `console.log ('Command not recognized')`, as shown here:\n\n```", "```js\n\nWith this in place, we can now rerun our app for a third time, and this time around, you'll see we have the command equal to list, and listing all notes shows up, as shown in the following code:\n\n```", "```js\n\nThis means we were able to use our argument to run different code. Notice that we didn't run `Adding new note` and we didn't run `Command not recognized`. We could, however, switch the `node app.js` command from `list` to `add`, and in that case, we'll get `Adding new note` printing, as shown in the following screenshot:\n\n![](img/475401cc-84e9-4785-a2b0-f676f103fba5.png)\n\nAnd if we run a command that doesn't exist, for example `read`, you can see `Command not recognized` prints as shown in the following screenshot:\n\n![](img/e9b6a001-067d-4224-aac3-449a3cdcbd07.png)\n\n# Exercise \u2013 adding two else if clauses to an if block\n\nNow, what I'd like you to do is add two more `else if` clauses to our `if` block, which will be as follows:\n\n*   One will be for the `read` command, which will be responsible for getting an individual note back\n*   Another one called `remove` will be responsible for removing the note\n\nAll you have to do is add the `else if` statement for both of them, and then just put a quick `console.log` printing something like `Fetching note` or `Removing note`.\n\nTake a moment to knock that out as your challenge for this section. Once you add those two `else if` clauses, run both of them from the Terminal and make sure your log shows up. If it does show up, you are done, you can move ahead with this section.\n\n# Solution to the exercise\n\nFor the solution, the first thing I'll do is to add an `else if` for `read`. I'll open and close my curly braces and hit e*nter* right in the middle so everything gets formatted correctly.\n\nIn the `else if` statement, I'll check whether the `command` variable equals the string `read`, as shown here:\n\n```", "```js\n\nIn the future, we'll be calling methods that update our local database with the notes.\n\nFor now, we'll use `console.log` to print `Reading note`:\n\n```", "```js\n\nThe next thing you need to do is add an `else if` clause that checks whether the `command` equals `remove`. In the `else if`, I'll open and close my condition and hit e*nter* just as I did in the previous `else if` clause; this time, I'll add `if` the `command` equals `remove`, we want to remove the note. And in that case, all we'll do is to use `console.log` to print `Reading note`, as shown in the following code:\n\n```", "```js\n\nAnd with this in place, we are done. If we refer to the code block, we've added two new commands we can run over in the Terminal, and we can test those:\n\n```", "```js\n\nFirst up, I'll run `node app.js` with the `read` command, and `Reading note` shows up:\n\n```", "```js\n\nThen I'll rerun the command; this time, I'll be using `remove`. And when I do that, `Removing note` prints to the screen, as shown in this screenshot:\n\n![](img/3f7acc58-ae65-4865-9d47-413e64f16ece.png)\n\nI'll wrap up my testing using a command that doesn't exist, and when I run that, you can see `Command not recognized` shows up.\n\n# Getting the specific note information\n\nNow, what we did in the previous subsection is step 1\\. We now have support for various commands. The next thing we need to figure out is how we'll get more specific information. For example, which note do you want to remove? Which note do you want to read? And what do you want the note text to be in the case of adding a note? This is all information we need to get from the Terminal.\n\nNow, getting it is going to be pretty similar to what we did earlier, and to show you what it looks like, we'll print the entire `argv` object once again, using the following command:\n\n```", "```js\n\nOver in the Terminal, we can now run a more complex command. Let's say we want to remove a note using the `node app.js remove` command, and we'll do that by its title. We might use the `title` argument, which looks like the following code:\n\n```", "```js\n\nIn this `title` argument, we have `--` (two) hyphens followed by the argument name, which is `title`, followed by the `=` (equals) sign. Then we can type our note title. Maybe the note title is `secrets`. This will pass the title argument into our application.\n\nNow, there are a couple of different ways you could format the `title` argument, which are as follows:\n\n*   You could have the title `secrets` like the one in the preceding command\n*   You could have title equals secrets inside quotes, which will let us use spaces in the title:\n\n```", "```js\n\n*   You can remove the `=` (equals) sign altogether and simply put a space:\n\n```", "```js\n\nNo matter how you choose to format your argument, these are all valid ways to pass in the title.\n\nAs you see in the preceding screenshot, I am using double quotes when wrapping my string. Now, if you switch to single quotes, it will not break on Linux or OS X, but it will break on Windows. That means when you're passing in command-line arguments such as the title or the note body, you'll want to wrap your strings, when you have spaces, in double quotes, not single. So, if you are using Windows and you're getting some sort of unexpected behavior with your arguments, make sure you're using double quotes instead of single; that should fix the issue.\n\nFor the moment, I'll keep the `=` (equals) sign and the quotes and rerun the command:\n\n```"]