["```js\nimport { createStore, applyMiddleware, compose } from \"redux\"; \nimport logger from 'redux-diff-logger'; \nconst storeEnhancer = compose( \n        applyMiddleware( logger ) \n      ); \n\nconst store = createStore( appReducer, storeEnhancer ); \n\n```", "```js\nimport React from \"react\"; \nimport { createDevTools } from \"redux-devtools\"; \nimport LogMonitor from \"redux-devtools-log-monitor\"; \nimport DockMonitor from \"redux-devtools-dock-monitor\"; \n\nconst DevTools = createDevTools( \n  <DockMonitor toggleVisibilityKey=\"ctrl-h\" \n               changePositionKey=\"ctrl-q\" \n               defaultPosition=\"bottom\" \n               defaultIsVisible={true}> \n    <LogMonitor theme=\"tomorrow\" /> \n  </DockMonitor> \n); \n\nexport default DevTools; \n\n```", "```js\nimport DevTools from \"./Components/DevTools.jsx\"; \n\nconst storeEnhancer = compose( \n        applyMiddleware( logger ), \n        DevTools.instrument() \n      ); \n\nconst store = createStore( appReducer, storeEnhancer ); \n\n```", "```js\nrender(<Provider store={store}> \n  <div> \n    <App /> \n    <DevTools /> \n  </div> \n </Provider>, document.querySelector( \"root\" ) ); \n\n```", "```js\n{ \n  \"presets\": [ \n     [\"env\", { \n      \"targets\": { \"node\": 7 }, \n      \"useBuiltIns\": true \n    }], \n    \"react\", \n    \"stage-3\" \n  ], \n\n  \"plugins\": [ \n    \"transform-class-properties\", \n    \"transform-decorators-legacy\" \n  ] \n} \n\n```", "```js\nimport { createStore } from \"redux\"; \nimport { toggleRecording } from \"./index\"; \n\ndescribe( \"Action creators\", () => { \n  describe( \"toggleRecording\", () => { \n    it( \"should return a valid action\", () => { \n      const FLAG = true, \n            action = toggleRecording( FLAG ); \n            expect( action.payload ).toEqual( { toggle: FLAG } ); \n    }); \n  }); \n}); \n\n```", "```js\n  const toggleRecording = createAction( \"TOGGLE_RECORDING\", ( toggle ) => ({ toggle }) ); \n\nthis becomes the unique identifier and therefore we can expect it in type property. \n\nexpect( action.type ).toEqual( \"TOGGLE_RECORDING\" ); \n\n```", "```js\nimport { createStore } from \"redux\"; \nimport { createReducer } from \"redux-act\"; \nimport { TAB_SCREENSHOT, SCREENSHOT_DEFAULT_FILENAME, ANIMATION_DEFAULT_FILENAME } from \"../Constants\"; \nimport { appReducer } from \"./index\"; \n\ndescribe( \"appReducer\", () => { \n  it( \"should return default state\", () => { \n    const DEFAULT_STATE = { \n      isRecording: false, \n      activeTab: TAB_SCREENSHOT, \n      screenshotFilename: SCREENSHOT_DEFAULT_FILENAME, \n      animationFilename: ANIMATION_DEFAULT_FILENAME, \n      screenshotInputError: \"\", \n      animationInputError: \"\" \n    }; \n    expect( appReducer() ).toEqual( DEFAULT_STATE ); \n  }); \n\n }); \n\n```", "```js\nimport { toggleRecording } from \"../Actions\"; \n\n```", "```js\nit( \"should return a new state for toggleRecording action\", () => { \n    const FLAG = true, \n          action = toggleRecording( FLAG ), \n          newState = appReducer( undefined, action ); \n    expect( newState.isRecording ).toEqual( FLAG ); \n  }); \n\n```", "```js\nimport * as fs from \"fs\"; \nfunction takeScreenshot( filePath ){ \n  appWindow.capturePage(( img ) => { \n    fs.writeFileSync( filePath, img, \"base64\" ); \n  }, { \n    format : \"png\", \n    datatype : \"raw\" \n  }); \n} \n\n```", "```js\n{ \n    audio: false, \n    video: { \n     mandatory: { \n      chromeMediaSource: \"desktop\", \n      chromeMediaSourceId: desktopStreamId, \n      minWidth: 1280, \n      maxWidth: 1920, \n      minHeight: 720, \n      maxHeight: 1080 \n     } \n   } \n} \n\n```", "```js\nnw.Screen.chooseDesktopMedia([ \"window\", \"screen\" ], ( mediaStremId ) => { \n      // mediaStremId \n    }); \n\n```", "```js\nimport * as fs from \"fs\"; \nconst appWindow = nw.Window.get(); \n\nexport default class Capturer { \n\n  constructor(){  \n    nw.Screen.chooseDesktopMedia([ \"window\", \"screen\" ], ( id) => { \n      this.start( id ); \n    }); \n  } \n\n  takeScreenshot( filename ){ \n    console.log( \"Saving screensho\" ); \n  } \n\n  start( desktopStreamId ){ \n    navigator.webkitGetUserMedia({ \n        audio: false, \n        video: { \n          mandatory: { \n            chromeMediaSource: \"desktop\", \n            chromeMediaSourceId: desktopStreamId, \n            minWidth: 1280, \n            maxWidth: 1920, \n            minHeight: 720, \n            maxHeight: 1080 \n          } \n        } \n      }, ( stream ) => { \n        // stream to HTMLVideoElement \n\n      }, ( error ) => { \n        console.log( \"navigator.getUserMedia error: \", error ); \n      }); \n\n  } \n} \n\n```", "```js\nstatic detectDesktopStreamId( done ){ \n    const dcm = nw.Screen.DesktopCaptureMonitor; \n    nw.Screen.Init(); \n    // New screen target detected \n    dcm.on(\"added\", ( id, name, order, type ) => { \n      // We are interested only in screens \n      if ( type !== \"screen\" ){ \n        return; \n      } \n      done( dcm.registerStream( id ) ); \n      dcm.stop(); \n    }); \n    dcm.start( true, true ); \n  } \n\n```", "```js\n  constructor(){ \n    Capturer.detectDesktopStreamId(( id ) => { \n      this.start( id ); \n    }); \n  } \n\n```", "```js\nexport default class Dom { \n\n  constructor(){ \n    this.canvas = document.createElement(\"canvas\") \n    this.video = Dom.createVideo(); \n  } \n\n   static createVideo(){ \n    const div = document.createElement( \"div\" ), \n          video = document.createElement( \"video\" ); \n    div.className = \"preview\"; \n    video.autoplay = true; \n    div.appendChild( video ); \n    document.body.appendChild( div ); \n    return video; \n  } \n\n } \n\n```", "```js\n.preview { \n  position: absolute; \n  left: -999px; \n  top: -999px; \n  width: 1px; \n  height: 1px; \n  overflow: hidden; \n}  \n\n```", "```js\n  getVideoFrameAsBase64() { \n    const context = this.canvas.getContext(\"2d\"), \n          width = this.video.offsetWidth, \n          height = this.video.offsetHeight; \n\n    this.canvas.width = width; \n    this.canvas.height = height; \n\n    context.drawImage( this.video, 0, 0, width, height ); \n\n    return this.canvas.toDataURL(\"image/png\") \n      .replace( /^data:image\\/png;base64,/, \"\" ); \n\n  } \n\n```", "```js\nconstructor( dom ){     \n     this.dom = dom; \n    Capturer.detectDesktopStreamId(( id ) => { \n      this.start( id ); \n    }); \n  } \n\n```", "```js\nstart( desktopStreamId ){ \n    navigator.webkitGetUserMedia( /* constaints */, ( stream ) => { \n        this.dom.video.srcObject = stream; \n      }, ( error ) => { \n        console.log( \"navigator.getUserMedia error: \", error ); \n      }); \n} \n\n```", "```js\ntakeScreenshot( filename ){ \n    const base64Data = this.dom.getVideoFrameAsBase64(); \n    fs.writeFileSync( filename, base64Data, \"base64\" ); \n  } \n\n```", "```js\nconst ICON = `./assets/icon-48x48.png`; \n//...  \ntakeScreenshot( filename ){ \n    const base64Data = this.dom.getVideoFrameAsBase64(); \n    fs.writeFileSync( filename, base64Data, \"base64\" ); \n    new Notification( \"Screenshot saved\",  { \n      body: `The screenshot was saved as ${filename}`, \n      icon: `./assets/icon-48x48.png` \n    }); \n\n  } \n\n```", "```js\n//... \nconst toBuffer = require( \"blob-to-buffer\" ); \n//... \nstart( desktopStreamId ){ \n    navigator.webkitGetUserMedia(/* constaints */, ( stream ) => { \n        let chunks = []; \n        this.dom.video.srcObject = stream; \n        this.mediaRecorder = new MediaRecorder( stream ); \n        this.mediaRecorder.onstop = ( e ) => { \n          const blob = new Blob( chunks, { type: \"video/webm\" }); \n          toBuffer( blob, ( err, buffer ) => { \n            if ( err ) { \n              throw err; \n            } \n            this.saveAnimationBuffer( buffer ); \n            chunks = []; \n          }); \n        } \n        this.mediaRecorder.ondataavailable = function( e ) { \n          chunks.push( e.data ); \n        } \n\n      }, ( error ) => { \n        console.log( \"navigator.getUserMedia error: \", error ); \n      }); \n\n  } \n\n```", "```js\nrecord( filename ){ \n    this.mediaRecorder.start(); \n    this.saveAnimationBuffer = ( buffer ) => { \n      fs.writeFileSync( filename, buffer, \"base64\" ); \n      new Notification( \"Animation saved\",  { \n        body: `The animation was saved as ${filename}`, \n        icon: ICON \n      }); \n    } \n  } \n\n  stop(){ \n    this.mediaRecorder.stop(); \n  } \n\n```", "```js\nimport * as fs from \"fs\"; \n\nexport default class Fsys { \n\n  static getStoredFiles( ext ){ \n    return fs.readdirSync( \".\" ) \n      .filter( (file) => fs.statSync( file ).isFile() \n          && file.endsWith( ext ) ) || [ ]; \n  } \n\n  saveFile( filenameRaw, data, ext ){ \n    const files = Fsys.getStoredFiles( ext ), \n          // Generate filename of the pattern like screenshot5.png \n          filename = filenameRaw.replace( \"{N}\", files.length + 1 ); \n    fs.writeFileSync( filename, data, \"base64\" ); \n    return filename; \n  } \n} \n\n```", "```js\n\nexport default class Capturer { \n\n  constructor( fsys, dom ){ \n    this.fsys = fsys; \n    this.dom = dom; \n    Capturer.detectDesktopStreamId(( id ) => { \n      this.start( id ); \n    }); \n  } \n\n```", "```js\nimport Fsys from \"./Service/Capturer/Fsys\"; \nimport Dom from \"./Service/Capturer/Dom\"; \nimport Capturer from \"./Service/Capturer\"; \n\nconst capturer = new Capturer( new Fsys(), new Dom() ); \n\nrender(<Provider store={store}> \n  <App capturer={capturer} /> \n </Provider>, document.querySelector( \"root\" ) ); \n\n```", "```js\n// Handle when clicked CAPTURE \n onCapture = () => { \n    const { states } = this.props; \n    this.props.capturer.takeScreenshot( states.screenshotFilename ); \n  } \n\n```", "```js\n// Handle when clicked RECORD \nonRecord = () => { \n    const { states } = this.props; \n    this.props.capturer.record( states.animationFilename ); \n    this.props.actions.toggleRecording( true ); \n  } \n // Handle when clicked STOP \n  onStop = () => { \n    this.props.capturer.stop(); \n    this.props.actions.toggleRecording( false ); \n  } \n\n```", "```js\nconst appWindow = nw.Window.get(); \n\nexport default class Tray { \n\n  tray = null; \n\n  constructor( ) { \n    this.title = nw.App.manifest.description; \n    this.removeOnExit(); \n  } \n\n  getItems = () => { \n    return [ /* */ ]; \n  } \n\n  render(){ \n    if ( this.tray ) { \n      this.tray.remove(); \n    } \n\n    const icon = \"./assets/\" + \n      ( process.platform === \"linux\" ? \"icon-48x48.png\" : \"icon-\n      32x32.png\" ); \n\n    this.tray = new nw.Tray({ \n      title: this.title, \n      icon, \n      iconsAreTemplates: false \n    }); \n\n    const menu = new nw.Menu(); \n    this.getItems().forEach(( item ) => menu.append( new nw.MenuItem( \n    item ))); \n\n    this.tray.menu = menu; \n\n  } \n\n  removeOnExit(){ \n    appWindow.on( \"close\", () => { \n      this.tray.remove(); \n      appWindow.hide(); // Pretend to be closed already \n      appWindow.close( true ); \n    }); \n    // do not spawn Tray instances on page reload \n    window.addEventListener( \"beforeunload\", () => this.tray.remove(), \n    false ); \n  } \n\n} \n\n```", "```js\nTake screenshot \nStart recording \nStop recording \n--- \nOpen \nExit \n\n```", "```js\nimport { toggleRecording } from \"../Actions\"; \nimport { SCREENSHOT_DEFAULT_FILENAME, ANIMATION_DEFAULT_FILENAME } from \"../Constants\"; \n\nexport default class Tray { \n // default file names \n  screenshotFilename = SCREENSHOT_DEFAULT_FILENAME; \n  animationFilename = ANIMATION_DEFAULT_FILENAME; \n  isRecording = false;  \n\n  constructor( capturer, store ) { \n    this.capturer = capturer; \n    this.store = store; \n} \n\n```", "```js\nconstructor( capturer, store ) { \n    //... \n    store.subscribe(() => { \n      const { isRecording, screenshotFilename, animationFilename } = \n      store.getState(); \n      this.screenshotFilename = screenshotFilename; \n      this.animationFilename = animationFilename; \n\n      if ( this.isRecording === isRecording ) { \n        return; \n      } \n      this.isRecording = isRecording; \n      this.render(); \n    });    \n\n  } \n\n```", "```js\ngetItems = () => { \n    return [ \n      { \n        label: `Take screenshot`, \n        click: () => this.capturer.takeScreenshot( \n        this.screenshotFilename ) \n      }, \n      { \n        label: `Start recording`, \n        enabled: !this.isRecording, \n        click: () => { \n          this.capturer.record( this.animationFilename ); \n          this.store.dispatch( toggleRecording( true ) ); \n        } \n      }, \n      { \n        label: `Stop recording`, \n        enabled: this.isRecording, \n        click: () => { \n          this.capturer.stop(); \n          this.store.dispatch( toggleRecording( false ) ); \n        } \n      }, \n      { \n        type: \"separator\" \n      }, \n      { \n        label: \"Open\", \n        click: () => appWindow.show() \n      }, \n      { \n        label: \"Exit\", \n        click: () => appWindow.close() \n      } \n    ]; \n  } \n\n```", "```js\nimport Shortcut from \"./Service/Shortcut\" \nconst tray = new Tray( capturer, store ); \ntray.render(); \n\n```", "```js\n  const shortcut = new nw.Shortcut({ \n      key: \"Shift+Alt+4\", \n      active: () => {} \n      failed: console.error \n    }); \n\nnw.App.registerGlobalHotKey( shortcut ); \nappWindow.on( \"close\", () => nw.App.unregisterGlobalHotKey( shortcut ) ); \nwindow.addEventListener( \"beforeunload\", () => nw.App.unregisterGlobalHotKey( shortcut ), false ); \n\n```", "```js\nconst appWindow = nw.Window.get(); \nimport { toggleRecording } from \"../Actions\"; \nimport { SCREENSHOT_DEFAULT_FILENAME, ANIMATION_DEFAULT_FILENAME, \n  TAKE_SCREENSHOT_SHORTCUT, RECORD_SHORTCUT, STOP_SHORTCUT } from \"../Constants\"; \n\nexport default class Shortcut { \n\n screenshotFilename = SCREENSHOT_DEFAULT_FILENAME; \n animationFilename = ANIMATION_DEFAULT_FILENAME; \n isRecording = false; \n\n constructor( capturer, store ) { \n\n    this.capturer = capturer; \n    this.store = store; \n\n    store.subscribe(() => { \n      const { isRecording, screenshotFilename, animationFilename } = \n      store.getState(); \n      this.screenshotFilename = screenshotFilename; \n      this.animationFilename = animationFilename; \n      this.isRecording = isRecording; \n    }); \n } \n\n registerOne( key, active ){ \n    const shortcut = new nw.Shortcut({ \n      key, \n      active, \n      failed: console.error \n    }); \n    // Register global desktop shortcut, which can work without focus. \n    nw.App.registerGlobalHotKey( shortcut ); \n    appWindow.on( \"close\", () => nw.App.unregisterGlobalHotKey( \n    shortcut ) ); \n    window.addEventListener( \"beforeunload\", () => \n    nw.App.unregisterGlobalHotKey( shortcut ), false ); \n } \n\n registerAll(){ \n  this.registerOne( TAKE_SCREENSHOT_SHORTCUT, () => \n  this.capturer.takeScreenshot( this.screenshotFilename ) ); \n  this.registerOne( RECORD_SHORTCUT, () => { \n    if ( this.isRecording ) { \n      return; \n    } \n    this.capturer.record( this.animationFilename ); \n    this.store.dispatch( toggleRecording( true ) ); \n  }); \n  this.registerOne( STOP_SHORTCUT, () => { \n    if ( !this.isRecording ) { \n      return; \n    } \n    this.capturer.stop(); \n    this.store.dispatch( toggleRecording( false ) ); \n  }); \n } \n\n} \n\n```", "```js\nexport const TAKE_SCREENSHOT_SHORTCUT = \"Shift+Alt+4\"; \nexport const RECORD_SHORTCUT = \"Shift+Alt+5\"; \nexport const STOP_SHORTCUT = \"Shift+Alt+6\"; \n\n```", "```js\ngetItems = () => { \n return [ \n    { \n      label: `Take screenshot (${TAKE_SCREENSHOT_SHORTCUT})`, \n   //... \n\n```"]